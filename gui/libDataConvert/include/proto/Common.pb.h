// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Numeric.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Common_2eproto;
class TAlignment;
struct TAlignmentDefaultTypeInternal;
extern TAlignmentDefaultTypeInternal _TAlignment_default_instance_;
class TEWidgetDescription;
struct TEWidgetDescriptionDefaultTypeInternal;
extern TEWidgetDescriptionDefaultTypeInternal _TEWidgetDescription_default_instance_;
class TIdentifier;
struct TIdentifierDefaultTypeInternal;
extern TIdentifierDefaultTypeInternal _TIdentifier_default_instance_;
class TVariant;
struct TVariantDefaultTypeInternal;
extern TVariantDefaultTypeInternal _TVariant_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::TAlignment* Arena::CreateMaybeMessage<::TAlignment>(Arena*);
template<> ::TEWidgetDescription* Arena::CreateMaybeMessage<::TEWidgetDescription>(Arena*);
template<> ::TIdentifier* Arena::CreateMaybeMessage<::TIdentifier>(Arena*);
template<> ::TVariant* Arena::CreateMaybeMessage<::TVariant>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TEIdentifierType : int {
  TEIdentifierType_Widget = 0,
  TEIdentifierType_WidgetType = 1,
  TEIdentifierType_Layout = 2,
  TEIdentifierType_LayoutType = 3,
  TEIdentifierType_WidgetAnimation = 4,
  TEIdentifierType_CompositeAnimation = 5,
  TEIdentifierType_Slot = 6,
  TEIdentifierType_Script = 7,
  TEIdentifierType_DataTrigger = 8,
  TEIdentifierType_Signal = 9,
  TEIdentifierType_Parameter = 10,
  TEIdentifierType_NodeParameter = 11,
  TEIdentifierType_LayoutGroup = 12,
  TEIdentifierType_LayoutState = 13,
  TEIdentifierType_UIComponentAction = 14,
  TEIdentifierType_ImportDefinition = 15,
  TEIdentifierType_ParameterValue = 16,
  TEIdentifierType_LayoutElementTemplate = 17,
  TEIdentifierType_Curve = 18,
  TEIdentifierType_TextProperty = 19,
  TEIdentifierType_GalResource = 20,
  TEIdentifierType_GalAttribute = 21,
  TEIdentifierType_GalUniform = 22,
  TEIdentifierType_GalNode = 23,
  TEIdentifierType_GalRenderPass = 24,
  TEIdentifierType_GalRenderOrderBin = 25
};
bool TEIdentifierType_IsValid(int value);
constexpr TEIdentifierType TEIdentifierType_MIN = TEIdentifierType_Widget;
constexpr TEIdentifierType TEIdentifierType_MAX = TEIdentifierType_GalRenderOrderBin;
constexpr int TEIdentifierType_ARRAYSIZE = TEIdentifierType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEIdentifierType_descriptor();
template<typename T>
inline const std::string& TEIdentifierType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEIdentifierType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEIdentifierType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEIdentifierType_descriptor(), enum_t_value);
}
inline bool TEIdentifierType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEIdentifierType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEIdentifierType>(
    TEIdentifierType_descriptor(), name, value);
}
enum TEInputModality : int {
  TEInputModality_Touch = 0,
  TEInputModality_Controller = 1,
  TEInputModality_Idle = 2
};
bool TEInputModality_IsValid(int value);
constexpr TEInputModality TEInputModality_MIN = TEInputModality_Touch;
constexpr TEInputModality TEInputModality_MAX = TEInputModality_Idle;
constexpr int TEInputModality_ARRAYSIZE = TEInputModality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEInputModality_descriptor();
template<typename T>
inline const std::string& TEInputModality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEInputModality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEInputModality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEInputModality_descriptor(), enum_t_value);
}
inline bool TEInputModality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEInputModality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEInputModality>(
    TEInputModality_descriptor(), name, value);
}
enum TEDayTime : int {
  TEDayTime_Day = 0,
  TEDayTime_Night = 1
};
bool TEDayTime_IsValid(int value);
constexpr TEDayTime TEDayTime_MIN = TEDayTime_Day;
constexpr TEDayTime TEDayTime_MAX = TEDayTime_Night;
constexpr int TEDayTime_ARRAYSIZE = TEDayTime_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEDayTime_descriptor();
template<typename T>
inline const std::string& TEDayTime_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEDayTime>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEDayTime_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEDayTime_descriptor(), enum_t_value);
}
inline bool TEDayTime_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEDayTime* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEDayTime>(
    TEDayTime_descriptor(), name, value);
}
enum TEScreenLocation : int {
  TEScreenLocation_FrontDriver = 0,
  TEScreenLocation_FrontPassenger = 1,
  TEScreenLocation_RearLeft = 2,
  TEScreenLocation_RearRight = 3,
  TEScreenLocation_InstrumentCluster = 4,
  TEScreenLocation_Hud = 5,
  TEScreenLocation_TouchController = 6
};
bool TEScreenLocation_IsValid(int value);
constexpr TEScreenLocation TEScreenLocation_MIN = TEScreenLocation_FrontDriver;
constexpr TEScreenLocation TEScreenLocation_MAX = TEScreenLocation_TouchController;
constexpr int TEScreenLocation_ARRAYSIZE = TEScreenLocation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEScreenLocation_descriptor();
template<typename T>
inline const std::string& TEScreenLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEScreenLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEScreenLocation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEScreenLocation_descriptor(), enum_t_value);
}
inline bool TEScreenLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEScreenLocation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEScreenLocation>(
    TEScreenLocation_descriptor(), name, value);
}
enum TEActiveCategory : int {
  TEActiveCategory_Media = 0,
  TEActiveCategory_Communication = 1,
  TEActiveCategory_Navigation = 2,
  TEActiveCategory_ConnectedDrive = 3,
  TEActiveCategory_Vehicle = 4,
  TEActiveCategory_Notifications = 5,
  TEActiveCategory_Invalid = 6
};
bool TEActiveCategory_IsValid(int value);
constexpr TEActiveCategory TEActiveCategory_MIN = TEActiveCategory_Media;
constexpr TEActiveCategory TEActiveCategory_MAX = TEActiveCategory_Invalid;
constexpr int TEActiveCategory_ARRAYSIZE = TEActiveCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEActiveCategory_descriptor();
template<typename T>
inline const std::string& TEActiveCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEActiveCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEActiveCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEActiveCategory_descriptor(), enum_t_value);
}
inline bool TEActiveCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEActiveCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEActiveCategory>(
    TEActiveCategory_descriptor(), name, value);
}
enum TEControllerType : int {
  TEControllerType_Standard = 0,
  TEControllerType_MainMenu = 1,
  TEControllerType_Speller = 2,
  TEControllerType_MapScale = 3,
  TEControllerType_Splitscreen = 4,
  TEControllerType_QuickAccess = 5,
  TEControllerType_Player = 6,
  TEControllerType_PieMenu = 7,
  TEControllerType_PreviewMap = 8,
  TEControllerType_Speller_Frequency = 9,
  TEControllerType_SplitConfig = 10,
  TEControllerType_IBA = 11,
  TEControllerType_Popup = 12,
  TEControllerType_Speller_Matrix = 13,
  TEControllerType_Speller_BatteryCharge = 14
};
bool TEControllerType_IsValid(int value);
constexpr TEControllerType TEControllerType_MIN = TEControllerType_Standard;
constexpr TEControllerType TEControllerType_MAX = TEControllerType_Speller_BatteryCharge;
constexpr int TEControllerType_ARRAYSIZE = TEControllerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEControllerType_descriptor();
template<typename T>
inline const std::string& TEControllerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEControllerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEControllerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEControllerType_descriptor(), enum_t_value);
}
inline bool TEControllerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEControllerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEControllerType>(
    TEControllerType_descriptor(), name, value);
}
enum TETouchEvent : int {
  TETouchEvent_None = 0,
  TETouchEvent_Start = 1,
  TETouchEvent_Update = 2,
  TETouchEvent_End = 3
};
bool TETouchEvent_IsValid(int value);
constexpr TETouchEvent TETouchEvent_MIN = TETouchEvent_None;
constexpr TETouchEvent TETouchEvent_MAX = TETouchEvent_End;
constexpr int TETouchEvent_ARRAYSIZE = TETouchEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETouchEvent_descriptor();
template<typename T>
inline const std::string& TETouchEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETouchEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETouchEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETouchEvent_descriptor(), enum_t_value);
}
inline bool TETouchEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETouchEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETouchEvent>(
    TETouchEvent_descriptor(), name, value);
}
enum TETouchGesture : int {
  TETouchGesture_Invalid = 0,
  TETouchGesture_Tap = 1,
  TETouchGesture_LongPress = 2,
  TETouchGesture_Pan = 3,
  TETouchGesture_PanX = 4,
  TETouchGesture_PanY = 5,
  TETouchGesture_Swipe = 6,
  TETouchGesture_SwipeX = 7,
  TETouchGesture_SwipeY = 8,
  TETouchGesture_Spread = 9,
  TETouchGesture_Pinch = 10,
  TETouchGesture_Scroll = 11,
  TETouchGesture_DoubleTap = 12,
  TETouchGesture_Rotate = 13,
  TETouchGesture_HandWriting = 14,
  TETouchGesture_RawInput = 15
};
bool TETouchGesture_IsValid(int value);
constexpr TETouchGesture TETouchGesture_MIN = TETouchGesture_Invalid;
constexpr TETouchGesture TETouchGesture_MAX = TETouchGesture_RawInput;
constexpr int TETouchGesture_ARRAYSIZE = TETouchGesture_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETouchGesture_descriptor();
template<typename T>
inline const std::string& TETouchGesture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETouchGesture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETouchGesture_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETouchGesture_descriptor(), enum_t_value);
}
inline bool TETouchGesture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETouchGesture* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETouchGesture>(
    TETouchGesture_descriptor(), name, value);
}
enum TETouchDevice : int {
  TETouchDevice_NotSet = 0,
  TETouchDevice_Screen = 1,
  TETouchDevice_Pad = 2,
  TETouchDevice_PadRueko = 3,
  TETouchDevice_Command = 4,
  TETouchDevice_Freespace = 5,
  TETouchDevice_All = 6
};
bool TETouchDevice_IsValid(int value);
constexpr TETouchDevice TETouchDevice_MIN = TETouchDevice_NotSet;
constexpr TETouchDevice TETouchDevice_MAX = TETouchDevice_All;
constexpr int TETouchDevice_ARRAYSIZE = TETouchDevice_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETouchDevice_descriptor();
template<typename T>
inline const std::string& TETouchDevice_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETouchDevice>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETouchDevice_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETouchDevice_descriptor(), enum_t_value);
}
inline bool TETouchDevice_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETouchDevice* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETouchDevice>(
    TETouchDevice_descriptor(), name, value);
}
enum TECursorType : int {
  TECursorType_List = 0,
  TECursorType_Speller = 1,
  TECursorType_MainMenu = 2,
  TECursorType_Store = 3,
  TECursorType_Speller_Matrix = 4,
  TECursorType_Speller_Frequency = 5,
  TECursorType_Functionlist = 6,
  TECursorType_QuickAccess = 7,
  TECursorType_Reading = 8,
  TECursorType_Pie = 9,
  TECursorType_InteractiveMap = 10,
  TECursorType_Speller_Extended = 11,
  TECursorType_Functionlist_Extended = 12,
  TECursorType_Link = 13,
  TECursorType_List_NoGlow = 14,
  TECursorType_Invalid = 15,
  TECursorType_Splitscreen = 16,
  TECursorType_Speller_Slider = 17,
  TECursorType_Popup = 18,
  TECursorType_PagePreview = 19,
  TECursorType_Lettersquare = 20,
  TECursorType_MainMenuWidget = 21,
  TECursorType_DragNDrop = 22,
  TECursorType_HorizontalList = 23,
  TECursorType_Toolbelt = 24
};
bool TECursorType_IsValid(int value);
constexpr TECursorType TECursorType_MIN = TECursorType_List;
constexpr TECursorType TECursorType_MAX = TECursorType_Toolbelt;
constexpr int TECursorType_ARRAYSIZE = TECursorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TECursorType_descriptor();
template<typename T>
inline const std::string& TECursorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TECursorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TECursorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TECursorType_descriptor(), enum_t_value);
}
inline bool TECursorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TECursorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TECursorType>(
    TECursorType_descriptor(), name, value);
}
enum TEFace : int {
  TEFace_Front = 1,
  TEFace_Back = 2,
  TEFace_FrontAndBack = 3,
  TEFace_None = 4
};
bool TEFace_IsValid(int value);
constexpr TEFace TEFace_MIN = TEFace_Front;
constexpr TEFace TEFace_MAX = TEFace_None;
constexpr int TEFace_ARRAYSIZE = TEFace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEFace_descriptor();
template<typename T>
inline const std::string& TEFace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEFace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEFace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEFace_descriptor(), enum_t_value);
}
inline bool TEFace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEFace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEFace>(
    TEFace_descriptor(), name, value);
}
enum TEWinding : int {
  TEWinding_ClockWise = 1,
  TEWinding_CounterClockWise = 2
};
bool TEWinding_IsValid(int value);
constexpr TEWinding TEWinding_MIN = TEWinding_ClockWise;
constexpr TEWinding TEWinding_MAX = TEWinding_CounterClockWise;
constexpr int TEWinding_ARRAYSIZE = TEWinding_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEWinding_descriptor();
template<typename T>
inline const std::string& TEWinding_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEWinding>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEWinding_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEWinding_descriptor(), enum_t_value);
}
inline bool TEWinding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEWinding* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEWinding>(
    TEWinding_descriptor(), name, value);
}
enum TECompareFunction : int {
  TECompareFunction_Never = 1,
  TECompareFunction_Less = 2,
  TECompareFunction_LessEqual = 3,
  TECompareFunction_Equal = 4,
  TECompareFunction_NotEqual = 5,
  TECompareFunction_GreaterEqual = 6,
  TECompareFunction_Greater = 7,
  TECompareFunction_Always = 8
};
bool TECompareFunction_IsValid(int value);
constexpr TECompareFunction TECompareFunction_MIN = TECompareFunction_Never;
constexpr TECompareFunction TECompareFunction_MAX = TECompareFunction_Always;
constexpr int TECompareFunction_ARRAYSIZE = TECompareFunction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TECompareFunction_descriptor();
template<typename T>
inline const std::string& TECompareFunction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TECompareFunction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TECompareFunction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TECompareFunction_descriptor(), enum_t_value);
}
inline bool TECompareFunction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TECompareFunction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TECompareFunction>(
    TECompareFunction_descriptor(), name, value);
}
enum TEBlendFactor : int {
  TEBlendFactor_Zero = 1,
  TEBlendFactor_One = 2,
  TEBlendFactor_SourceColor = 3,
  TEBlendFactor_InverseSourceColor = 4,
  TEBlendFactor_SourceAlpha = 5,
  TEBlendFactor_SourceAlphaSaturate = 6,
  TEBlendFactor_InverseSourceAlpha = 7,
  TEBlendFactor_DestinationColor = 8,
  TEBlendFactor_InverseDestinationColor = 9,
  TEBlendFactor_DestinationAlpha = 10,
  TEBlendFactor_InverseDestinationAlpha = 11,
  TEBlendFactor_ConstantColor = 12,
  TEBlendFactor_InverseConstantColor = 13,
  TEBlendFactor_ConstantAlpha = 14,
  TEBlendFactor_InverseConstantAlpha = 15
};
bool TEBlendFactor_IsValid(int value);
constexpr TEBlendFactor TEBlendFactor_MIN = TEBlendFactor_Zero;
constexpr TEBlendFactor TEBlendFactor_MAX = TEBlendFactor_InverseConstantAlpha;
constexpr int TEBlendFactor_ARRAYSIZE = TEBlendFactor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEBlendFactor_descriptor();
template<typename T>
inline const std::string& TEBlendFactor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEBlendFactor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEBlendFactor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEBlendFactor_descriptor(), enum_t_value);
}
inline bool TEBlendFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEBlendFactor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEBlendFactor>(
    TEBlendFactor_descriptor(), name, value);
}
enum TEBlendOperation : int {
  TEBlendOperation_None = 1,
  TEBlendOperation_Add = 2,
  TEBlendOperation_Subtract = 3,
  TEBlendOperation_ReverseSubtract = 4
};
bool TEBlendOperation_IsValid(int value);
constexpr TEBlendOperation TEBlendOperation_MIN = TEBlendOperation_None;
constexpr TEBlendOperation TEBlendOperation_MAX = TEBlendOperation_ReverseSubtract;
constexpr int TEBlendOperation_ARRAYSIZE = TEBlendOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEBlendOperation_descriptor();
template<typename T>
inline const std::string& TEBlendOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEBlendOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEBlendOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEBlendOperation_descriptor(), enum_t_value);
}
inline bool TEBlendOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEBlendOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEBlendOperation>(
    TEBlendOperation_descriptor(), name, value);
}
enum TEStencilOperation : int {
  TEStencilOperation_Zero = 1,
  TEStencilOperation_Keep = 2,
  TEStencilOperation_Replace = 3,
  TEStencilOperation_Decrement = 4,
  TEStencilOperation_DecrementWrap = 5,
  TEStencilOperation_Increment = 6,
  TEStencilOperation_IncrementWrap = 7,
  TEStencilOperation_Invert = 8
};
bool TEStencilOperation_IsValid(int value);
constexpr TEStencilOperation TEStencilOperation_MIN = TEStencilOperation_Zero;
constexpr TEStencilOperation TEStencilOperation_MAX = TEStencilOperation_Invert;
constexpr int TEStencilOperation_ARRAYSIZE = TEStencilOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEStencilOperation_descriptor();
template<typename T>
inline const std::string& TEStencilOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEStencilOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEStencilOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEStencilOperation_descriptor(), enum_t_value);
}
inline bool TEStencilOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEStencilOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEStencilOperation>(
    TEStencilOperation_descriptor(), name, value);
}
enum TETextureFilter : int {
  TETextureFilter_Nearest = 1,
  TETextureFilter_Linear = 2,
  TETextureFilter_NearestMipMapNearest = 3,
  TETextureFilter_NearestMipMapLinear = 4,
  TETextureFilter_LinearMipMapNearest = 5,
  TETextureFilter_LinearMipMapLinear = 6
};
bool TETextureFilter_IsValid(int value);
constexpr TETextureFilter TETextureFilter_MIN = TETextureFilter_Nearest;
constexpr TETextureFilter TETextureFilter_MAX = TETextureFilter_LinearMipMapLinear;
constexpr int TETextureFilter_ARRAYSIZE = TETextureFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextureFilter_descriptor();
template<typename T>
inline const std::string& TETextureFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextureFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextureFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextureFilter_descriptor(), enum_t_value);
}
inline bool TETextureFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextureFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextureFilter>(
    TETextureFilter_descriptor(), name, value);
}
enum TEScope : int {
  TEScope_None = 1,
  TEScope_Global = 2,
  TEScope_Scene = 3,
  TEScope_Local = 4
};
bool TEScope_IsValid(int value);
constexpr TEScope TEScope_MIN = TEScope_None;
constexpr TEScope TEScope_MAX = TEScope_Local;
constexpr int TEScope_ARRAYSIZE = TEScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEScope_descriptor();
template<typename T>
inline const std::string& TEScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEScope_descriptor(), enum_t_value);
}
inline bool TEScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEScope>(
    TEScope_descriptor(), name, value);
}
enum TETextureWrapMode : int {
  TETextureWrapMode_Repeat = 1,
  TETextureWrapMode_ClampToEdge = 2,
  TETextureWrapMode_MirroredRepeat = 3
};
bool TETextureWrapMode_IsValid(int value);
constexpr TETextureWrapMode TETextureWrapMode_MIN = TETextureWrapMode_Repeat;
constexpr TETextureWrapMode TETextureWrapMode_MAX = TETextureWrapMode_MirroredRepeat;
constexpr int TETextureWrapMode_ARRAYSIZE = TETextureWrapMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextureWrapMode_descriptor();
template<typename T>
inline const std::string& TETextureWrapMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextureWrapMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextureWrapMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextureWrapMode_descriptor(), enum_t_value);
}
inline bool TETextureWrapMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextureWrapMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextureWrapMode>(
    TETextureWrapMode_descriptor(), name, value);
}
enum TELayoutOrientation : int {
  TELayoutOrientation_Left = 0,
  TELayoutOrientation_Right = 1,
  TELayoutOrientation_Top = 2,
  TELayoutOrientation_Bottom = 3,
  TELayoutOrientation_Clockwise = 4,
  TELayoutOrientation_CounterClockwise = 5
};
bool TELayoutOrientation_IsValid(int value);
constexpr TELayoutOrientation TELayoutOrientation_MIN = TELayoutOrientation_Left;
constexpr TELayoutOrientation TELayoutOrientation_MAX = TELayoutOrientation_CounterClockwise;
constexpr int TELayoutOrientation_ARRAYSIZE = TELayoutOrientation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TELayoutOrientation_descriptor();
template<typename T>
inline const std::string& TELayoutOrientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TELayoutOrientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TELayoutOrientation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TELayoutOrientation_descriptor(), enum_t_value);
}
inline bool TELayoutOrientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TELayoutOrientation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TELayoutOrientation>(
    TELayoutOrientation_descriptor(), name, value);
}
enum TEPixelFormat : int {
  TEPixelFormat_DEPTH = 0,
  TEPixelFormat_DEPTH_STENCIL = 1,
  TEPixelFormat_STENCIL = 2,
  TEPixelFormat_LUMINANCE = 3,
  TEPixelFormat_ALPHA = 4,
  TEPixelFormat_LUMINANCE_ALPHA = 5,
  TEPixelFormat_RGB = 6,
  TEPixelFormat_RGBA = 7,
  TEPixelFormat_DEPTH16 = 10,
  TEPixelFormat_DEPTH24 = 11,
  TEPixelFormat_DEPTH32F = 12,
  TEPixelFormat_DEPTH24_STENCIL8 = 13,
  TEPixelFormat_DEPTH32F_STENCIL8 = 14,
  TEPixelFormat_R8 = 20,
  TEPixelFormat_RG8 = 21,
  TEPixelFormat_RGB8 = 22,
  TEPixelFormat_RGBA8 = 23,
  TEPixelFormat_R16F = 24,
  TEPixelFormat_RG16F = 25,
  TEPixelFormat_RGB16F = 26,
  TEPixelFormat_RGBA16F = 27,
  TEPixelFormat_R32F = 28,
  TEPixelFormat_RG32F = 29,
  TEPixelFormat_RGB32F = 30,
  TEPixelFormat_RGBA32F = 31,
  TEPixelFormat_BGR8 = 32,
  TEPixelFormat_RGB565 = 33,
  TEPixelFormat_RGBA4 = 34,
  TEPixelFormat_RGBA5551 = 35,
  TEPixelFormat_BGRA8 = 36,
  TEPixelFormat_SRGB8 = 37,
  TEPixelFormat_SRGBA8 = 38,
  TEPixelFormat_ETC2RGB = 39,
  TEPixelFormat_ETC2RGBA = 40
};
bool TEPixelFormat_IsValid(int value);
constexpr TEPixelFormat TEPixelFormat_MIN = TEPixelFormat_DEPTH;
constexpr TEPixelFormat TEPixelFormat_MAX = TEPixelFormat_ETC2RGBA;
constexpr int TEPixelFormat_ARRAYSIZE = TEPixelFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEPixelFormat_descriptor();
template<typename T>
inline const std::string& TEPixelFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEPixelFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEPixelFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEPixelFormat_descriptor(), enum_t_value);
}
inline bool TEPixelFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEPixelFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEPixelFormat>(
    TEPixelFormat_descriptor(), name, value);
}
enum TESizePolicy : int {
  TESizePolicy_Fix = 0,
  TESizePolicy_Grow = 1,
  TESizePolicy_Shrink = 2,
  TESizePolicy_Grow_Shrink = 3,
  TESizePolicy_Preferred = 4,
  TESizePolicy_Preferred_Grow = 5,
  TESizePolicy_Preferred_Shrink = 6,
  TESizePolicy_Preferred_Grow_Shrink = 7,
  TESizePolicy_Custom_Separator = 8
};
bool TESizePolicy_IsValid(int value);
constexpr TESizePolicy TESizePolicy_MIN = TESizePolicy_Fix;
constexpr TESizePolicy TESizePolicy_MAX = TESizePolicy_Custom_Separator;
constexpr int TESizePolicy_ARRAYSIZE = TESizePolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TESizePolicy_descriptor();
template<typename T>
inline const std::string& TESizePolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TESizePolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TESizePolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TESizePolicy_descriptor(), enum_t_value);
}
inline bool TESizePolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TESizePolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TESizePolicy>(
    TESizePolicy_descriptor(), name, value);
}
enum TEDataType : int {
  TEDataType_Int = 0,
  TEDataType_UInt = 1,
  TEDataType_Float = 2,
  TEDataType_Double = 3,
  TEDataType_Vec2 = 4,
  TEDataType_Vec3 = 5,
  TEDataType_Vec4 = 6,
  TEDataType_IVec2 = 7,
  TEDataType_IVec3 = 8,
  TEDataType_IVec4 = 9,
  TEDataType_String = 10,
  TEDataType_Bool = 11,
  TEDataType_Color = 12,
  TEDataType_Identifier = 13,
  TEDataType_AsciiString = 14,
  TEDataType_ResourceId = 15,
  TEDataType_EControllerType = 100,
  TEDataType_ECursorType = 101,
  TEDataType_EInputModalityType = 102,
  TEDataType_EFontStyle = 103,
  TEDataType_EAlignment = 104,
  TEDataType_ETextAlignment = 105,
  TEDataType_ETextFormat = 106,
  TEDataType_ETextVariant = 107,
  TEDataType_EDayTime = 108,
  TEDataType_EActiveCategory = 109,
  TEDataType_ETouchEvent = 110,
  TEDataType_EScrollAreaDirection = 111,
  TEDataType_ELayoutOrientation = 112
};
bool TEDataType_IsValid(int value);
constexpr TEDataType TEDataType_MIN = TEDataType_Int;
constexpr TEDataType TEDataType_MAX = TEDataType_ELayoutOrientation;
constexpr int TEDataType_ARRAYSIZE = TEDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEDataType_descriptor();
template<typename T>
inline const std::string& TEDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEDataType_descriptor(), enum_t_value);
}
inline bool TEDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEDataType>(
    TEDataType_descriptor(), name, value);
}
enum TEFontId : int {
  TEFontId_Automatic = 0,
  TEFontId_Latin = 1,
  TEFontId_Japan = 2,
  TEFontId_Korea = 3,
  TEFontId_Taiwan = 4,
  TEFontId_China = 5,
  TEFontId_Japan_ARIB = 6,
  TEFontId_Special = 7
};
bool TEFontId_IsValid(int value);
constexpr TEFontId TEFontId_MIN = TEFontId_Automatic;
constexpr TEFontId TEFontId_MAX = TEFontId_Special;
constexpr int TEFontId_ARRAYSIZE = TEFontId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEFontId_descriptor();
template<typename T>
inline const std::string& TEFontId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEFontId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEFontId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEFontId_descriptor(), enum_t_value);
}
inline bool TEFontId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEFontId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEFontId>(
    TEFontId_descriptor(), name, value);
}
enum TEFontStyle : int {
  TEFontStyle_Regular = 0,
  TEFontStyle_Light = 1
};
bool TEFontStyle_IsValid(int value);
constexpr TEFontStyle TEFontStyle_MIN = TEFontStyle_Regular;
constexpr TEFontStyle TEFontStyle_MAX = TEFontStyle_Light;
constexpr int TEFontStyle_ARRAYSIZE = TEFontStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEFontStyle_descriptor();
template<typename T>
inline const std::string& TEFontStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEFontStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEFontStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEFontStyle_descriptor(), enum_t_value);
}
inline bool TEFontStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEFontStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEFontStyle>(
    TEFontStyle_descriptor(), name, value);
}
enum TETextAlignment : int {
  TETextAlignment_BottomLeft = 0,
  TETextAlignment_MiddleLeft = 1,
  TETextAlignment_TopLeft = 2,
  TETextAlignment_BottomMiddle = 3,
  TETextAlignment_MiddleMiddle = 4,
  TETextAlignment_TopMiddle = 5,
  TETextAlignment_BottomRight = 6,
  TETextAlignment_MiddleRight = 7,
  TETextAlignment_TopRight = 8
};
bool TETextAlignment_IsValid(int value);
constexpr TETextAlignment TETextAlignment_MIN = TETextAlignment_BottomLeft;
constexpr TETextAlignment TETextAlignment_MAX = TETextAlignment_TopRight;
constexpr int TETextAlignment_ARRAYSIZE = TETextAlignment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextAlignment_descriptor();
template<typename T>
inline const std::string& TETextAlignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextAlignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextAlignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextAlignment_descriptor(), enum_t_value);
}
inline bool TETextAlignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextAlignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextAlignment>(
    TETextAlignment_descriptor(), name, value);
}
enum TETextCuttingStyle : int {
  TETextCuttingStyle_BreakNone = 0,
  TETextCuttingStyle_BreakCharacters = 1,
  TETextCuttingStyle_BreakCharactersFront = 2,
  TETextCuttingStyle_BreakWords = 3,
  TETextCuttingStyle_BreakWordsFront = 4
};
bool TETextCuttingStyle_IsValid(int value);
constexpr TETextCuttingStyle TETextCuttingStyle_MIN = TETextCuttingStyle_BreakNone;
constexpr TETextCuttingStyle TETextCuttingStyle_MAX = TETextCuttingStyle_BreakWordsFront;
constexpr int TETextCuttingStyle_ARRAYSIZE = TETextCuttingStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextCuttingStyle_descriptor();
template<typename T>
inline const std::string& TETextCuttingStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextCuttingStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextCuttingStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextCuttingStyle_descriptor(), enum_t_value);
}
inline bool TETextCuttingStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextCuttingStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextCuttingStyle>(
    TETextCuttingStyle_descriptor(), name, value);
}
enum TETextFormat : int {
  TETextFormat_StandardText = 0,
  TETextFormat_RichTextFormat = 1,
  TETextFormat_LinkTextFormat = 2
};
bool TETextFormat_IsValid(int value);
constexpr TETextFormat TETextFormat_MIN = TETextFormat_StandardText;
constexpr TETextFormat TETextFormat_MAX = TETextFormat_LinkTextFormat;
constexpr int TETextFormat_ARRAYSIZE = TETextFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextFormat_descriptor();
template<typename T>
inline const std::string& TETextFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextFormat_descriptor(), enum_t_value);
}
inline bool TETextFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextFormat>(
    TETextFormat_descriptor(), name, value);
}
enum TETextVariant : int {
  TETextVariant_Default = 0,
  TETextVariant_FBM = 1,
  TETextVariant_Long = 2,
  TETextVariant_Short = 3
};
bool TETextVariant_IsValid(int value);
constexpr TETextVariant TETextVariant_MIN = TETextVariant_Default;
constexpr TETextVariant TETextVariant_MAX = TETextVariant_Short;
constexpr int TETextVariant_ARRAYSIZE = TETextVariant_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TETextVariant_descriptor();
template<typename T>
inline const std::string& TETextVariant_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TETextVariant>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TETextVariant_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TETextVariant_descriptor(), enum_t_value);
}
inline bool TETextVariant_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TETextVariant* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TETextVariant>(
    TETextVariant_descriptor(), name, value);
}
enum TEAlignment : int {
  TEAlignment_Left = 0,
  TEAlignment_Bottom = 1,
  TEAlignment_Front = 2,
  TEAlignment_Center = 3,
  TEAlignment_Right = 4,
  TEAlignment_Top = 5,
  TEAlignment_Back = 6
};
bool TEAlignment_IsValid(int value);
constexpr TEAlignment TEAlignment_MIN = TEAlignment_Left;
constexpr TEAlignment TEAlignment_MAX = TEAlignment_Back;
constexpr int TEAlignment_ARRAYSIZE = TEAlignment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAlignment_descriptor();
template<typename T>
inline const std::string& TEAlignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAlignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAlignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAlignment_descriptor(), enum_t_value);
}
inline bool TEAlignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAlignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAlignment>(
    TEAlignment_descriptor(), name, value);
}
enum TEScrollAreaDirection : int {
  TEScrollAreaDirection_Disabled = 0,
  TEScrollAreaDirection_LeftToRight = 1,
  TEScrollAreaDirection_TopToBottom = 2
};
bool TEScrollAreaDirection_IsValid(int value);
constexpr TEScrollAreaDirection TEScrollAreaDirection_MIN = TEScrollAreaDirection_Disabled;
constexpr TEScrollAreaDirection TEScrollAreaDirection_MAX = TEScrollAreaDirection_TopToBottom;
constexpr int TEScrollAreaDirection_ARRAYSIZE = TEScrollAreaDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEScrollAreaDirection_descriptor();
template<typename T>
inline const std::string& TEScrollAreaDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEScrollAreaDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEScrollAreaDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEScrollAreaDirection_descriptor(), enum_t_value);
}
inline bool TEScrollAreaDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEScrollAreaDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEScrollAreaDirection>(
    TEScrollAreaDirection_descriptor(), name, value);
}
enum TEScrollbarPosition : int {
  TEScrollbarPosition_Default = 0,
  TEScrollbarPosition_Left = 1,
  TEScrollbarPosition_Right = 2,
  TEScrollbarPosition_Top = 3,
  TEScrollbarPosition_Bottom = 4,
  TEScrollbarPosition_Disabled = 5
};
bool TEScrollbarPosition_IsValid(int value);
constexpr TEScrollbarPosition TEScrollbarPosition_MIN = TEScrollbarPosition_Default;
constexpr TEScrollbarPosition TEScrollbarPosition_MAX = TEScrollbarPosition_Disabled;
constexpr int TEScrollbarPosition_ARRAYSIZE = TEScrollbarPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEScrollbarPosition_descriptor();
template<typename T>
inline const std::string& TEScrollbarPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEScrollbarPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEScrollbarPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEScrollbarPosition_descriptor(), enum_t_value);
}
inline bool TEScrollbarPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEScrollbarPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEScrollbarPosition>(
    TEScrollbarPosition_descriptor(), name, value);
}
enum TESceneGraphSearchRoot : int {
  TESearchRoot_Widget = 0,
  TESearchRoot_Scene = 1,
  TESearchRoot_Layout = 2
};
bool TESceneGraphSearchRoot_IsValid(int value);
constexpr TESceneGraphSearchRoot TESceneGraphSearchRoot_MIN = TESearchRoot_Widget;
constexpr TESceneGraphSearchRoot TESceneGraphSearchRoot_MAX = TESearchRoot_Layout;
constexpr int TESceneGraphSearchRoot_ARRAYSIZE = TESceneGraphSearchRoot_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TESceneGraphSearchRoot_descriptor();
template<typename T>
inline const std::string& TESceneGraphSearchRoot_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TESceneGraphSearchRoot>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TESceneGraphSearchRoot_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TESceneGraphSearchRoot_descriptor(), enum_t_value);
}
inline bool TESceneGraphSearchRoot_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TESceneGraphSearchRoot* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TESceneGraphSearchRoot>(
    TESceneGraphSearchRoot_descriptor(), name, value);
}
// ===================================================================

class TIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TIdentifier) */ {
 public:
  inline TIdentifier() : TIdentifier(nullptr) {}
  ~TIdentifier() override;
  explicit PROTOBUF_CONSTEXPR TIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TIdentifier(const TIdentifier& from);
  TIdentifier(TIdentifier&& from) noexcept
    : TIdentifier() {
    *this = ::std::move(from);
  }

  inline TIdentifier& operator=(const TIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline TIdentifier& operator=(TIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const TIdentifier* internal_default_instance() {
    return reinterpret_cast<const TIdentifier*>(
               &_TIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TIdentifier& a, TIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(TIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TIdentifier& from) {
    TIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TIdentifier";
  }
  protected:
  explicit TIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueStringFieldNumber = 2,
    kValueFieldNumber = 1,
    kInvalidFieldNumber = 3,
  };
  // optional string valueString = 2;
  bool has_valuestring() const;
  private:
  bool _internal_has_valuestring() const;
  public:
  void clear_valuestring();
  const std::string& valuestring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valuestring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valuestring();
  PROTOBUF_NODISCARD std::string* release_valuestring();
  void set_allocated_valuestring(std::string* valuestring);
  private:
  const std::string& _internal_valuestring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valuestring(const std::string& value);
  std::string* _internal_mutable_valuestring();
  public:

  // optional uint32 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // optional bool invalid = 3;
  bool has_invalid() const;
  private:
  bool _internal_has_invalid() const;
  public:
  void clear_invalid();
  bool invalid() const;
  void set_invalid(bool value);
  private:
  bool _internal_invalid() const;
  void _internal_set_invalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valuestring_;
    uint32_t value_;
    bool invalid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Common_2eproto;
};
// -------------------------------------------------------------------

class TAlignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TAlignment) */ {
 public:
  inline TAlignment() : TAlignment(nullptr) {}
  ~TAlignment() override;
  explicit PROTOBUF_CONSTEXPR TAlignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TAlignment(const TAlignment& from);
  TAlignment(TAlignment&& from) noexcept
    : TAlignment() {
    *this = ::std::move(from);
  }

  inline TAlignment& operator=(const TAlignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TAlignment& operator=(TAlignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TAlignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TAlignment* internal_default_instance() {
    return reinterpret_cast<const TAlignment*>(
               &_TAlignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TAlignment& a, TAlignment& b) {
    a.Swap(&b);
  }
  inline void Swap(TAlignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TAlignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TAlignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TAlignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TAlignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TAlignment& from) {
    TAlignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TAlignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TAlignment";
  }
  protected:
  explicit TAlignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDepthFieldNumber = 3,
  };
  // optional .TEAlignment width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::TEAlignment width() const;
  void set_width(::TEAlignment value);
  private:
  ::TEAlignment _internal_width() const;
  void _internal_set_width(::TEAlignment value);
  public:

  // optional .TEAlignment height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::TEAlignment height() const;
  void set_height(::TEAlignment value);
  private:
  ::TEAlignment _internal_height() const;
  void _internal_set_height(::TEAlignment value);
  public:

  // optional .TEAlignment depth = 3;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  ::TEAlignment depth() const;
  void set_depth(::TEAlignment value);
  private:
  ::TEAlignment _internal_depth() const;
  void _internal_set_depth(::TEAlignment value);
  public:

  // @@protoc_insertion_point(class_scope:TAlignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int width_;
    int height_;
    int depth_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Common_2eproto;
};
// -------------------------------------------------------------------

class TVariant final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVariant) */ {
 public:
  inline TVariant() : TVariant(nullptr) {}
  ~TVariant() override;
  explicit PROTOBUF_CONSTEXPR TVariant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVariant(const TVariant& from);
  TVariant(TVariant&& from) noexcept
    : TVariant() {
    *this = ::std::move(from);
  }

  inline TVariant& operator=(const TVariant& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVariant& operator=(TVariant&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVariant& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVariant* internal_default_instance() {
    return reinterpret_cast<const TVariant*>(
               &_TVariant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TVariant& a, TVariant& b) {
    a.Swap(&b);
  }
  inline void Swap(TVariant* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVariant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVariant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVariant>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVariant& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVariant& from) {
    TVariant::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVariant* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVariant";
  }
  protected:
  explicit TVariant(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsciiStringFieldNumber = 2,
    kHmiStringFieldNumber = 3,
    kUtf8StringFieldNumber = 9,
    kResourceIdFieldNumber = 10,
    kAssetIdFieldNumber = 11,
    kUtf32StringFieldNumber = 14,
    kNumericFieldNumber = 5,
    kIdentifierFieldNumber = 7,
    kAABBFieldNumber = 8,
    kAlignmentFieldNumber = 20,
    kWidgetDescriptionFieldNumber = 67,
    kBoolFieldNumber = 1,
    kColorFieldNumber = 4,
    kIdentifierTypeFieldNumber = 6,
    kStringIdFieldNumber = 12,
    kResourceIdNumericFieldNumber = 13,
    kOrientationFieldNumber = 40,
    kSizePolicyFieldNumber = 41,
    kInputModalityFieldNumber = 42,
    kDayTimeFieldNumber = 43,
    kScreenLocationFieldNumber = 44,
    kActiveCategoryFieldNumber = 45,
    kControllerTypeFieldNumber = 46,
    kCursorTypeFieldNumber = 47,
    kFontIdFieldNumber = 56,
    kTextAlignmentFieldNumber = 57,
    kTextCutFieldNumber = 58,
    kTextFormatFieldNumber = 59,
    kTouchEventFieldNumber = 60,
    kScrollAreaDirectionFieldNumber = 61,
    kFontStyleFieldNumber = 62,
    kScrollbarPositionFieldNumber = 63,
    kScalarAlignmentFieldNumber = 64,
    kLayoutSearchRootFieldNumber = 65,
    kTextVariantFieldNumber = 66,
    kFaceFieldNumber = 48,
    kWindingFieldNumber = 49,
    kCompareFunctionFieldNumber = 50,
    kBlendFactorFieldNumber = 51,
    kBlendOperationFieldNumber = 52,
    kStencilOperationFieldNumber = 53,
    kTextureFilterFieldNumber = 54,
    kTextureWrapModeFieldNumber = 55,
  };
  // optional string AsciiString = 2;
  bool has_asciistring() const;
  private:
  bool _internal_has_asciistring() const;
  public:
  void clear_asciistring();
  const std::string& asciistring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asciistring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asciistring();
  PROTOBUF_NODISCARD std::string* release_asciistring();
  void set_allocated_asciistring(std::string* asciistring);
  private:
  const std::string& _internal_asciistring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asciistring(const std::string& value);
  std::string* _internal_mutable_asciistring();
  public:

  // optional string HmiString = 3;
  bool has_hmistring() const;
  private:
  bool _internal_has_hmistring() const;
  public:
  void clear_hmistring();
  const std::string& hmistring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hmistring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hmistring();
  PROTOBUF_NODISCARD std::string* release_hmistring();
  void set_allocated_hmistring(std::string* hmistring);
  private:
  const std::string& _internal_hmistring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hmistring(const std::string& value);
  std::string* _internal_mutable_hmistring();
  public:

  // optional string Utf8String = 9;
  bool has_utf8string() const;
  private:
  bool _internal_has_utf8string() const;
  public:
  void clear_utf8string();
  const std::string& utf8string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf8string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf8string();
  PROTOBUF_NODISCARD std::string* release_utf8string();
  void set_allocated_utf8string(std::string* utf8string);
  private:
  const std::string& _internal_utf8string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf8string(const std::string& value);
  std::string* _internal_mutable_utf8string();
  public:

  // optional string ResourceId = 10;
  bool has_resourceid() const;
  private:
  bool _internal_has_resourceid() const;
  public:
  void clear_resourceid();
  const std::string& resourceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resourceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resourceid();
  PROTOBUF_NODISCARD std::string* release_resourceid();
  void set_allocated_resourceid(std::string* resourceid);
  private:
  const std::string& _internal_resourceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resourceid(const std::string& value);
  std::string* _internal_mutable_resourceid();
  public:

  // optional string AssetId = 11;
  bool has_assetid() const;
  private:
  bool _internal_has_assetid() const;
  public:
  void clear_assetid();
  const std::string& assetid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetid();
  PROTOBUF_NODISCARD std::string* release_assetid();
  void set_allocated_assetid(std::string* assetid);
  private:
  const std::string& _internal_assetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetid(const std::string& value);
  std::string* _internal_mutable_assetid();
  public:

  // optional string Utf32String = 14;
  bool has_utf32string() const;
  private:
  bool _internal_has_utf32string() const;
  public:
  void clear_utf32string();
  const std::string& utf32string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utf32string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utf32string();
  PROTOBUF_NODISCARD std::string* release_utf32string();
  void set_allocated_utf32string(std::string* utf32string);
  private:
  const std::string& _internal_utf32string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf32string(const std::string& value);
  std::string* _internal_mutable_utf32string();
  public:

  // optional .TNumericValue Numeric = 5;
  bool has_numeric() const;
  private:
  bool _internal_has_numeric() const;
  public:
  void clear_numeric();
  const ::TNumericValue& numeric() const;
  PROTOBUF_NODISCARD ::TNumericValue* release_numeric();
  ::TNumericValue* mutable_numeric();
  void set_allocated_numeric(::TNumericValue* numeric);
  private:
  const ::TNumericValue& _internal_numeric() const;
  ::TNumericValue* _internal_mutable_numeric();
  public:
  void unsafe_arena_set_allocated_numeric(
      ::TNumericValue* numeric);
  ::TNumericValue* unsafe_arena_release_numeric();

  // optional .TIdentifier Identifier = 7;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const ::TIdentifier& identifier() const;
  PROTOBUF_NODISCARD ::TIdentifier* release_identifier();
  ::TIdentifier* mutable_identifier();
  void set_allocated_identifier(::TIdentifier* identifier);
  private:
  const ::TIdentifier& _internal_identifier() const;
  ::TIdentifier* _internal_mutable_identifier();
  public:
  void unsafe_arena_set_allocated_identifier(
      ::TIdentifier* identifier);
  ::TIdentifier* unsafe_arena_release_identifier();

  // optional .TAxisAlignedBoundingBox AABB = 8;
  bool has_aabb() const;
  private:
  bool _internal_has_aabb() const;
  public:
  void clear_aabb();
  const ::TAxisAlignedBoundingBox& aabb() const;
  PROTOBUF_NODISCARD ::TAxisAlignedBoundingBox* release_aabb();
  ::TAxisAlignedBoundingBox* mutable_aabb();
  void set_allocated_aabb(::TAxisAlignedBoundingBox* aabb);
  private:
  const ::TAxisAlignedBoundingBox& _internal_aabb() const;
  ::TAxisAlignedBoundingBox* _internal_mutable_aabb();
  public:
  void unsafe_arena_set_allocated_aabb(
      ::TAxisAlignedBoundingBox* aabb);
  ::TAxisAlignedBoundingBox* unsafe_arena_release_aabb();

  // optional .TAlignment Alignment = 20;
  bool has_alignment() const;
  private:
  bool _internal_has_alignment() const;
  public:
  void clear_alignment();
  const ::TAlignment& alignment() const;
  PROTOBUF_NODISCARD ::TAlignment* release_alignment();
  ::TAlignment* mutable_alignment();
  void set_allocated_alignment(::TAlignment* alignment);
  private:
  const ::TAlignment& _internal_alignment() const;
  ::TAlignment* _internal_mutable_alignment();
  public:
  void unsafe_arena_set_allocated_alignment(
      ::TAlignment* alignment);
  ::TAlignment* unsafe_arena_release_alignment();

  // optional .TEWidgetDescription WidgetDescription = 67;
  bool has_widgetdescription() const;
  private:
  bool _internal_has_widgetdescription() const;
  public:
  void clear_widgetdescription();
  const ::TEWidgetDescription& widgetdescription() const;
  PROTOBUF_NODISCARD ::TEWidgetDescription* release_widgetdescription();
  ::TEWidgetDescription* mutable_widgetdescription();
  void set_allocated_widgetdescription(::TEWidgetDescription* widgetdescription);
  private:
  const ::TEWidgetDescription& _internal_widgetdescription() const;
  ::TEWidgetDescription* _internal_mutable_widgetdescription();
  public:
  void unsafe_arena_set_allocated_widgetdescription(
      ::TEWidgetDescription* widgetdescription);
  ::TEWidgetDescription* unsafe_arena_release_widgetdescription();

  // optional bool Bool = 1;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;
  public:
  void clear_bool_();
  bool bool_() const;
  void set_bool_(bool value);
  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);
  public:

  // optional fixed32 Color = 4;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  uint32_t color() const;
  void set_color(uint32_t value);
  private:
  uint32_t _internal_color() const;
  void _internal_set_color(uint32_t value);
  public:

  // optional .TEIdentifierType IdentifierType = 6;
  bool has_identifiertype() const;
  private:
  bool _internal_has_identifiertype() const;
  public:
  void clear_identifiertype();
  ::TEIdentifierType identifiertype() const;
  void set_identifiertype(::TEIdentifierType value);
  private:
  ::TEIdentifierType _internal_identifiertype() const;
  void _internal_set_identifiertype(::TEIdentifierType value);
  public:

  // optional uint32 StringId = 12;
  bool has_stringid() const;
  private:
  bool _internal_has_stringid() const;
  public:
  void clear_stringid();
  uint32_t stringid() const;
  void set_stringid(uint32_t value);
  private:
  uint32_t _internal_stringid() const;
  void _internal_set_stringid(uint32_t value);
  public:

  // optional uint32 ResourceIdNumeric = 13;
  bool has_resourceidnumeric() const;
  private:
  bool _internal_has_resourceidnumeric() const;
  public:
  void clear_resourceidnumeric();
  uint32_t resourceidnumeric() const;
  void set_resourceidnumeric(uint32_t value);
  private:
  uint32_t _internal_resourceidnumeric() const;
  void _internal_set_resourceidnumeric(uint32_t value);
  public:

  // optional .TELayoutOrientation Orientation = 40;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  ::TELayoutOrientation orientation() const;
  void set_orientation(::TELayoutOrientation value);
  private:
  ::TELayoutOrientation _internal_orientation() const;
  void _internal_set_orientation(::TELayoutOrientation value);
  public:

  // optional .TESizePolicy SizePolicy = 41;
  bool has_sizepolicy() const;
  private:
  bool _internal_has_sizepolicy() const;
  public:
  void clear_sizepolicy();
  ::TESizePolicy sizepolicy() const;
  void set_sizepolicy(::TESizePolicy value);
  private:
  ::TESizePolicy _internal_sizepolicy() const;
  void _internal_set_sizepolicy(::TESizePolicy value);
  public:

  // optional .TEInputModality InputModality = 42;
  bool has_inputmodality() const;
  private:
  bool _internal_has_inputmodality() const;
  public:
  void clear_inputmodality();
  ::TEInputModality inputmodality() const;
  void set_inputmodality(::TEInputModality value);
  private:
  ::TEInputModality _internal_inputmodality() const;
  void _internal_set_inputmodality(::TEInputModality value);
  public:

  // optional .TEDayTime DayTime = 43;
  bool has_daytime() const;
  private:
  bool _internal_has_daytime() const;
  public:
  void clear_daytime();
  ::TEDayTime daytime() const;
  void set_daytime(::TEDayTime value);
  private:
  ::TEDayTime _internal_daytime() const;
  void _internal_set_daytime(::TEDayTime value);
  public:

  // optional .TEScreenLocation ScreenLocation = 44;
  bool has_screenlocation() const;
  private:
  bool _internal_has_screenlocation() const;
  public:
  void clear_screenlocation();
  ::TEScreenLocation screenlocation() const;
  void set_screenlocation(::TEScreenLocation value);
  private:
  ::TEScreenLocation _internal_screenlocation() const;
  void _internal_set_screenlocation(::TEScreenLocation value);
  public:

  // optional .TEActiveCategory ActiveCategory = 45;
  bool has_activecategory() const;
  private:
  bool _internal_has_activecategory() const;
  public:
  void clear_activecategory();
  ::TEActiveCategory activecategory() const;
  void set_activecategory(::TEActiveCategory value);
  private:
  ::TEActiveCategory _internal_activecategory() const;
  void _internal_set_activecategory(::TEActiveCategory value);
  public:

  // optional .TEControllerType ControllerType = 46;
  bool has_controllertype() const;
  private:
  bool _internal_has_controllertype() const;
  public:
  void clear_controllertype();
  ::TEControllerType controllertype() const;
  void set_controllertype(::TEControllerType value);
  private:
  ::TEControllerType _internal_controllertype() const;
  void _internal_set_controllertype(::TEControllerType value);
  public:

  // optional .TECursorType CursorType = 47;
  bool has_cursortype() const;
  private:
  bool _internal_has_cursortype() const;
  public:
  void clear_cursortype();
  ::TECursorType cursortype() const;
  void set_cursortype(::TECursorType value);
  private:
  ::TECursorType _internal_cursortype() const;
  void _internal_set_cursortype(::TECursorType value);
  public:

  // optional .TEFontId FontId = 56;
  bool has_fontid() const;
  private:
  bool _internal_has_fontid() const;
  public:
  void clear_fontid();
  ::TEFontId fontid() const;
  void set_fontid(::TEFontId value);
  private:
  ::TEFontId _internal_fontid() const;
  void _internal_set_fontid(::TEFontId value);
  public:

  // optional .TETextAlignment TextAlignment = 57;
  bool has_textalignment() const;
  private:
  bool _internal_has_textalignment() const;
  public:
  void clear_textalignment();
  ::TETextAlignment textalignment() const;
  void set_textalignment(::TETextAlignment value);
  private:
  ::TETextAlignment _internal_textalignment() const;
  void _internal_set_textalignment(::TETextAlignment value);
  public:

  // optional .TETextCuttingStyle TextCut = 58;
  bool has_textcut() const;
  private:
  bool _internal_has_textcut() const;
  public:
  void clear_textcut();
  ::TETextCuttingStyle textcut() const;
  void set_textcut(::TETextCuttingStyle value);
  private:
  ::TETextCuttingStyle _internal_textcut() const;
  void _internal_set_textcut(::TETextCuttingStyle value);
  public:

  // optional .TETextFormat TextFormat = 59;
  bool has_textformat() const;
  private:
  bool _internal_has_textformat() const;
  public:
  void clear_textformat();
  ::TETextFormat textformat() const;
  void set_textformat(::TETextFormat value);
  private:
  ::TETextFormat _internal_textformat() const;
  void _internal_set_textformat(::TETextFormat value);
  public:

  // optional .TETouchEvent TouchEvent = 60;
  bool has_touchevent() const;
  private:
  bool _internal_has_touchevent() const;
  public:
  void clear_touchevent();
  ::TETouchEvent touchevent() const;
  void set_touchevent(::TETouchEvent value);
  private:
  ::TETouchEvent _internal_touchevent() const;
  void _internal_set_touchevent(::TETouchEvent value);
  public:

  // optional .TEScrollAreaDirection ScrollAreaDirection = 61;
  bool has_scrollareadirection() const;
  private:
  bool _internal_has_scrollareadirection() const;
  public:
  void clear_scrollareadirection();
  ::TEScrollAreaDirection scrollareadirection() const;
  void set_scrollareadirection(::TEScrollAreaDirection value);
  private:
  ::TEScrollAreaDirection _internal_scrollareadirection() const;
  void _internal_set_scrollareadirection(::TEScrollAreaDirection value);
  public:

  // optional .TEFontStyle FontStyle = 62;
  bool has_fontstyle() const;
  private:
  bool _internal_has_fontstyle() const;
  public:
  void clear_fontstyle();
  ::TEFontStyle fontstyle() const;
  void set_fontstyle(::TEFontStyle value);
  private:
  ::TEFontStyle _internal_fontstyle() const;
  void _internal_set_fontstyle(::TEFontStyle value);
  public:

  // optional .TEScrollbarPosition ScrollbarPosition = 63;
  bool has_scrollbarposition() const;
  private:
  bool _internal_has_scrollbarposition() const;
  public:
  void clear_scrollbarposition();
  ::TEScrollbarPosition scrollbarposition() const;
  void set_scrollbarposition(::TEScrollbarPosition value);
  private:
  ::TEScrollbarPosition _internal_scrollbarposition() const;
  void _internal_set_scrollbarposition(::TEScrollbarPosition value);
  public:

  // optional .TEAlignment ScalarAlignment = 64;
  bool has_scalaralignment() const;
  private:
  bool _internal_has_scalaralignment() const;
  public:
  void clear_scalaralignment();
  ::TEAlignment scalaralignment() const;
  void set_scalaralignment(::TEAlignment value);
  private:
  ::TEAlignment _internal_scalaralignment() const;
  void _internal_set_scalaralignment(::TEAlignment value);
  public:

  // optional .TESceneGraphSearchRoot LayoutSearchRoot = 65;
  bool has_layoutsearchroot() const;
  private:
  bool _internal_has_layoutsearchroot() const;
  public:
  void clear_layoutsearchroot();
  ::TESceneGraphSearchRoot layoutsearchroot() const;
  void set_layoutsearchroot(::TESceneGraphSearchRoot value);
  private:
  ::TESceneGraphSearchRoot _internal_layoutsearchroot() const;
  void _internal_set_layoutsearchroot(::TESceneGraphSearchRoot value);
  public:

  // optional .TETextVariant TextVariant = 66;
  bool has_textvariant() const;
  private:
  bool _internal_has_textvariant() const;
  public:
  void clear_textvariant();
  ::TETextVariant textvariant() const;
  void set_textvariant(::TETextVariant value);
  private:
  ::TETextVariant _internal_textvariant() const;
  void _internal_set_textvariant(::TETextVariant value);
  public:

  // optional .TEFace Face = 48;
  bool has_face() const;
  private:
  bool _internal_has_face() const;
  public:
  void clear_face();
  ::TEFace face() const;
  void set_face(::TEFace value);
  private:
  ::TEFace _internal_face() const;
  void _internal_set_face(::TEFace value);
  public:

  // optional .TEWinding Winding = 49;
  bool has_winding() const;
  private:
  bool _internal_has_winding() const;
  public:
  void clear_winding();
  ::TEWinding winding() const;
  void set_winding(::TEWinding value);
  private:
  ::TEWinding _internal_winding() const;
  void _internal_set_winding(::TEWinding value);
  public:

  // optional .TECompareFunction CompareFunction = 50;
  bool has_comparefunction() const;
  private:
  bool _internal_has_comparefunction() const;
  public:
  void clear_comparefunction();
  ::TECompareFunction comparefunction() const;
  void set_comparefunction(::TECompareFunction value);
  private:
  ::TECompareFunction _internal_comparefunction() const;
  void _internal_set_comparefunction(::TECompareFunction value);
  public:

  // optional .TEBlendFactor BlendFactor = 51;
  bool has_blendfactor() const;
  private:
  bool _internal_has_blendfactor() const;
  public:
  void clear_blendfactor();
  ::TEBlendFactor blendfactor() const;
  void set_blendfactor(::TEBlendFactor value);
  private:
  ::TEBlendFactor _internal_blendfactor() const;
  void _internal_set_blendfactor(::TEBlendFactor value);
  public:

  // optional .TEBlendOperation BlendOperation = 52;
  bool has_blendoperation() const;
  private:
  bool _internal_has_blendoperation() const;
  public:
  void clear_blendoperation();
  ::TEBlendOperation blendoperation() const;
  void set_blendoperation(::TEBlendOperation value);
  private:
  ::TEBlendOperation _internal_blendoperation() const;
  void _internal_set_blendoperation(::TEBlendOperation value);
  public:

  // optional .TEStencilOperation StencilOperation = 53;
  bool has_stenciloperation() const;
  private:
  bool _internal_has_stenciloperation() const;
  public:
  void clear_stenciloperation();
  ::TEStencilOperation stenciloperation() const;
  void set_stenciloperation(::TEStencilOperation value);
  private:
  ::TEStencilOperation _internal_stenciloperation() const;
  void _internal_set_stenciloperation(::TEStencilOperation value);
  public:

  // optional .TETextureFilter TextureFilter = 54;
  bool has_texturefilter() const;
  private:
  bool _internal_has_texturefilter() const;
  public:
  void clear_texturefilter();
  ::TETextureFilter texturefilter() const;
  void set_texturefilter(::TETextureFilter value);
  private:
  ::TETextureFilter _internal_texturefilter() const;
  void _internal_set_texturefilter(::TETextureFilter value);
  public:

  // optional .TETextureWrapMode TextureWrapMode = 55;
  bool has_texturewrapmode() const;
  private:
  bool _internal_has_texturewrapmode() const;
  public:
  void clear_texturewrapmode();
  ::TETextureWrapMode texturewrapmode() const;
  void set_texturewrapmode(::TETextureWrapMode value);
  private:
  ::TETextureWrapMode _internal_texturewrapmode() const;
  void _internal_set_texturewrapmode(::TETextureWrapMode value);
  public:

  // @@protoc_insertion_point(class_scope:TVariant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asciistring_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hmistring_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf8string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resourceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf32string_;
    ::TNumericValue* numeric_;
    ::TIdentifier* identifier_;
    ::TAxisAlignedBoundingBox* aabb_;
    ::TAlignment* alignment_;
    ::TEWidgetDescription* widgetdescription_;
    bool bool__;
    uint32_t color_;
    int identifiertype_;
    uint32_t stringid_;
    uint32_t resourceidnumeric_;
    int orientation_;
    int sizepolicy_;
    int inputmodality_;
    int daytime_;
    int screenlocation_;
    int activecategory_;
    int controllertype_;
    int cursortype_;
    int fontid_;
    int textalignment_;
    int textcut_;
    int textformat_;
    int touchevent_;
    int scrollareadirection_;
    int fontstyle_;
    int scrollbarposition_;
    int scalaralignment_;
    int layoutsearchroot_;
    int textvariant_;
    int face_;
    int winding_;
    int comparefunction_;
    int blendfactor_;
    int blendoperation_;
    int stenciloperation_;
    int texturefilter_;
    int texturewrapmode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Common_2eproto;
};
// -------------------------------------------------------------------

class TEWidgetDescription final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:TEWidgetDescription) */ {
 public:
  inline TEWidgetDescription() : TEWidgetDescription(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TEWidgetDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TEWidgetDescription(const TEWidgetDescription& from);
  TEWidgetDescription(TEWidgetDescription&& from) noexcept
    : TEWidgetDescription() {
    *this = ::std::move(from);
  }

  inline TEWidgetDescription& operator=(const TEWidgetDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline TEWidgetDescription& operator=(TEWidgetDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TEWidgetDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const TEWidgetDescription* internal_default_instance() {
    return reinterpret_cast<const TEWidgetDescription*>(
               &_TEWidgetDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TEWidgetDescription& a, TEWidgetDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(TEWidgetDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TEWidgetDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TEWidgetDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TEWidgetDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TEWidgetDescription& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TEWidgetDescription& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TEWidgetDescription";
  }
  protected:
  explicit TEWidgetDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TEWidgetDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TIdentifier

// optional uint32 value = 1;
inline bool TIdentifier::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TIdentifier::has_value() const {
  return _internal_has_value();
}
inline void TIdentifier::clear_value() {
  _impl_.value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TIdentifier::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t TIdentifier::value() const {
  // @@protoc_insertion_point(field_get:TIdentifier.value)
  return _internal_value();
}
inline void TIdentifier::_internal_set_value(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void TIdentifier::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:TIdentifier.value)
}

// optional string valueString = 2;
inline bool TIdentifier::_internal_has_valuestring() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TIdentifier::has_valuestring() const {
  return _internal_has_valuestring();
}
inline void TIdentifier::clear_valuestring() {
  _impl_.valuestring_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TIdentifier::valuestring() const {
  // @@protoc_insertion_point(field_get:TIdentifier.valueString)
  return _internal_valuestring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TIdentifier::set_valuestring(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.valuestring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TIdentifier.valueString)
}
inline std::string* TIdentifier::mutable_valuestring() {
  std::string* _s = _internal_mutable_valuestring();
  // @@protoc_insertion_point(field_mutable:TIdentifier.valueString)
  return _s;
}
inline const std::string& TIdentifier::_internal_valuestring() const {
  return _impl_.valuestring_.Get();
}
inline void TIdentifier::_internal_set_valuestring(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valuestring_.Set(value, GetArenaForAllocation());
}
inline std::string* TIdentifier::_internal_mutable_valuestring() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.valuestring_.Mutable(GetArenaForAllocation());
}
inline std::string* TIdentifier::release_valuestring() {
  // @@protoc_insertion_point(field_release:TIdentifier.valueString)
  if (!_internal_has_valuestring()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.valuestring_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valuestring_.IsDefault()) {
    _impl_.valuestring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TIdentifier::set_allocated_valuestring(std::string* valuestring) {
  if (valuestring != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.valuestring_.SetAllocated(valuestring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valuestring_.IsDefault()) {
    _impl_.valuestring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TIdentifier.valueString)
}

// optional bool invalid = 3;
inline bool TIdentifier::_internal_has_invalid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TIdentifier::has_invalid() const {
  return _internal_has_invalid();
}
inline void TIdentifier::clear_invalid() {
  _impl_.invalid_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TIdentifier::_internal_invalid() const {
  return _impl_.invalid_;
}
inline bool TIdentifier::invalid() const {
  // @@protoc_insertion_point(field_get:TIdentifier.invalid)
  return _internal_invalid();
}
inline void TIdentifier::_internal_set_invalid(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.invalid_ = value;
}
inline void TIdentifier::set_invalid(bool value) {
  _internal_set_invalid(value);
  // @@protoc_insertion_point(field_set:TIdentifier.invalid)
}

// -------------------------------------------------------------------

// TAlignment

// optional .TEAlignment width = 1;
inline bool TAlignment::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TAlignment::has_width() const {
  return _internal_has_width();
}
inline void TAlignment::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TEAlignment TAlignment::_internal_width() const {
  return static_cast< ::TEAlignment >(_impl_.width_);
}
inline ::TEAlignment TAlignment::width() const {
  // @@protoc_insertion_point(field_get:TAlignment.width)
  return _internal_width();
}
inline void TAlignment::_internal_set_width(::TEAlignment value) {
  assert(::TEAlignment_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void TAlignment::set_width(::TEAlignment value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TAlignment.width)
}

// optional .TEAlignment height = 2;
inline bool TAlignment::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TAlignment::has_height() const {
  return _internal_has_height();
}
inline void TAlignment::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TEAlignment TAlignment::_internal_height() const {
  return static_cast< ::TEAlignment >(_impl_.height_);
}
inline ::TEAlignment TAlignment::height() const {
  // @@protoc_insertion_point(field_get:TAlignment.height)
  return _internal_height();
}
inline void TAlignment::_internal_set_height(::TEAlignment value) {
  assert(::TEAlignment_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void TAlignment::set_height(::TEAlignment value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TAlignment.height)
}

// optional .TEAlignment depth = 3;
inline bool TAlignment::_internal_has_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TAlignment::has_depth() const {
  return _internal_has_depth();
}
inline void TAlignment::clear_depth() {
  _impl_.depth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TEAlignment TAlignment::_internal_depth() const {
  return static_cast< ::TEAlignment >(_impl_.depth_);
}
inline ::TEAlignment TAlignment::depth() const {
  // @@protoc_insertion_point(field_get:TAlignment.depth)
  return _internal_depth();
}
inline void TAlignment::_internal_set_depth(::TEAlignment value) {
  assert(::TEAlignment_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.depth_ = value;
}
inline void TAlignment::set_depth(::TEAlignment value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:TAlignment.depth)
}

// -------------------------------------------------------------------

// TVariant

// optional bool Bool = 1;
inline bool TVariant::_internal_has_bool_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TVariant::has_bool_() const {
  return _internal_has_bool_();
}
inline void TVariant::clear_bool_() {
  _impl_.bool__ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool TVariant::_internal_bool_() const {
  return _impl_.bool__;
}
inline bool TVariant::bool_() const {
  // @@protoc_insertion_point(field_get:TVariant.Bool)
  return _internal_bool_();
}
inline void TVariant::_internal_set_bool_(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.bool__ = value;
}
inline void TVariant::set_bool_(bool value) {
  _internal_set_bool_(value);
  // @@protoc_insertion_point(field_set:TVariant.Bool)
}

// optional string AsciiString = 2;
inline bool TVariant::_internal_has_asciistring() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVariant::has_asciistring() const {
  return _internal_has_asciistring();
}
inline void TVariant::clear_asciistring() {
  _impl_.asciistring_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TVariant::asciistring() const {
  // @@protoc_insertion_point(field_get:TVariant.AsciiString)
  return _internal_asciistring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_asciistring(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.asciistring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.AsciiString)
}
inline std::string* TVariant::mutable_asciistring() {
  std::string* _s = _internal_mutable_asciistring();
  // @@protoc_insertion_point(field_mutable:TVariant.AsciiString)
  return _s;
}
inline const std::string& TVariant::_internal_asciistring() const {
  return _impl_.asciistring_.Get();
}
inline void TVariant::_internal_set_asciistring(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.asciistring_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_asciistring() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.asciistring_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_asciistring() {
  // @@protoc_insertion_point(field_release:TVariant.AsciiString)
  if (!_internal_has_asciistring()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.asciistring_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asciistring_.IsDefault()) {
    _impl_.asciistring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_asciistring(std::string* asciistring) {
  if (asciistring != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.asciistring_.SetAllocated(asciistring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asciistring_.IsDefault()) {
    _impl_.asciistring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.AsciiString)
}

// optional string HmiString = 3;
inline bool TVariant::_internal_has_hmistring() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVariant::has_hmistring() const {
  return _internal_has_hmistring();
}
inline void TVariant::clear_hmistring() {
  _impl_.hmistring_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TVariant::hmistring() const {
  // @@protoc_insertion_point(field_get:TVariant.HmiString)
  return _internal_hmistring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_hmistring(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.hmistring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.HmiString)
}
inline std::string* TVariant::mutable_hmistring() {
  std::string* _s = _internal_mutable_hmistring();
  // @@protoc_insertion_point(field_mutable:TVariant.HmiString)
  return _s;
}
inline const std::string& TVariant::_internal_hmistring() const {
  return _impl_.hmistring_.Get();
}
inline void TVariant::_internal_set_hmistring(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hmistring_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_hmistring() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hmistring_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_hmistring() {
  // @@protoc_insertion_point(field_release:TVariant.HmiString)
  if (!_internal_has_hmistring()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.hmistring_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hmistring_.IsDefault()) {
    _impl_.hmistring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_hmistring(std::string* hmistring) {
  if (hmistring != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hmistring_.SetAllocated(hmistring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hmistring_.IsDefault()) {
    _impl_.hmistring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.HmiString)
}

// optional fixed32 Color = 4;
inline bool TVariant::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TVariant::has_color() const {
  return _internal_has_color();
}
inline void TVariant::clear_color() {
  _impl_.color_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t TVariant::_internal_color() const {
  return _impl_.color_;
}
inline uint32_t TVariant::color() const {
  // @@protoc_insertion_point(field_get:TVariant.Color)
  return _internal_color();
}
inline void TVariant::_internal_set_color(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.color_ = value;
}
inline void TVariant::set_color(uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:TVariant.Color)
}

// optional .TNumericValue Numeric = 5;
inline bool TVariant::_internal_has_numeric() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.numeric_ != nullptr);
  return value;
}
inline bool TVariant::has_numeric() const {
  return _internal_has_numeric();
}
inline const ::TNumericValue& TVariant::_internal_numeric() const {
  const ::TNumericValue* p = _impl_.numeric_;
  return p != nullptr ? *p : reinterpret_cast<const ::TNumericValue&>(
      ::_TNumericValue_default_instance_);
}
inline const ::TNumericValue& TVariant::numeric() const {
  // @@protoc_insertion_point(field_get:TVariant.Numeric)
  return _internal_numeric();
}
inline void TVariant::unsafe_arena_set_allocated_numeric(
    ::TNumericValue* numeric) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.numeric_);
  }
  _impl_.numeric_ = numeric;
  if (numeric) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TVariant.Numeric)
}
inline ::TNumericValue* TVariant::release_numeric() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TNumericValue* temp = _impl_.numeric_;
  _impl_.numeric_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TNumericValue* TVariant::unsafe_arena_release_numeric() {
  // @@protoc_insertion_point(field_release:TVariant.Numeric)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TNumericValue* temp = _impl_.numeric_;
  _impl_.numeric_ = nullptr;
  return temp;
}
inline ::TNumericValue* TVariant::_internal_mutable_numeric() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.numeric_ == nullptr) {
    auto* p = CreateMaybeMessage<::TNumericValue>(GetArenaForAllocation());
    _impl_.numeric_ = p;
  }
  return _impl_.numeric_;
}
inline ::TNumericValue* TVariant::mutable_numeric() {
  ::TNumericValue* _msg = _internal_mutable_numeric();
  // @@protoc_insertion_point(field_mutable:TVariant.Numeric)
  return _msg;
}
inline void TVariant::set_allocated_numeric(::TNumericValue* numeric) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.numeric_);
  }
  if (numeric) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(numeric));
    if (message_arena != submessage_arena) {
      numeric = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, numeric, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.numeric_ = numeric;
  // @@protoc_insertion_point(field_set_allocated:TVariant.Numeric)
}

// optional .TEIdentifierType IdentifierType = 6;
inline bool TVariant::_internal_has_identifiertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TVariant::has_identifiertype() const {
  return _internal_has_identifiertype();
}
inline void TVariant::clear_identifiertype() {
  _impl_.identifiertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::TEIdentifierType TVariant::_internal_identifiertype() const {
  return static_cast< ::TEIdentifierType >(_impl_.identifiertype_);
}
inline ::TEIdentifierType TVariant::identifiertype() const {
  // @@protoc_insertion_point(field_get:TVariant.IdentifierType)
  return _internal_identifiertype();
}
inline void TVariant::_internal_set_identifiertype(::TEIdentifierType value) {
  assert(::TEIdentifierType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.identifiertype_ = value;
}
inline void TVariant::set_identifiertype(::TEIdentifierType value) {
  _internal_set_identifiertype(value);
  // @@protoc_insertion_point(field_set:TVariant.IdentifierType)
}

// optional .TIdentifier Identifier = 7;
inline bool TVariant::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identifier_ != nullptr);
  return value;
}
inline bool TVariant::has_identifier() const {
  return _internal_has_identifier();
}
inline void TVariant::clear_identifier() {
  if (_impl_.identifier_ != nullptr) _impl_.identifier_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::TIdentifier& TVariant::_internal_identifier() const {
  const ::TIdentifier* p = _impl_.identifier_;
  return p != nullptr ? *p : reinterpret_cast<const ::TIdentifier&>(
      ::_TIdentifier_default_instance_);
}
inline const ::TIdentifier& TVariant::identifier() const {
  // @@protoc_insertion_point(field_get:TVariant.Identifier)
  return _internal_identifier();
}
inline void TVariant::unsafe_arena_set_allocated_identifier(
    ::TIdentifier* identifier) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.identifier_);
  }
  _impl_.identifier_ = identifier;
  if (identifier) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TVariant.Identifier)
}
inline ::TIdentifier* TVariant::release_identifier() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TIdentifier* temp = _impl_.identifier_;
  _impl_.identifier_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TIdentifier* TVariant::unsafe_arena_release_identifier() {
  // @@protoc_insertion_point(field_release:TVariant.Identifier)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TIdentifier* temp = _impl_.identifier_;
  _impl_.identifier_ = nullptr;
  return temp;
}
inline ::TIdentifier* TVariant::_internal_mutable_identifier() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.identifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::TIdentifier>(GetArenaForAllocation());
    _impl_.identifier_ = p;
  }
  return _impl_.identifier_;
}
inline ::TIdentifier* TVariant::mutable_identifier() {
  ::TIdentifier* _msg = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:TVariant.Identifier)
  return _msg;
}
inline void TVariant::set_allocated_identifier(::TIdentifier* identifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.identifier_;
  }
  if (identifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(identifier);
    if (message_arena != submessage_arena) {
      identifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, identifier, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.identifier_ = identifier;
  // @@protoc_insertion_point(field_set_allocated:TVariant.Identifier)
}

// optional .TAxisAlignedBoundingBox AABB = 8;
inline bool TVariant::_internal_has_aabb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aabb_ != nullptr);
  return value;
}
inline bool TVariant::has_aabb() const {
  return _internal_has_aabb();
}
inline const ::TAxisAlignedBoundingBox& TVariant::_internal_aabb() const {
  const ::TAxisAlignedBoundingBox* p = _impl_.aabb_;
  return p != nullptr ? *p : reinterpret_cast<const ::TAxisAlignedBoundingBox&>(
      ::_TAxisAlignedBoundingBox_default_instance_);
}
inline const ::TAxisAlignedBoundingBox& TVariant::aabb() const {
  // @@protoc_insertion_point(field_get:TVariant.AABB)
  return _internal_aabb();
}
inline void TVariant::unsafe_arena_set_allocated_aabb(
    ::TAxisAlignedBoundingBox* aabb) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aabb_);
  }
  _impl_.aabb_ = aabb;
  if (aabb) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TVariant.AABB)
}
inline ::TAxisAlignedBoundingBox* TVariant::release_aabb() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TAxisAlignedBoundingBox* temp = _impl_.aabb_;
  _impl_.aabb_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TAxisAlignedBoundingBox* TVariant::unsafe_arena_release_aabb() {
  // @@protoc_insertion_point(field_release:TVariant.AABB)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TAxisAlignedBoundingBox* temp = _impl_.aabb_;
  _impl_.aabb_ = nullptr;
  return temp;
}
inline ::TAxisAlignedBoundingBox* TVariant::_internal_mutable_aabb() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.aabb_ == nullptr) {
    auto* p = CreateMaybeMessage<::TAxisAlignedBoundingBox>(GetArenaForAllocation());
    _impl_.aabb_ = p;
  }
  return _impl_.aabb_;
}
inline ::TAxisAlignedBoundingBox* TVariant::mutable_aabb() {
  ::TAxisAlignedBoundingBox* _msg = _internal_mutable_aabb();
  // @@protoc_insertion_point(field_mutable:TVariant.AABB)
  return _msg;
}
inline void TVariant::set_allocated_aabb(::TAxisAlignedBoundingBox* aabb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aabb_);
  }
  if (aabb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aabb));
    if (message_arena != submessage_arena) {
      aabb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aabb, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.aabb_ = aabb;
  // @@protoc_insertion_point(field_set_allocated:TVariant.AABB)
}

// optional string Utf8String = 9;
inline bool TVariant::_internal_has_utf8string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TVariant::has_utf8string() const {
  return _internal_has_utf8string();
}
inline void TVariant::clear_utf8string() {
  _impl_.utf8string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TVariant::utf8string() const {
  // @@protoc_insertion_point(field_get:TVariant.Utf8String)
  return _internal_utf8string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_utf8string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.utf8string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.Utf8String)
}
inline std::string* TVariant::mutable_utf8string() {
  std::string* _s = _internal_mutable_utf8string();
  // @@protoc_insertion_point(field_mutable:TVariant.Utf8String)
  return _s;
}
inline const std::string& TVariant::_internal_utf8string() const {
  return _impl_.utf8string_.Get();
}
inline void TVariant::_internal_set_utf8string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.utf8string_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_utf8string() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.utf8string_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_utf8string() {
  // @@protoc_insertion_point(field_release:TVariant.Utf8String)
  if (!_internal_has_utf8string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.utf8string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utf8string_.IsDefault()) {
    _impl_.utf8string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_utf8string(std::string* utf8string) {
  if (utf8string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.utf8string_.SetAllocated(utf8string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utf8string_.IsDefault()) {
    _impl_.utf8string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.Utf8String)
}

// optional string ResourceId = 10;
inline bool TVariant::_internal_has_resourceid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TVariant::has_resourceid() const {
  return _internal_has_resourceid();
}
inline void TVariant::clear_resourceid() {
  _impl_.resourceid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TVariant::resourceid() const {
  // @@protoc_insertion_point(field_get:TVariant.ResourceId)
  return _internal_resourceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_resourceid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.resourceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.ResourceId)
}
inline std::string* TVariant::mutable_resourceid() {
  std::string* _s = _internal_mutable_resourceid();
  // @@protoc_insertion_point(field_mutable:TVariant.ResourceId)
  return _s;
}
inline const std::string& TVariant::_internal_resourceid() const {
  return _impl_.resourceid_.Get();
}
inline void TVariant::_internal_set_resourceid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.resourceid_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_resourceid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.resourceid_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_resourceid() {
  // @@protoc_insertion_point(field_release:TVariant.ResourceId)
  if (!_internal_has_resourceid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.resourceid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceid_.IsDefault()) {
    _impl_.resourceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_resourceid(std::string* resourceid) {
  if (resourceid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.resourceid_.SetAllocated(resourceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resourceid_.IsDefault()) {
    _impl_.resourceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.ResourceId)
}

// optional string AssetId = 11;
inline bool TVariant::_internal_has_assetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TVariant::has_assetid() const {
  return _internal_has_assetid();
}
inline void TVariant::clear_assetid() {
  _impl_.assetid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TVariant::assetid() const {
  // @@protoc_insertion_point(field_get:TVariant.AssetId)
  return _internal_assetid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_assetid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.assetid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.AssetId)
}
inline std::string* TVariant::mutable_assetid() {
  std::string* _s = _internal_mutable_assetid();
  // @@protoc_insertion_point(field_mutable:TVariant.AssetId)
  return _s;
}
inline const std::string& TVariant::_internal_assetid() const {
  return _impl_.assetid_.Get();
}
inline void TVariant::_internal_set_assetid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.assetid_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_assetid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.assetid_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_assetid() {
  // @@protoc_insertion_point(field_release:TVariant.AssetId)
  if (!_internal_has_assetid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.assetid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assetid_.IsDefault()) {
    _impl_.assetid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_assetid(std::string* assetid) {
  if (assetid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.assetid_.SetAllocated(assetid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assetid_.IsDefault()) {
    _impl_.assetid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.AssetId)
}

// optional uint32 StringId = 12;
inline bool TVariant::_internal_has_stringid() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TVariant::has_stringid() const {
  return _internal_has_stringid();
}
inline void TVariant::clear_stringid() {
  _impl_.stringid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t TVariant::_internal_stringid() const {
  return _impl_.stringid_;
}
inline uint32_t TVariant::stringid() const {
  // @@protoc_insertion_point(field_get:TVariant.StringId)
  return _internal_stringid();
}
inline void TVariant::_internal_set_stringid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.stringid_ = value;
}
inline void TVariant::set_stringid(uint32_t value) {
  _internal_set_stringid(value);
  // @@protoc_insertion_point(field_set:TVariant.StringId)
}

// optional uint32 ResourceIdNumeric = 13;
inline bool TVariant::_internal_has_resourceidnumeric() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TVariant::has_resourceidnumeric() const {
  return _internal_has_resourceidnumeric();
}
inline void TVariant::clear_resourceidnumeric() {
  _impl_.resourceidnumeric_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t TVariant::_internal_resourceidnumeric() const {
  return _impl_.resourceidnumeric_;
}
inline uint32_t TVariant::resourceidnumeric() const {
  // @@protoc_insertion_point(field_get:TVariant.ResourceIdNumeric)
  return _internal_resourceidnumeric();
}
inline void TVariant::_internal_set_resourceidnumeric(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.resourceidnumeric_ = value;
}
inline void TVariant::set_resourceidnumeric(uint32_t value) {
  _internal_set_resourceidnumeric(value);
  // @@protoc_insertion_point(field_set:TVariant.ResourceIdNumeric)
}

// optional string Utf32String = 14;
inline bool TVariant::_internal_has_utf32string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TVariant::has_utf32string() const {
  return _internal_has_utf32string();
}
inline void TVariant::clear_utf32string() {
  _impl_.utf32string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TVariant::utf32string() const {
  // @@protoc_insertion_point(field_get:TVariant.Utf32String)
  return _internal_utf32string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TVariant::set_utf32string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.utf32string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TVariant.Utf32String)
}
inline std::string* TVariant::mutable_utf32string() {
  std::string* _s = _internal_mutable_utf32string();
  // @@protoc_insertion_point(field_mutable:TVariant.Utf32String)
  return _s;
}
inline const std::string& TVariant::_internal_utf32string() const {
  return _impl_.utf32string_.Get();
}
inline void TVariant::_internal_set_utf32string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.utf32string_.Set(value, GetArenaForAllocation());
}
inline std::string* TVariant::_internal_mutable_utf32string() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.utf32string_.Mutable(GetArenaForAllocation());
}
inline std::string* TVariant::release_utf32string() {
  // @@protoc_insertion_point(field_release:TVariant.Utf32String)
  if (!_internal_has_utf32string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.utf32string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utf32string_.IsDefault()) {
    _impl_.utf32string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TVariant::set_allocated_utf32string(std::string* utf32string) {
  if (utf32string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.utf32string_.SetAllocated(utf32string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utf32string_.IsDefault()) {
    _impl_.utf32string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TVariant.Utf32String)
}

// optional .TAlignment Alignment = 20;
inline bool TVariant::_internal_has_alignment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alignment_ != nullptr);
  return value;
}
inline bool TVariant::has_alignment() const {
  return _internal_has_alignment();
}
inline void TVariant::clear_alignment() {
  if (_impl_.alignment_ != nullptr) _impl_.alignment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::TAlignment& TVariant::_internal_alignment() const {
  const ::TAlignment* p = _impl_.alignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TAlignment&>(
      ::_TAlignment_default_instance_);
}
inline const ::TAlignment& TVariant::alignment() const {
  // @@protoc_insertion_point(field_get:TVariant.Alignment)
  return _internal_alignment();
}
inline void TVariant::unsafe_arena_set_allocated_alignment(
    ::TAlignment* alignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.alignment_);
  }
  _impl_.alignment_ = alignment;
  if (alignment) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TVariant.Alignment)
}
inline ::TAlignment* TVariant::release_alignment() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TAlignment* temp = _impl_.alignment_;
  _impl_.alignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TAlignment* TVariant::unsafe_arena_release_alignment() {
  // @@protoc_insertion_point(field_release:TVariant.Alignment)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TAlignment* temp = _impl_.alignment_;
  _impl_.alignment_ = nullptr;
  return temp;
}
inline ::TAlignment* TVariant::_internal_mutable_alignment() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.alignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TAlignment>(GetArenaForAllocation());
    _impl_.alignment_ = p;
  }
  return _impl_.alignment_;
}
inline ::TAlignment* TVariant::mutable_alignment() {
  ::TAlignment* _msg = _internal_mutable_alignment();
  // @@protoc_insertion_point(field_mutable:TVariant.Alignment)
  return _msg;
}
inline void TVariant::set_allocated_alignment(::TAlignment* alignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.alignment_;
  }
  if (alignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(alignment);
    if (message_arena != submessage_arena) {
      alignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alignment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.alignment_ = alignment;
  // @@protoc_insertion_point(field_set_allocated:TVariant.Alignment)
}

// optional .TELayoutOrientation Orientation = 40;
inline bool TVariant::_internal_has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TVariant::has_orientation() const {
  return _internal_has_orientation();
}
inline void TVariant::clear_orientation() {
  _impl_.orientation_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::TELayoutOrientation TVariant::_internal_orientation() const {
  return static_cast< ::TELayoutOrientation >(_impl_.orientation_);
}
inline ::TELayoutOrientation TVariant::orientation() const {
  // @@protoc_insertion_point(field_get:TVariant.Orientation)
  return _internal_orientation();
}
inline void TVariant::_internal_set_orientation(::TELayoutOrientation value) {
  assert(::TELayoutOrientation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.orientation_ = value;
}
inline void TVariant::set_orientation(::TELayoutOrientation value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:TVariant.Orientation)
}

// optional .TESizePolicy SizePolicy = 41;
inline bool TVariant::_internal_has_sizepolicy() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TVariant::has_sizepolicy() const {
  return _internal_has_sizepolicy();
}
inline void TVariant::clear_sizepolicy() {
  _impl_.sizepolicy_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::TESizePolicy TVariant::_internal_sizepolicy() const {
  return static_cast< ::TESizePolicy >(_impl_.sizepolicy_);
}
inline ::TESizePolicy TVariant::sizepolicy() const {
  // @@protoc_insertion_point(field_get:TVariant.SizePolicy)
  return _internal_sizepolicy();
}
inline void TVariant::_internal_set_sizepolicy(::TESizePolicy value) {
  assert(::TESizePolicy_IsValid(value));
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.sizepolicy_ = value;
}
inline void TVariant::set_sizepolicy(::TESizePolicy value) {
  _internal_set_sizepolicy(value);
  // @@protoc_insertion_point(field_set:TVariant.SizePolicy)
}

// optional .TEInputModality InputModality = 42;
inline bool TVariant::_internal_has_inputmodality() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool TVariant::has_inputmodality() const {
  return _internal_has_inputmodality();
}
inline void TVariant::clear_inputmodality() {
  _impl_.inputmodality_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::TEInputModality TVariant::_internal_inputmodality() const {
  return static_cast< ::TEInputModality >(_impl_.inputmodality_);
}
inline ::TEInputModality TVariant::inputmodality() const {
  // @@protoc_insertion_point(field_get:TVariant.InputModality)
  return _internal_inputmodality();
}
inline void TVariant::_internal_set_inputmodality(::TEInputModality value) {
  assert(::TEInputModality_IsValid(value));
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.inputmodality_ = value;
}
inline void TVariant::set_inputmodality(::TEInputModality value) {
  _internal_set_inputmodality(value);
  // @@protoc_insertion_point(field_set:TVariant.InputModality)
}

// optional .TEDayTime DayTime = 43;
inline bool TVariant::_internal_has_daytime() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool TVariant::has_daytime() const {
  return _internal_has_daytime();
}
inline void TVariant::clear_daytime() {
  _impl_.daytime_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::TEDayTime TVariant::_internal_daytime() const {
  return static_cast< ::TEDayTime >(_impl_.daytime_);
}
inline ::TEDayTime TVariant::daytime() const {
  // @@protoc_insertion_point(field_get:TVariant.DayTime)
  return _internal_daytime();
}
inline void TVariant::_internal_set_daytime(::TEDayTime value) {
  assert(::TEDayTime_IsValid(value));
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.daytime_ = value;
}
inline void TVariant::set_daytime(::TEDayTime value) {
  _internal_set_daytime(value);
  // @@protoc_insertion_point(field_set:TVariant.DayTime)
}

// optional .TEScreenLocation ScreenLocation = 44;
inline bool TVariant::_internal_has_screenlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool TVariant::has_screenlocation() const {
  return _internal_has_screenlocation();
}
inline void TVariant::clear_screenlocation() {
  _impl_.screenlocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::TEScreenLocation TVariant::_internal_screenlocation() const {
  return static_cast< ::TEScreenLocation >(_impl_.screenlocation_);
}
inline ::TEScreenLocation TVariant::screenlocation() const {
  // @@protoc_insertion_point(field_get:TVariant.ScreenLocation)
  return _internal_screenlocation();
}
inline void TVariant::_internal_set_screenlocation(::TEScreenLocation value) {
  assert(::TEScreenLocation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.screenlocation_ = value;
}
inline void TVariant::set_screenlocation(::TEScreenLocation value) {
  _internal_set_screenlocation(value);
  // @@protoc_insertion_point(field_set:TVariant.ScreenLocation)
}

// optional .TEActiveCategory ActiveCategory = 45;
inline bool TVariant::_internal_has_activecategory() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool TVariant::has_activecategory() const {
  return _internal_has_activecategory();
}
inline void TVariant::clear_activecategory() {
  _impl_.activecategory_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::TEActiveCategory TVariant::_internal_activecategory() const {
  return static_cast< ::TEActiveCategory >(_impl_.activecategory_);
}
inline ::TEActiveCategory TVariant::activecategory() const {
  // @@protoc_insertion_point(field_get:TVariant.ActiveCategory)
  return _internal_activecategory();
}
inline void TVariant::_internal_set_activecategory(::TEActiveCategory value) {
  assert(::TEActiveCategory_IsValid(value));
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.activecategory_ = value;
}
inline void TVariant::set_activecategory(::TEActiveCategory value) {
  _internal_set_activecategory(value);
  // @@protoc_insertion_point(field_set:TVariant.ActiveCategory)
}

// optional .TEControllerType ControllerType = 46;
inline bool TVariant::_internal_has_controllertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool TVariant::has_controllertype() const {
  return _internal_has_controllertype();
}
inline void TVariant::clear_controllertype() {
  _impl_.controllertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::TEControllerType TVariant::_internal_controllertype() const {
  return static_cast< ::TEControllerType >(_impl_.controllertype_);
}
inline ::TEControllerType TVariant::controllertype() const {
  // @@protoc_insertion_point(field_get:TVariant.ControllerType)
  return _internal_controllertype();
}
inline void TVariant::_internal_set_controllertype(::TEControllerType value) {
  assert(::TEControllerType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.controllertype_ = value;
}
inline void TVariant::set_controllertype(::TEControllerType value) {
  _internal_set_controllertype(value);
  // @@protoc_insertion_point(field_set:TVariant.ControllerType)
}

// optional .TECursorType CursorType = 47;
inline bool TVariant::_internal_has_cursortype() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool TVariant::has_cursortype() const {
  return _internal_has_cursortype();
}
inline void TVariant::clear_cursortype() {
  _impl_.cursortype_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::TECursorType TVariant::_internal_cursortype() const {
  return static_cast< ::TECursorType >(_impl_.cursortype_);
}
inline ::TECursorType TVariant::cursortype() const {
  // @@protoc_insertion_point(field_get:TVariant.CursorType)
  return _internal_cursortype();
}
inline void TVariant::_internal_set_cursortype(::TECursorType value) {
  assert(::TECursorType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.cursortype_ = value;
}
inline void TVariant::set_cursortype(::TECursorType value) {
  _internal_set_cursortype(value);
  // @@protoc_insertion_point(field_set:TVariant.CursorType)
}

// optional .TEFace Face = 48;
inline bool TVariant::_internal_has_face() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool TVariant::has_face() const {
  return _internal_has_face();
}
inline void TVariant::clear_face() {
  _impl_.face_ = 1;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline ::TEFace TVariant::_internal_face() const {
  return static_cast< ::TEFace >(_impl_.face_);
}
inline ::TEFace TVariant::face() const {
  // @@protoc_insertion_point(field_get:TVariant.Face)
  return _internal_face();
}
inline void TVariant::_internal_set_face(::TEFace value) {
  assert(::TEFace_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.face_ = value;
}
inline void TVariant::set_face(::TEFace value) {
  _internal_set_face(value);
  // @@protoc_insertion_point(field_set:TVariant.Face)
}

// optional .TEWinding Winding = 49;
inline bool TVariant::_internal_has_winding() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool TVariant::has_winding() const {
  return _internal_has_winding();
}
inline void TVariant::clear_winding() {
  _impl_.winding_ = 1;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline ::TEWinding TVariant::_internal_winding() const {
  return static_cast< ::TEWinding >(_impl_.winding_);
}
inline ::TEWinding TVariant::winding() const {
  // @@protoc_insertion_point(field_get:TVariant.Winding)
  return _internal_winding();
}
inline void TVariant::_internal_set_winding(::TEWinding value) {
  assert(::TEWinding_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.winding_ = value;
}
inline void TVariant::set_winding(::TEWinding value) {
  _internal_set_winding(value);
  // @@protoc_insertion_point(field_set:TVariant.Winding)
}

// optional .TECompareFunction CompareFunction = 50;
inline bool TVariant::_internal_has_comparefunction() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool TVariant::has_comparefunction() const {
  return _internal_has_comparefunction();
}
inline void TVariant::clear_comparefunction() {
  _impl_.comparefunction_ = 1;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline ::TECompareFunction TVariant::_internal_comparefunction() const {
  return static_cast< ::TECompareFunction >(_impl_.comparefunction_);
}
inline ::TECompareFunction TVariant::comparefunction() const {
  // @@protoc_insertion_point(field_get:TVariant.CompareFunction)
  return _internal_comparefunction();
}
inline void TVariant::_internal_set_comparefunction(::TECompareFunction value) {
  assert(::TECompareFunction_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.comparefunction_ = value;
}
inline void TVariant::set_comparefunction(::TECompareFunction value) {
  _internal_set_comparefunction(value);
  // @@protoc_insertion_point(field_set:TVariant.CompareFunction)
}

// optional .TEBlendFactor BlendFactor = 51;
inline bool TVariant::_internal_has_blendfactor() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool TVariant::has_blendfactor() const {
  return _internal_has_blendfactor();
}
inline void TVariant::clear_blendfactor() {
  _impl_.blendfactor_ = 1;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline ::TEBlendFactor TVariant::_internal_blendfactor() const {
  return static_cast< ::TEBlendFactor >(_impl_.blendfactor_);
}
inline ::TEBlendFactor TVariant::blendfactor() const {
  // @@protoc_insertion_point(field_get:TVariant.BlendFactor)
  return _internal_blendfactor();
}
inline void TVariant::_internal_set_blendfactor(::TEBlendFactor value) {
  assert(::TEBlendFactor_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.blendfactor_ = value;
}
inline void TVariant::set_blendfactor(::TEBlendFactor value) {
  _internal_set_blendfactor(value);
  // @@protoc_insertion_point(field_set:TVariant.BlendFactor)
}

// optional .TEBlendOperation BlendOperation = 52;
inline bool TVariant::_internal_has_blendoperation() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool TVariant::has_blendoperation() const {
  return _internal_has_blendoperation();
}
inline void TVariant::clear_blendoperation() {
  _impl_.blendoperation_ = 1;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline ::TEBlendOperation TVariant::_internal_blendoperation() const {
  return static_cast< ::TEBlendOperation >(_impl_.blendoperation_);
}
inline ::TEBlendOperation TVariant::blendoperation() const {
  // @@protoc_insertion_point(field_get:TVariant.BlendOperation)
  return _internal_blendoperation();
}
inline void TVariant::_internal_set_blendoperation(::TEBlendOperation value) {
  assert(::TEBlendOperation_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.blendoperation_ = value;
}
inline void TVariant::set_blendoperation(::TEBlendOperation value) {
  _internal_set_blendoperation(value);
  // @@protoc_insertion_point(field_set:TVariant.BlendOperation)
}

// optional .TEStencilOperation StencilOperation = 53;
inline bool TVariant::_internal_has_stenciloperation() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool TVariant::has_stenciloperation() const {
  return _internal_has_stenciloperation();
}
inline void TVariant::clear_stenciloperation() {
  _impl_.stenciloperation_ = 1;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline ::TEStencilOperation TVariant::_internal_stenciloperation() const {
  return static_cast< ::TEStencilOperation >(_impl_.stenciloperation_);
}
inline ::TEStencilOperation TVariant::stenciloperation() const {
  // @@protoc_insertion_point(field_get:TVariant.StencilOperation)
  return _internal_stenciloperation();
}
inline void TVariant::_internal_set_stenciloperation(::TEStencilOperation value) {
  assert(::TEStencilOperation_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.stenciloperation_ = value;
}
inline void TVariant::set_stenciloperation(::TEStencilOperation value) {
  _internal_set_stenciloperation(value);
  // @@protoc_insertion_point(field_set:TVariant.StencilOperation)
}

// optional .TETextureFilter TextureFilter = 54;
inline bool TVariant::_internal_has_texturefilter() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool TVariant::has_texturefilter() const {
  return _internal_has_texturefilter();
}
inline void TVariant::clear_texturefilter() {
  _impl_.texturefilter_ = 1;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline ::TETextureFilter TVariant::_internal_texturefilter() const {
  return static_cast< ::TETextureFilter >(_impl_.texturefilter_);
}
inline ::TETextureFilter TVariant::texturefilter() const {
  // @@protoc_insertion_point(field_get:TVariant.TextureFilter)
  return _internal_texturefilter();
}
inline void TVariant::_internal_set_texturefilter(::TETextureFilter value) {
  assert(::TETextureFilter_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.texturefilter_ = value;
}
inline void TVariant::set_texturefilter(::TETextureFilter value) {
  _internal_set_texturefilter(value);
  // @@protoc_insertion_point(field_set:TVariant.TextureFilter)
}

// optional .TETextureWrapMode TextureWrapMode = 55;
inline bool TVariant::_internal_has_texturewrapmode() const {
  bool value = (_impl_._has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool TVariant::has_texturewrapmode() const {
  return _internal_has_texturewrapmode();
}
inline void TVariant::clear_texturewrapmode() {
  _impl_.texturewrapmode_ = 1;
  _impl_._has_bits_[1] &= ~0x00000400u;
}
inline ::TETextureWrapMode TVariant::_internal_texturewrapmode() const {
  return static_cast< ::TETextureWrapMode >(_impl_.texturewrapmode_);
}
inline ::TETextureWrapMode TVariant::texturewrapmode() const {
  // @@protoc_insertion_point(field_get:TVariant.TextureWrapMode)
  return _internal_texturewrapmode();
}
inline void TVariant::_internal_set_texturewrapmode(::TETextureWrapMode value) {
  assert(::TETextureWrapMode_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000400u;
  _impl_.texturewrapmode_ = value;
}
inline void TVariant::set_texturewrapmode(::TETextureWrapMode value) {
  _internal_set_texturewrapmode(value);
  // @@protoc_insertion_point(field_set:TVariant.TextureWrapMode)
}

// optional .TEFontId FontId = 56;
inline bool TVariant::_internal_has_fontid() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool TVariant::has_fontid() const {
  return _internal_has_fontid();
}
inline void TVariant::clear_fontid() {
  _impl_.fontid_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::TEFontId TVariant::_internal_fontid() const {
  return static_cast< ::TEFontId >(_impl_.fontid_);
}
inline ::TEFontId TVariant::fontid() const {
  // @@protoc_insertion_point(field_get:TVariant.FontId)
  return _internal_fontid();
}
inline void TVariant::_internal_set_fontid(::TEFontId value) {
  assert(::TEFontId_IsValid(value));
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.fontid_ = value;
}
inline void TVariant::set_fontid(::TEFontId value) {
  _internal_set_fontid(value);
  // @@protoc_insertion_point(field_set:TVariant.FontId)
}

// optional .TETextAlignment TextAlignment = 57;
inline bool TVariant::_internal_has_textalignment() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool TVariant::has_textalignment() const {
  return _internal_has_textalignment();
}
inline void TVariant::clear_textalignment() {
  _impl_.textalignment_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::TETextAlignment TVariant::_internal_textalignment() const {
  return static_cast< ::TETextAlignment >(_impl_.textalignment_);
}
inline ::TETextAlignment TVariant::textalignment() const {
  // @@protoc_insertion_point(field_get:TVariant.TextAlignment)
  return _internal_textalignment();
}
inline void TVariant::_internal_set_textalignment(::TETextAlignment value) {
  assert(::TETextAlignment_IsValid(value));
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.textalignment_ = value;
}
inline void TVariant::set_textalignment(::TETextAlignment value) {
  _internal_set_textalignment(value);
  // @@protoc_insertion_point(field_set:TVariant.TextAlignment)
}

// optional .TETextCuttingStyle TextCut = 58;
inline bool TVariant::_internal_has_textcut() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool TVariant::has_textcut() const {
  return _internal_has_textcut();
}
inline void TVariant::clear_textcut() {
  _impl_.textcut_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::TETextCuttingStyle TVariant::_internal_textcut() const {
  return static_cast< ::TETextCuttingStyle >(_impl_.textcut_);
}
inline ::TETextCuttingStyle TVariant::textcut() const {
  // @@protoc_insertion_point(field_get:TVariant.TextCut)
  return _internal_textcut();
}
inline void TVariant::_internal_set_textcut(::TETextCuttingStyle value) {
  assert(::TETextCuttingStyle_IsValid(value));
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.textcut_ = value;
}
inline void TVariant::set_textcut(::TETextCuttingStyle value) {
  _internal_set_textcut(value);
  // @@protoc_insertion_point(field_set:TVariant.TextCut)
}

// optional .TETextFormat TextFormat = 59;
inline bool TVariant::_internal_has_textformat() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool TVariant::has_textformat() const {
  return _internal_has_textformat();
}
inline void TVariant::clear_textformat() {
  _impl_.textformat_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::TETextFormat TVariant::_internal_textformat() const {
  return static_cast< ::TETextFormat >(_impl_.textformat_);
}
inline ::TETextFormat TVariant::textformat() const {
  // @@protoc_insertion_point(field_get:TVariant.TextFormat)
  return _internal_textformat();
}
inline void TVariant::_internal_set_textformat(::TETextFormat value) {
  assert(::TETextFormat_IsValid(value));
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.textformat_ = value;
}
inline void TVariant::set_textformat(::TETextFormat value) {
  _internal_set_textformat(value);
  // @@protoc_insertion_point(field_set:TVariant.TextFormat)
}

// optional .TETouchEvent TouchEvent = 60;
inline bool TVariant::_internal_has_touchevent() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool TVariant::has_touchevent() const {
  return _internal_has_touchevent();
}
inline void TVariant::clear_touchevent() {
  _impl_.touchevent_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::TETouchEvent TVariant::_internal_touchevent() const {
  return static_cast< ::TETouchEvent >(_impl_.touchevent_);
}
inline ::TETouchEvent TVariant::touchevent() const {
  // @@protoc_insertion_point(field_get:TVariant.TouchEvent)
  return _internal_touchevent();
}
inline void TVariant::_internal_set_touchevent(::TETouchEvent value) {
  assert(::TETouchEvent_IsValid(value));
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.touchevent_ = value;
}
inline void TVariant::set_touchevent(::TETouchEvent value) {
  _internal_set_touchevent(value);
  // @@protoc_insertion_point(field_set:TVariant.TouchEvent)
}

// optional .TEScrollAreaDirection ScrollAreaDirection = 61;
inline bool TVariant::_internal_has_scrollareadirection() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool TVariant::has_scrollareadirection() const {
  return _internal_has_scrollareadirection();
}
inline void TVariant::clear_scrollareadirection() {
  _impl_.scrollareadirection_ = 0;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline ::TEScrollAreaDirection TVariant::_internal_scrollareadirection() const {
  return static_cast< ::TEScrollAreaDirection >(_impl_.scrollareadirection_);
}
inline ::TEScrollAreaDirection TVariant::scrollareadirection() const {
  // @@protoc_insertion_point(field_get:TVariant.ScrollAreaDirection)
  return _internal_scrollareadirection();
}
inline void TVariant::_internal_set_scrollareadirection(::TEScrollAreaDirection value) {
  assert(::TEScrollAreaDirection_IsValid(value));
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.scrollareadirection_ = value;
}
inline void TVariant::set_scrollareadirection(::TEScrollAreaDirection value) {
  _internal_set_scrollareadirection(value);
  // @@protoc_insertion_point(field_set:TVariant.ScrollAreaDirection)
}

// optional .TEFontStyle FontStyle = 62;
inline bool TVariant::_internal_has_fontstyle() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool TVariant::has_fontstyle() const {
  return _internal_has_fontstyle();
}
inline void TVariant::clear_fontstyle() {
  _impl_.fontstyle_ = 0;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::TEFontStyle TVariant::_internal_fontstyle() const {
  return static_cast< ::TEFontStyle >(_impl_.fontstyle_);
}
inline ::TEFontStyle TVariant::fontstyle() const {
  // @@protoc_insertion_point(field_get:TVariant.FontStyle)
  return _internal_fontstyle();
}
inline void TVariant::_internal_set_fontstyle(::TEFontStyle value) {
  assert(::TEFontStyle_IsValid(value));
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.fontstyle_ = value;
}
inline void TVariant::set_fontstyle(::TEFontStyle value) {
  _internal_set_fontstyle(value);
  // @@protoc_insertion_point(field_set:TVariant.FontStyle)
}

// optional .TEScrollbarPosition ScrollbarPosition = 63;
inline bool TVariant::_internal_has_scrollbarposition() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool TVariant::has_scrollbarposition() const {
  return _internal_has_scrollbarposition();
}
inline void TVariant::clear_scrollbarposition() {
  _impl_.scrollbarposition_ = 0;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::TEScrollbarPosition TVariant::_internal_scrollbarposition() const {
  return static_cast< ::TEScrollbarPosition >(_impl_.scrollbarposition_);
}
inline ::TEScrollbarPosition TVariant::scrollbarposition() const {
  // @@protoc_insertion_point(field_get:TVariant.ScrollbarPosition)
  return _internal_scrollbarposition();
}
inline void TVariant::_internal_set_scrollbarposition(::TEScrollbarPosition value) {
  assert(::TEScrollbarPosition_IsValid(value));
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.scrollbarposition_ = value;
}
inline void TVariant::set_scrollbarposition(::TEScrollbarPosition value) {
  _internal_set_scrollbarposition(value);
  // @@protoc_insertion_point(field_set:TVariant.ScrollbarPosition)
}

// optional .TEAlignment ScalarAlignment = 64;
inline bool TVariant::_internal_has_scalaralignment() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool TVariant::has_scalaralignment() const {
  return _internal_has_scalaralignment();
}
inline void TVariant::clear_scalaralignment() {
  _impl_.scalaralignment_ = 0;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline ::TEAlignment TVariant::_internal_scalaralignment() const {
  return static_cast< ::TEAlignment >(_impl_.scalaralignment_);
}
inline ::TEAlignment TVariant::scalaralignment() const {
  // @@protoc_insertion_point(field_get:TVariant.ScalarAlignment)
  return _internal_scalaralignment();
}
inline void TVariant::_internal_set_scalaralignment(::TEAlignment value) {
  assert(::TEAlignment_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.scalaralignment_ = value;
}
inline void TVariant::set_scalaralignment(::TEAlignment value) {
  _internal_set_scalaralignment(value);
  // @@protoc_insertion_point(field_set:TVariant.ScalarAlignment)
}

// optional .TESceneGraphSearchRoot LayoutSearchRoot = 65;
inline bool TVariant::_internal_has_layoutsearchroot() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool TVariant::has_layoutsearchroot() const {
  return _internal_has_layoutsearchroot();
}
inline void TVariant::clear_layoutsearchroot() {
  _impl_.layoutsearchroot_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline ::TESceneGraphSearchRoot TVariant::_internal_layoutsearchroot() const {
  return static_cast< ::TESceneGraphSearchRoot >(_impl_.layoutsearchroot_);
}
inline ::TESceneGraphSearchRoot TVariant::layoutsearchroot() const {
  // @@protoc_insertion_point(field_get:TVariant.LayoutSearchRoot)
  return _internal_layoutsearchroot();
}
inline void TVariant::_internal_set_layoutsearchroot(::TESceneGraphSearchRoot value) {
  assert(::TESceneGraphSearchRoot_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.layoutsearchroot_ = value;
}
inline void TVariant::set_layoutsearchroot(::TESceneGraphSearchRoot value) {
  _internal_set_layoutsearchroot(value);
  // @@protoc_insertion_point(field_set:TVariant.LayoutSearchRoot)
}

// optional .TETextVariant TextVariant = 66;
inline bool TVariant::_internal_has_textvariant() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool TVariant::has_textvariant() const {
  return _internal_has_textvariant();
}
inline void TVariant::clear_textvariant() {
  _impl_.textvariant_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline ::TETextVariant TVariant::_internal_textvariant() const {
  return static_cast< ::TETextVariant >(_impl_.textvariant_);
}
inline ::TETextVariant TVariant::textvariant() const {
  // @@protoc_insertion_point(field_get:TVariant.TextVariant)
  return _internal_textvariant();
}
inline void TVariant::_internal_set_textvariant(::TETextVariant value) {
  assert(::TETextVariant_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.textvariant_ = value;
}
inline void TVariant::set_textvariant(::TETextVariant value) {
  _internal_set_textvariant(value);
  // @@protoc_insertion_point(field_set:TVariant.TextVariant)
}

// optional .TEWidgetDescription WidgetDescription = 67;
inline bool TVariant::_internal_has_widgetdescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.widgetdescription_ != nullptr);
  return value;
}
inline bool TVariant::has_widgetdescription() const {
  return _internal_has_widgetdescription();
}
inline void TVariant::clear_widgetdescription() {
  if (_impl_.widgetdescription_ != nullptr) _impl_.widgetdescription_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::TEWidgetDescription& TVariant::_internal_widgetdescription() const {
  const ::TEWidgetDescription* p = _impl_.widgetdescription_;
  return p != nullptr ? *p : reinterpret_cast<const ::TEWidgetDescription&>(
      ::_TEWidgetDescription_default_instance_);
}
inline const ::TEWidgetDescription& TVariant::widgetdescription() const {
  // @@protoc_insertion_point(field_get:TVariant.WidgetDescription)
  return _internal_widgetdescription();
}
inline void TVariant::unsafe_arena_set_allocated_widgetdescription(
    ::TEWidgetDescription* widgetdescription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.widgetdescription_);
  }
  _impl_.widgetdescription_ = widgetdescription;
  if (widgetdescription) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TVariant.WidgetDescription)
}
inline ::TEWidgetDescription* TVariant::release_widgetdescription() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TEWidgetDescription* temp = _impl_.widgetdescription_;
  _impl_.widgetdescription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TEWidgetDescription* TVariant::unsafe_arena_release_widgetdescription() {
  // @@protoc_insertion_point(field_release:TVariant.WidgetDescription)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TEWidgetDescription* temp = _impl_.widgetdescription_;
  _impl_.widgetdescription_ = nullptr;
  return temp;
}
inline ::TEWidgetDescription* TVariant::_internal_mutable_widgetdescription() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.widgetdescription_ == nullptr) {
    auto* p = CreateMaybeMessage<::TEWidgetDescription>(GetArenaForAllocation());
    _impl_.widgetdescription_ = p;
  }
  return _impl_.widgetdescription_;
}
inline ::TEWidgetDescription* TVariant::mutable_widgetdescription() {
  ::TEWidgetDescription* _msg = _internal_mutable_widgetdescription();
  // @@protoc_insertion_point(field_mutable:TVariant.WidgetDescription)
  return _msg;
}
inline void TVariant::set_allocated_widgetdescription(::TEWidgetDescription* widgetdescription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.widgetdescription_;
  }
  if (widgetdescription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(widgetdescription);
    if (message_arena != submessage_arena) {
      widgetdescription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, widgetdescription, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.widgetdescription_ = widgetdescription;
  // @@protoc_insertion_point(field_set_allocated:TVariant.WidgetDescription)
}

// -------------------------------------------------------------------

// TEWidgetDescription

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TEIdentifierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEIdentifierType>() {
  return ::TEIdentifierType_descriptor();
}
template <> struct is_proto_enum< ::TEInputModality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEInputModality>() {
  return ::TEInputModality_descriptor();
}
template <> struct is_proto_enum< ::TEDayTime> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEDayTime>() {
  return ::TEDayTime_descriptor();
}
template <> struct is_proto_enum< ::TEScreenLocation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEScreenLocation>() {
  return ::TEScreenLocation_descriptor();
}
template <> struct is_proto_enum< ::TEActiveCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEActiveCategory>() {
  return ::TEActiveCategory_descriptor();
}
template <> struct is_proto_enum< ::TEControllerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEControllerType>() {
  return ::TEControllerType_descriptor();
}
template <> struct is_proto_enum< ::TETouchEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETouchEvent>() {
  return ::TETouchEvent_descriptor();
}
template <> struct is_proto_enum< ::TETouchGesture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETouchGesture>() {
  return ::TETouchGesture_descriptor();
}
template <> struct is_proto_enum< ::TETouchDevice> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETouchDevice>() {
  return ::TETouchDevice_descriptor();
}
template <> struct is_proto_enum< ::TECursorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TECursorType>() {
  return ::TECursorType_descriptor();
}
template <> struct is_proto_enum< ::TEFace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEFace>() {
  return ::TEFace_descriptor();
}
template <> struct is_proto_enum< ::TEWinding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEWinding>() {
  return ::TEWinding_descriptor();
}
template <> struct is_proto_enum< ::TECompareFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TECompareFunction>() {
  return ::TECompareFunction_descriptor();
}
template <> struct is_proto_enum< ::TEBlendFactor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEBlendFactor>() {
  return ::TEBlendFactor_descriptor();
}
template <> struct is_proto_enum< ::TEBlendOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEBlendOperation>() {
  return ::TEBlendOperation_descriptor();
}
template <> struct is_proto_enum< ::TEStencilOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEStencilOperation>() {
  return ::TEStencilOperation_descriptor();
}
template <> struct is_proto_enum< ::TETextureFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextureFilter>() {
  return ::TETextureFilter_descriptor();
}
template <> struct is_proto_enum< ::TEScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEScope>() {
  return ::TEScope_descriptor();
}
template <> struct is_proto_enum< ::TETextureWrapMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextureWrapMode>() {
  return ::TETextureWrapMode_descriptor();
}
template <> struct is_proto_enum< ::TELayoutOrientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TELayoutOrientation>() {
  return ::TELayoutOrientation_descriptor();
}
template <> struct is_proto_enum< ::TEPixelFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEPixelFormat>() {
  return ::TEPixelFormat_descriptor();
}
template <> struct is_proto_enum< ::TESizePolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TESizePolicy>() {
  return ::TESizePolicy_descriptor();
}
template <> struct is_proto_enum< ::TEDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEDataType>() {
  return ::TEDataType_descriptor();
}
template <> struct is_proto_enum< ::TEFontId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEFontId>() {
  return ::TEFontId_descriptor();
}
template <> struct is_proto_enum< ::TEFontStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEFontStyle>() {
  return ::TEFontStyle_descriptor();
}
template <> struct is_proto_enum< ::TETextAlignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextAlignment>() {
  return ::TETextAlignment_descriptor();
}
template <> struct is_proto_enum< ::TETextCuttingStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextCuttingStyle>() {
  return ::TETextCuttingStyle_descriptor();
}
template <> struct is_proto_enum< ::TETextFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextFormat>() {
  return ::TETextFormat_descriptor();
}
template <> struct is_proto_enum< ::TETextVariant> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TETextVariant>() {
  return ::TETextVariant_descriptor();
}
template <> struct is_proto_enum< ::TEAlignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEAlignment>() {
  return ::TEAlignment_descriptor();
}
template <> struct is_proto_enum< ::TEScrollAreaDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEScrollAreaDirection>() {
  return ::TEScrollAreaDirection_descriptor();
}
template <> struct is_proto_enum< ::TEScrollbarPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TEScrollbarPosition>() {
  return ::TEScrollbarPosition_descriptor();
}
template <> struct is_proto_enum< ::TESceneGraphSearchRoot> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TESceneGraphSearchRoot>() {
  return ::TESceneGraphSearchRoot_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Common_2eproto
