// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Numeric.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Numeric_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Numeric_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Numeric_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Numeric_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Numeric_2eproto;
class TAxisAlignedBoundingBox;
struct TAxisAlignedBoundingBoxDefaultTypeInternal;
extern TAxisAlignedBoundingBoxDefaultTypeInternal _TAxisAlignedBoundingBox_default_instance_;
class TCurveDefinition;
struct TCurveDefinitionDefaultTypeInternal;
extern TCurveDefinitionDefaultTypeInternal _TCurveDefinition_default_instance_;
class TCurvePoint;
struct TCurvePointDefaultTypeInternal;
extern TCurvePointDefaultTypeInternal _TCurvePoint_default_instance_;
class TCurvePointInterpolation;
struct TCurvePointInterpolationDefaultTypeInternal;
extern TCurvePointInterpolationDefaultTypeInternal _TCurvePointInterpolation_default_instance_;
class TKeyFrame;
struct TKeyFrameDefaultTypeInternal;
extern TKeyFrameDefaultTypeInternal _TKeyFrame_default_instance_;
class TKeyFrameSequence;
struct TKeyFrameSequenceDefaultTypeInternal;
extern TKeyFrameSequenceDefaultTypeInternal _TKeyFrameSequence_default_instance_;
class TMatrix3x3f;
struct TMatrix3x3fDefaultTypeInternal;
extern TMatrix3x3fDefaultTypeInternal _TMatrix3x3f_default_instance_;
class TMatrix4x4f;
struct TMatrix4x4fDefaultTypeInternal;
extern TMatrix4x4fDefaultTypeInternal _TMatrix4x4f_default_instance_;
class TMultidimensionalPoint;
struct TMultidimensionalPointDefaultTypeInternal;
extern TMultidimensionalPointDefaultTypeInternal _TMultidimensionalPoint_default_instance_;
class TNumericValue;
struct TNumericValueDefaultTypeInternal;
extern TNumericValueDefaultTypeInternal _TNumericValue_default_instance_;
class TVector2f;
struct TVector2fDefaultTypeInternal;
extern TVector2fDefaultTypeInternal _TVector2f_default_instance_;
class TVector2i;
struct TVector2iDefaultTypeInternal;
extern TVector2iDefaultTypeInternal _TVector2i_default_instance_;
class TVector3f;
struct TVector3fDefaultTypeInternal;
extern TVector3fDefaultTypeInternal _TVector3f_default_instance_;
class TVector3i;
struct TVector3iDefaultTypeInternal;
extern TVector3iDefaultTypeInternal _TVector3i_default_instance_;
class TVector4f;
struct TVector4fDefaultTypeInternal;
extern TVector4fDefaultTypeInternal _TVector4f_default_instance_;
class TVector4i;
struct TVector4iDefaultTypeInternal;
extern TVector4iDefaultTypeInternal _TVector4i_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::TAxisAlignedBoundingBox* Arena::CreateMaybeMessage<::TAxisAlignedBoundingBox>(Arena*);
template<> ::TCurveDefinition* Arena::CreateMaybeMessage<::TCurveDefinition>(Arena*);
template<> ::TCurvePoint* Arena::CreateMaybeMessage<::TCurvePoint>(Arena*);
template<> ::TCurvePointInterpolation* Arena::CreateMaybeMessage<::TCurvePointInterpolation>(Arena*);
template<> ::TKeyFrame* Arena::CreateMaybeMessage<::TKeyFrame>(Arena*);
template<> ::TKeyFrameSequence* Arena::CreateMaybeMessage<::TKeyFrameSequence>(Arena*);
template<> ::TMatrix3x3f* Arena::CreateMaybeMessage<::TMatrix3x3f>(Arena*);
template<> ::TMatrix4x4f* Arena::CreateMaybeMessage<::TMatrix4x4f>(Arena*);
template<> ::TMultidimensionalPoint* Arena::CreateMaybeMessage<::TMultidimensionalPoint>(Arena*);
template<> ::TNumericValue* Arena::CreateMaybeMessage<::TNumericValue>(Arena*);
template<> ::TVector2f* Arena::CreateMaybeMessage<::TVector2f>(Arena*);
template<> ::TVector2i* Arena::CreateMaybeMessage<::TVector2i>(Arena*);
template<> ::TVector3f* Arena::CreateMaybeMessage<::TVector3f>(Arena*);
template<> ::TVector3i* Arena::CreateMaybeMessage<::TVector3i>(Arena*);
template<> ::TVector4f* Arena::CreateMaybeMessage<::TVector4f>(Arena*);
template<> ::TVector4i* Arena::CreateMaybeMessage<::TVector4i>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TENumericType : int {
  TENumericType_integer = 1,
  TENumericType_unsignedInteger = 2,
  TENumericType_float = 3,
  TENumericType_floatVector2 = 4,
  TENumericType_floatVector3 = 5,
  TENumericType_floatVector4 = 6,
  TENumericType_intVector2 = 7,
  TENumericType_intVector3 = 8,
  TENumericType_intVector4 = 9,
  TENumericType_floatMatrix3 = 10,
  TENumericType_floatMatrix4 = 11
};
bool TENumericType_IsValid(int value);
constexpr TENumericType TENumericType_MIN = TENumericType_integer;
constexpr TENumericType TENumericType_MAX = TENumericType_floatMatrix4;
constexpr int TENumericType_ARRAYSIZE = TENumericType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TENumericType_descriptor();
template<typename T>
inline const std::string& TENumericType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TENumericType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TENumericType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TENumericType_descriptor(), enum_t_value);
}
inline bool TENumericType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TENumericType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TENumericType>(
    TENumericType_descriptor(), name, value);
}
enum TCurvePointInterpolationType : int {
  TCurvePointInterpolationType_Step = 0,
  TCurvePointInterpolationType_Linear = 1,
  TCurvePointInterpolationType_Hermite = 2
};
bool TCurvePointInterpolationType_IsValid(int value);
constexpr TCurvePointInterpolationType TCurvePointInterpolationType_MIN = TCurvePointInterpolationType_Step;
constexpr TCurvePointInterpolationType TCurvePointInterpolationType_MAX = TCurvePointInterpolationType_Hermite;
constexpr int TCurvePointInterpolationType_ARRAYSIZE = TCurvePointInterpolationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TCurvePointInterpolationType_descriptor();
template<typename T>
inline const std::string& TCurvePointInterpolationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TCurvePointInterpolationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TCurvePointInterpolationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TCurvePointInterpolationType_descriptor(), enum_t_value);
}
inline bool TCurvePointInterpolationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TCurvePointInterpolationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TCurvePointInterpolationType>(
    TCurvePointInterpolationType_descriptor(), name, value);
}
// ===================================================================

class TVector2i final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector2i) */ {
 public:
  inline TVector2i() : TVector2i(nullptr) {}
  ~TVector2i() override;
  explicit PROTOBUF_CONSTEXPR TVector2i(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector2i(const TVector2i& from);
  TVector2i(TVector2i&& from) noexcept
    : TVector2i() {
    *this = ::std::move(from);
  }

  inline TVector2i& operator=(const TVector2i& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector2i& operator=(TVector2i&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector2i& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector2i* internal_default_instance() {
    return reinterpret_cast<const TVector2i*>(
               &_TVector2i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TVector2i& a, TVector2i& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector2i* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector2i* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector2i* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector2i>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector2i& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector2i& from) {
    TVector2i::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector2i* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector2i";
  }
  protected:
  explicit TVector2i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TVector2i)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TVector3i final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector3i) */ {
 public:
  inline TVector3i() : TVector3i(nullptr) {}
  ~TVector3i() override;
  explicit PROTOBUF_CONSTEXPR TVector3i(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector3i(const TVector3i& from);
  TVector3i(TVector3i&& from) noexcept
    : TVector3i() {
    *this = ::std::move(from);
  }

  inline TVector3i& operator=(const TVector3i& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector3i& operator=(TVector3i&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector3i& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector3i* internal_default_instance() {
    return reinterpret_cast<const TVector3i*>(
               &_TVector3i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TVector3i& a, TVector3i& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector3i* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector3i* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector3i* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector3i>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector3i& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector3i& from) {
    TVector3i::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector3i* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector3i";
  }
  protected:
  explicit TVector3i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // required int32 z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TVector3i)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
    int32_t z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TVector4i final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector4i) */ {
 public:
  inline TVector4i() : TVector4i(nullptr) {}
  ~TVector4i() override;
  explicit PROTOBUF_CONSTEXPR TVector4i(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector4i(const TVector4i& from);
  TVector4i(TVector4i&& from) noexcept
    : TVector4i() {
    *this = ::std::move(from);
  }

  inline TVector4i& operator=(const TVector4i& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector4i& operator=(TVector4i&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector4i& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector4i* internal_default_instance() {
    return reinterpret_cast<const TVector4i*>(
               &_TVector4i_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TVector4i& a, TVector4i& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector4i* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector4i* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector4i* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector4i>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector4i& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector4i& from) {
    TVector4i::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector4i* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector4i";
  }
  protected:
  explicit TVector4i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // required int32 z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // required int32 w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  int32_t w() const;
  void set_w(int32_t value);
  private:
  int32_t _internal_w() const;
  void _internal_set_w(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TVector4i)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
    int32_t z_;
    int32_t w_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TVector2f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector2f) */ {
 public:
  inline TVector2f() : TVector2f(nullptr) {}
  ~TVector2f() override;
  explicit PROTOBUF_CONSTEXPR TVector2f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector2f(const TVector2f& from);
  TVector2f(TVector2f&& from) noexcept
    : TVector2f() {
    *this = ::std::move(from);
  }

  inline TVector2f& operator=(const TVector2f& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector2f& operator=(TVector2f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector2f& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector2f* internal_default_instance() {
    return reinterpret_cast<const TVector2f*>(
               &_TVector2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TVector2f& a, TVector2f& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector2f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector2f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector2f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector2f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector2f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector2f& from) {
    TVector2f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector2f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector2f";
  }
  protected:
  explicit TVector2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:TVector2f)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TVector3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector3f) */ {
 public:
  inline TVector3f() : TVector3f(nullptr) {}
  ~TVector3f() override;
  explicit PROTOBUF_CONSTEXPR TVector3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector3f(const TVector3f& from);
  TVector3f(TVector3f&& from) noexcept
    : TVector3f() {
    *this = ::std::move(from);
  }

  inline TVector3f& operator=(const TVector3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector3f& operator=(TVector3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector3f* internal_default_instance() {
    return reinterpret_cast<const TVector3f*>(
               &_TVector3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TVector3f& a, TVector3f& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector3f& from) {
    TVector3f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector3f";
  }
  protected:
  explicit TVector3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:TVector3f)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TVector4f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TVector4f) */ {
 public:
  inline TVector4f() : TVector4f(nullptr) {}
  ~TVector4f() override;
  explicit PROTOBUF_CONSTEXPR TVector4f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TVector4f(const TVector4f& from);
  TVector4f(TVector4f&& from) noexcept
    : TVector4f() {
    *this = ::std::move(from);
  }

  inline TVector4f& operator=(const TVector4f& from) {
    CopyFrom(from);
    return *this;
  }
  inline TVector4f& operator=(TVector4f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TVector4f& default_instance() {
    return *internal_default_instance();
  }
  static inline const TVector4f* internal_default_instance() {
    return reinterpret_cast<const TVector4f*>(
               &_TVector4f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TVector4f& a, TVector4f& b) {
    a.Swap(&b);
  }
  inline void Swap(TVector4f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TVector4f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TVector4f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TVector4f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TVector4f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TVector4f& from) {
    TVector4f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TVector4f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TVector4f";
  }
  protected:
  explicit TVector4f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // required float w = 4;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:TVector4f)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    float w_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TMatrix3x3f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TMatrix3x3f) */ {
 public:
  inline TMatrix3x3f() : TMatrix3x3f(nullptr) {}
  ~TMatrix3x3f() override;
  explicit PROTOBUF_CONSTEXPR TMatrix3x3f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMatrix3x3f(const TMatrix3x3f& from);
  TMatrix3x3f(TMatrix3x3f&& from) noexcept
    : TMatrix3x3f() {
    *this = ::std::move(from);
  }

  inline TMatrix3x3f& operator=(const TMatrix3x3f& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMatrix3x3f& operator=(TMatrix3x3f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMatrix3x3f& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMatrix3x3f* internal_default_instance() {
    return reinterpret_cast<const TMatrix3x3f*>(
               &_TMatrix3x3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TMatrix3x3f& a, TMatrix3x3f& b) {
    a.Swap(&b);
  }
  inline void Swap(TMatrix3x3f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMatrix3x3f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMatrix3x3f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMatrix3x3f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMatrix3x3f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMatrix3x3f& from) {
    TMatrix3x3f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMatrix3x3f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TMatrix3x3f";
  }
  protected:
  explicit TMatrix3x3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kM11FieldNumber = 1,
    kM12FieldNumber = 2,
    kM13FieldNumber = 3,
    kM21FieldNumber = 4,
    kM22FieldNumber = 5,
    kM23FieldNumber = 6,
    kM31FieldNumber = 7,
    kM32FieldNumber = 8,
    kM33FieldNumber = 9,
  };
  // optional float m11 = 1;
  bool has_m11() const;
  private:
  bool _internal_has_m11() const;
  public:
  void clear_m11();
  float m11() const;
  void set_m11(float value);
  private:
  float _internal_m11() const;
  void _internal_set_m11(float value);
  public:

  // optional float m12 = 2;
  bool has_m12() const;
  private:
  bool _internal_has_m12() const;
  public:
  void clear_m12();
  float m12() const;
  void set_m12(float value);
  private:
  float _internal_m12() const;
  void _internal_set_m12(float value);
  public:

  // optional float m13 = 3;
  bool has_m13() const;
  private:
  bool _internal_has_m13() const;
  public:
  void clear_m13();
  float m13() const;
  void set_m13(float value);
  private:
  float _internal_m13() const;
  void _internal_set_m13(float value);
  public:

  // optional float m21 = 4;
  bool has_m21() const;
  private:
  bool _internal_has_m21() const;
  public:
  void clear_m21();
  float m21() const;
  void set_m21(float value);
  private:
  float _internal_m21() const;
  void _internal_set_m21(float value);
  public:

  // optional float m22 = 5;
  bool has_m22() const;
  private:
  bool _internal_has_m22() const;
  public:
  void clear_m22();
  float m22() const;
  void set_m22(float value);
  private:
  float _internal_m22() const;
  void _internal_set_m22(float value);
  public:

  // optional float m23 = 6;
  bool has_m23() const;
  private:
  bool _internal_has_m23() const;
  public:
  void clear_m23();
  float m23() const;
  void set_m23(float value);
  private:
  float _internal_m23() const;
  void _internal_set_m23(float value);
  public:

  // optional float m31 = 7;
  bool has_m31() const;
  private:
  bool _internal_has_m31() const;
  public:
  void clear_m31();
  float m31() const;
  void set_m31(float value);
  private:
  float _internal_m31() const;
  void _internal_set_m31(float value);
  public:

  // optional float m32 = 8;
  bool has_m32() const;
  private:
  bool _internal_has_m32() const;
  public:
  void clear_m32();
  float m32() const;
  void set_m32(float value);
  private:
  float _internal_m32() const;
  void _internal_set_m32(float value);
  public:

  // optional float m33 = 9;
  bool has_m33() const;
  private:
  bool _internal_has_m33() const;
  public:
  void clear_m33();
  float m33() const;
  void set_m33(float value);
  private:
  float _internal_m33() const;
  void _internal_set_m33(float value);
  public:

  // @@protoc_insertion_point(class_scope:TMatrix3x3f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float m11_;
    float m12_;
    float m13_;
    float m21_;
    float m22_;
    float m23_;
    float m31_;
    float m32_;
    float m33_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TMatrix4x4f final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TMatrix4x4f) */ {
 public:
  inline TMatrix4x4f() : TMatrix4x4f(nullptr) {}
  ~TMatrix4x4f() override;
  explicit PROTOBUF_CONSTEXPR TMatrix4x4f(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMatrix4x4f(const TMatrix4x4f& from);
  TMatrix4x4f(TMatrix4x4f&& from) noexcept
    : TMatrix4x4f() {
    *this = ::std::move(from);
  }

  inline TMatrix4x4f& operator=(const TMatrix4x4f& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMatrix4x4f& operator=(TMatrix4x4f&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMatrix4x4f& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMatrix4x4f* internal_default_instance() {
    return reinterpret_cast<const TMatrix4x4f*>(
               &_TMatrix4x4f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TMatrix4x4f& a, TMatrix4x4f& b) {
    a.Swap(&b);
  }
  inline void Swap(TMatrix4x4f* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMatrix4x4f* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMatrix4x4f* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMatrix4x4f>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMatrix4x4f& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMatrix4x4f& from) {
    TMatrix4x4f::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMatrix4x4f* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TMatrix4x4f";
  }
  protected:
  explicit TMatrix4x4f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kM11FieldNumber = 1,
    kM12FieldNumber = 2,
    kM13FieldNumber = 3,
    kM14FieldNumber = 4,
    kM21FieldNumber = 5,
    kM22FieldNumber = 6,
    kM23FieldNumber = 7,
    kM24FieldNumber = 8,
    kM31FieldNumber = 9,
    kM32FieldNumber = 10,
    kM33FieldNumber = 11,
    kM34FieldNumber = 12,
    kM41FieldNumber = 13,
    kM42FieldNumber = 14,
    kM43FieldNumber = 15,
    kM44FieldNumber = 16,
  };
  // optional float m11 = 1;
  bool has_m11() const;
  private:
  bool _internal_has_m11() const;
  public:
  void clear_m11();
  float m11() const;
  void set_m11(float value);
  private:
  float _internal_m11() const;
  void _internal_set_m11(float value);
  public:

  // optional float m12 = 2;
  bool has_m12() const;
  private:
  bool _internal_has_m12() const;
  public:
  void clear_m12();
  float m12() const;
  void set_m12(float value);
  private:
  float _internal_m12() const;
  void _internal_set_m12(float value);
  public:

  // optional float m13 = 3;
  bool has_m13() const;
  private:
  bool _internal_has_m13() const;
  public:
  void clear_m13();
  float m13() const;
  void set_m13(float value);
  private:
  float _internal_m13() const;
  void _internal_set_m13(float value);
  public:

  // optional float m14 = 4;
  bool has_m14() const;
  private:
  bool _internal_has_m14() const;
  public:
  void clear_m14();
  float m14() const;
  void set_m14(float value);
  private:
  float _internal_m14() const;
  void _internal_set_m14(float value);
  public:

  // optional float m21 = 5;
  bool has_m21() const;
  private:
  bool _internal_has_m21() const;
  public:
  void clear_m21();
  float m21() const;
  void set_m21(float value);
  private:
  float _internal_m21() const;
  void _internal_set_m21(float value);
  public:

  // optional float m22 = 6;
  bool has_m22() const;
  private:
  bool _internal_has_m22() const;
  public:
  void clear_m22();
  float m22() const;
  void set_m22(float value);
  private:
  float _internal_m22() const;
  void _internal_set_m22(float value);
  public:

  // optional float m23 = 7;
  bool has_m23() const;
  private:
  bool _internal_has_m23() const;
  public:
  void clear_m23();
  float m23() const;
  void set_m23(float value);
  private:
  float _internal_m23() const;
  void _internal_set_m23(float value);
  public:

  // optional float m24 = 8;
  bool has_m24() const;
  private:
  bool _internal_has_m24() const;
  public:
  void clear_m24();
  float m24() const;
  void set_m24(float value);
  private:
  float _internal_m24() const;
  void _internal_set_m24(float value);
  public:

  // optional float m31 = 9;
  bool has_m31() const;
  private:
  bool _internal_has_m31() const;
  public:
  void clear_m31();
  float m31() const;
  void set_m31(float value);
  private:
  float _internal_m31() const;
  void _internal_set_m31(float value);
  public:

  // optional float m32 = 10;
  bool has_m32() const;
  private:
  bool _internal_has_m32() const;
  public:
  void clear_m32();
  float m32() const;
  void set_m32(float value);
  private:
  float _internal_m32() const;
  void _internal_set_m32(float value);
  public:

  // optional float m33 = 11;
  bool has_m33() const;
  private:
  bool _internal_has_m33() const;
  public:
  void clear_m33();
  float m33() const;
  void set_m33(float value);
  private:
  float _internal_m33() const;
  void _internal_set_m33(float value);
  public:

  // optional float m34 = 12;
  bool has_m34() const;
  private:
  bool _internal_has_m34() const;
  public:
  void clear_m34();
  float m34() const;
  void set_m34(float value);
  private:
  float _internal_m34() const;
  void _internal_set_m34(float value);
  public:

  // optional float m41 = 13;
  bool has_m41() const;
  private:
  bool _internal_has_m41() const;
  public:
  void clear_m41();
  float m41() const;
  void set_m41(float value);
  private:
  float _internal_m41() const;
  void _internal_set_m41(float value);
  public:

  // optional float m42 = 14;
  bool has_m42() const;
  private:
  bool _internal_has_m42() const;
  public:
  void clear_m42();
  float m42() const;
  void set_m42(float value);
  private:
  float _internal_m42() const;
  void _internal_set_m42(float value);
  public:

  // optional float m43 = 15;
  bool has_m43() const;
  private:
  bool _internal_has_m43() const;
  public:
  void clear_m43();
  float m43() const;
  void set_m43(float value);
  private:
  float _internal_m43() const;
  void _internal_set_m43(float value);
  public:

  // optional float m44 = 16;
  bool has_m44() const;
  private:
  bool _internal_has_m44() const;
  public:
  void clear_m44();
  float m44() const;
  void set_m44(float value);
  private:
  float _internal_m44() const;
  void _internal_set_m44(float value);
  public:

  // @@protoc_insertion_point(class_scope:TMatrix4x4f)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float m11_;
    float m12_;
    float m13_;
    float m14_;
    float m21_;
    float m22_;
    float m23_;
    float m24_;
    float m31_;
    float m32_;
    float m33_;
    float m34_;
    float m41_;
    float m42_;
    float m43_;
    float m44_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TAxisAlignedBoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TAxisAlignedBoundingBox) */ {
 public:
  inline TAxisAlignedBoundingBox() : TAxisAlignedBoundingBox(nullptr) {}
  ~TAxisAlignedBoundingBox() override;
  explicit PROTOBUF_CONSTEXPR TAxisAlignedBoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TAxisAlignedBoundingBox(const TAxisAlignedBoundingBox& from);
  TAxisAlignedBoundingBox(TAxisAlignedBoundingBox&& from) noexcept
    : TAxisAlignedBoundingBox() {
    *this = ::std::move(from);
  }

  inline TAxisAlignedBoundingBox& operator=(const TAxisAlignedBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline TAxisAlignedBoundingBox& operator=(TAxisAlignedBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TAxisAlignedBoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const TAxisAlignedBoundingBox* internal_default_instance() {
    return reinterpret_cast<const TAxisAlignedBoundingBox*>(
               &_TAxisAlignedBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TAxisAlignedBoundingBox& a, TAxisAlignedBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(TAxisAlignedBoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TAxisAlignedBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TAxisAlignedBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TAxisAlignedBoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TAxisAlignedBoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TAxisAlignedBoundingBox& from) {
    TAxisAlignedBoundingBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TAxisAlignedBoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TAxisAlignedBoundingBox";
  }
  protected:
  explicit TAxisAlignedBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // required .TVector3f min = 1;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::TVector3f& min() const;
  PROTOBUF_NODISCARD ::TVector3f* release_min();
  ::TVector3f* mutable_min();
  void set_allocated_min(::TVector3f* min);
  private:
  const ::TVector3f& _internal_min() const;
  ::TVector3f* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::TVector3f* min);
  ::TVector3f* unsafe_arena_release_min();

  // required .TVector3f max = 2;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::TVector3f& max() const;
  PROTOBUF_NODISCARD ::TVector3f* release_max();
  ::TVector3f* mutable_max();
  void set_allocated_max(::TVector3f* max);
  private:
  const ::TVector3f& _internal_max() const;
  ::TVector3f* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::TVector3f* max);
  ::TVector3f* unsafe_arena_release_max();

  // @@protoc_insertion_point(class_scope:TAxisAlignedBoundingBox)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TVector3f* min_;
    ::TVector3f* max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TNumericValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TNumericValue) */ {
 public:
  inline TNumericValue() : TNumericValue(nullptr) {}
  ~TNumericValue() override;
  explicit PROTOBUF_CONSTEXPR TNumericValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TNumericValue(const TNumericValue& from);
  TNumericValue(TNumericValue&& from) noexcept
    : TNumericValue() {
    *this = ::std::move(from);
  }

  inline TNumericValue& operator=(const TNumericValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TNumericValue& operator=(TNumericValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TNumericValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TNumericValue* internal_default_instance() {
    return reinterpret_cast<const TNumericValue*>(
               &_TNumericValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TNumericValue& a, TNumericValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TNumericValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TNumericValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TNumericValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TNumericValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TNumericValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TNumericValue& from) {
    TNumericValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TNumericValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TNumericValue";
  }
  protected:
  explicit TNumericValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVec2FFieldNumber = 4,
    kVec3FFieldNumber = 5,
    kVec4FFieldNumber = 6,
    kVec2IFieldNumber = 7,
    kVec3IFieldNumber = 8,
    kVec4IFieldNumber = 9,
    kFloatMatrix3FieldNumber = 10,
    kFloatMatrix4FieldNumber = 11,
    kIntFieldNumber = 1,
    kUIntFieldNumber = 2,
    kFloatFieldNumber = 3,
  };
  // optional .TVector2f Vec2f = 4;
  bool has_vec2f() const;
  private:
  bool _internal_has_vec2f() const;
  public:
  void clear_vec2f();
  const ::TVector2f& vec2f() const;
  PROTOBUF_NODISCARD ::TVector2f* release_vec2f();
  ::TVector2f* mutable_vec2f();
  void set_allocated_vec2f(::TVector2f* vec2f);
  private:
  const ::TVector2f& _internal_vec2f() const;
  ::TVector2f* _internal_mutable_vec2f();
  public:
  void unsafe_arena_set_allocated_vec2f(
      ::TVector2f* vec2f);
  ::TVector2f* unsafe_arena_release_vec2f();

  // optional .TVector3f Vec3f = 5;
  bool has_vec3f() const;
  private:
  bool _internal_has_vec3f() const;
  public:
  void clear_vec3f();
  const ::TVector3f& vec3f() const;
  PROTOBUF_NODISCARD ::TVector3f* release_vec3f();
  ::TVector3f* mutable_vec3f();
  void set_allocated_vec3f(::TVector3f* vec3f);
  private:
  const ::TVector3f& _internal_vec3f() const;
  ::TVector3f* _internal_mutable_vec3f();
  public:
  void unsafe_arena_set_allocated_vec3f(
      ::TVector3f* vec3f);
  ::TVector3f* unsafe_arena_release_vec3f();

  // optional .TVector4f Vec4f = 6;
  bool has_vec4f() const;
  private:
  bool _internal_has_vec4f() const;
  public:
  void clear_vec4f();
  const ::TVector4f& vec4f() const;
  PROTOBUF_NODISCARD ::TVector4f* release_vec4f();
  ::TVector4f* mutable_vec4f();
  void set_allocated_vec4f(::TVector4f* vec4f);
  private:
  const ::TVector4f& _internal_vec4f() const;
  ::TVector4f* _internal_mutable_vec4f();
  public:
  void unsafe_arena_set_allocated_vec4f(
      ::TVector4f* vec4f);
  ::TVector4f* unsafe_arena_release_vec4f();

  // optional .TVector2i Vec2i = 7;
  bool has_vec2i() const;
  private:
  bool _internal_has_vec2i() const;
  public:
  void clear_vec2i();
  const ::TVector2i& vec2i() const;
  PROTOBUF_NODISCARD ::TVector2i* release_vec2i();
  ::TVector2i* mutable_vec2i();
  void set_allocated_vec2i(::TVector2i* vec2i);
  private:
  const ::TVector2i& _internal_vec2i() const;
  ::TVector2i* _internal_mutable_vec2i();
  public:
  void unsafe_arena_set_allocated_vec2i(
      ::TVector2i* vec2i);
  ::TVector2i* unsafe_arena_release_vec2i();

  // optional .TVector3i Vec3i = 8;
  bool has_vec3i() const;
  private:
  bool _internal_has_vec3i() const;
  public:
  void clear_vec3i();
  const ::TVector3i& vec3i() const;
  PROTOBUF_NODISCARD ::TVector3i* release_vec3i();
  ::TVector3i* mutable_vec3i();
  void set_allocated_vec3i(::TVector3i* vec3i);
  private:
  const ::TVector3i& _internal_vec3i() const;
  ::TVector3i* _internal_mutable_vec3i();
  public:
  void unsafe_arena_set_allocated_vec3i(
      ::TVector3i* vec3i);
  ::TVector3i* unsafe_arena_release_vec3i();

  // optional .TVector4i Vec4i = 9;
  bool has_vec4i() const;
  private:
  bool _internal_has_vec4i() const;
  public:
  void clear_vec4i();
  const ::TVector4i& vec4i() const;
  PROTOBUF_NODISCARD ::TVector4i* release_vec4i();
  ::TVector4i* mutable_vec4i();
  void set_allocated_vec4i(::TVector4i* vec4i);
  private:
  const ::TVector4i& _internal_vec4i() const;
  ::TVector4i* _internal_mutable_vec4i();
  public:
  void unsafe_arena_set_allocated_vec4i(
      ::TVector4i* vec4i);
  ::TVector4i* unsafe_arena_release_vec4i();

  // optional .TMatrix3x3f FloatMatrix3 = 10;
  bool has_floatmatrix3() const;
  private:
  bool _internal_has_floatmatrix3() const;
  public:
  void clear_floatmatrix3();
  const ::TMatrix3x3f& floatmatrix3() const;
  PROTOBUF_NODISCARD ::TMatrix3x3f* release_floatmatrix3();
  ::TMatrix3x3f* mutable_floatmatrix3();
  void set_allocated_floatmatrix3(::TMatrix3x3f* floatmatrix3);
  private:
  const ::TMatrix3x3f& _internal_floatmatrix3() const;
  ::TMatrix3x3f* _internal_mutable_floatmatrix3();
  public:
  void unsafe_arena_set_allocated_floatmatrix3(
      ::TMatrix3x3f* floatmatrix3);
  ::TMatrix3x3f* unsafe_arena_release_floatmatrix3();

  // optional .TMatrix4x4f FloatMatrix4 = 11;
  bool has_floatmatrix4() const;
  private:
  bool _internal_has_floatmatrix4() const;
  public:
  void clear_floatmatrix4();
  const ::TMatrix4x4f& floatmatrix4() const;
  PROTOBUF_NODISCARD ::TMatrix4x4f* release_floatmatrix4();
  ::TMatrix4x4f* mutable_floatmatrix4();
  void set_allocated_floatmatrix4(::TMatrix4x4f* floatmatrix4);
  private:
  const ::TMatrix4x4f& _internal_floatmatrix4() const;
  ::TMatrix4x4f* _internal_mutable_floatmatrix4();
  public:
  void unsafe_arena_set_allocated_floatmatrix4(
      ::TMatrix4x4f* floatmatrix4);
  ::TMatrix4x4f* unsafe_arena_release_floatmatrix4();

  // optional int32 Int = 1;
  bool has_int_() const;
  private:
  bool _internal_has_int_() const;
  public:
  void clear_int_();
  int32_t int_() const;
  void set_int_(int32_t value);
  private:
  int32_t _internal_int_() const;
  void _internal_set_int_(int32_t value);
  public:

  // optional uint32 UInt = 2;
  bool has_uint() const;
  private:
  bool _internal_has_uint() const;
  public:
  void clear_uint();
  uint32_t uint() const;
  void set_uint(uint32_t value);
  private:
  uint32_t _internal_uint() const;
  void _internal_set_uint(uint32_t value);
  public:

  // optional float Float = 3;
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;
  public:
  void clear_float_();
  float float_() const;
  void set_float_(float value);
  private:
  float _internal_float_() const;
  void _internal_set_float_(float value);
  public:

  // @@protoc_insertion_point(class_scope:TNumericValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TVector2f* vec2f_;
    ::TVector3f* vec3f_;
    ::TVector4f* vec4f_;
    ::TVector2i* vec2i_;
    ::TVector3i* vec3i_;
    ::TVector4i* vec4i_;
    ::TMatrix3x3f* floatmatrix3_;
    ::TMatrix4x4f* floatmatrix4_;
    int32_t int__;
    uint32_t uint_;
    float float__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TMultidimensionalPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TMultidimensionalPoint) */ {
 public:
  inline TMultidimensionalPoint() : TMultidimensionalPoint(nullptr) {}
  ~TMultidimensionalPoint() override;
  explicit PROTOBUF_CONSTEXPR TMultidimensionalPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMultidimensionalPoint(const TMultidimensionalPoint& from);
  TMultidimensionalPoint(TMultidimensionalPoint&& from) noexcept
    : TMultidimensionalPoint() {
    *this = ::std::move(from);
  }

  inline TMultidimensionalPoint& operator=(const TMultidimensionalPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMultidimensionalPoint& operator=(TMultidimensionalPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMultidimensionalPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMultidimensionalPoint* internal_default_instance() {
    return reinterpret_cast<const TMultidimensionalPoint*>(
               &_TMultidimensionalPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TMultidimensionalPoint& a, TMultidimensionalPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TMultidimensionalPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMultidimensionalPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMultidimensionalPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMultidimensionalPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMultidimensionalPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMultidimensionalPoint& from) {
    TMultidimensionalPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMultidimensionalPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TMultidimensionalPoint";
  }
  protected:
  explicit TMultidimensionalPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kDomainFieldNumber = 2,
  };
  // required .TNumericValue value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::TNumericValue& value() const;
  PROTOBUF_NODISCARD ::TNumericValue* release_value();
  ::TNumericValue* mutable_value();
  void set_allocated_value(::TNumericValue* value);
  private:
  const ::TNumericValue& _internal_value() const;
  ::TNumericValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::TNumericValue* value);
  ::TNumericValue* unsafe_arena_release_value();

  // required float domain = 2;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  float domain() const;
  void set_domain(float value);
  private:
  float _internal_domain() const;
  void _internal_set_domain(float value);
  public:

  // @@protoc_insertion_point(class_scope:TMultidimensionalPoint)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TNumericValue* value_;
    float domain_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TCurvePointInterpolation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TCurvePointInterpolation) */ {
 public:
  inline TCurvePointInterpolation() : TCurvePointInterpolation(nullptr) {}
  ~TCurvePointInterpolation() override;
  explicit PROTOBUF_CONSTEXPR TCurvePointInterpolation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCurvePointInterpolation(const TCurvePointInterpolation& from);
  TCurvePointInterpolation(TCurvePointInterpolation&& from) noexcept
    : TCurvePointInterpolation() {
    *this = ::std::move(from);
  }

  inline TCurvePointInterpolation& operator=(const TCurvePointInterpolation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCurvePointInterpolation& operator=(TCurvePointInterpolation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCurvePointInterpolation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCurvePointInterpolation* internal_default_instance() {
    return reinterpret_cast<const TCurvePointInterpolation*>(
               &_TCurvePointInterpolation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TCurvePointInterpolation& a, TCurvePointInterpolation& b) {
    a.Swap(&b);
  }
  inline void Swap(TCurvePointInterpolation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCurvePointInterpolation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCurvePointInterpolation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCurvePointInterpolation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCurvePointInterpolation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCurvePointInterpolation& from) {
    TCurvePointInterpolation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCurvePointInterpolation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TCurvePointInterpolation";
  }
  protected:
  explicit TCurvePointInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTangentVectorFieldNumber = 2,
    kInterpolationFieldNumber = 1,
  };
  // optional .TMultidimensionalPoint tangentVector = 2;
  bool has_tangentvector() const;
  private:
  bool _internal_has_tangentvector() const;
  public:
  void clear_tangentvector();
  const ::TMultidimensionalPoint& tangentvector() const;
  PROTOBUF_NODISCARD ::TMultidimensionalPoint* release_tangentvector();
  ::TMultidimensionalPoint* mutable_tangentvector();
  void set_allocated_tangentvector(::TMultidimensionalPoint* tangentvector);
  private:
  const ::TMultidimensionalPoint& _internal_tangentvector() const;
  ::TMultidimensionalPoint* _internal_mutable_tangentvector();
  public:
  void unsafe_arena_set_allocated_tangentvector(
      ::TMultidimensionalPoint* tangentvector);
  ::TMultidimensionalPoint* unsafe_arena_release_tangentvector();

  // required .TCurvePointInterpolationType interpolation = 1;
  bool has_interpolation() const;
  private:
  bool _internal_has_interpolation() const;
  public:
  void clear_interpolation();
  ::TCurvePointInterpolationType interpolation() const;
  void set_interpolation(::TCurvePointInterpolationType value);
  private:
  ::TCurvePointInterpolationType _internal_interpolation() const;
  void _internal_set_interpolation(::TCurvePointInterpolationType value);
  public:

  // @@protoc_insertion_point(class_scope:TCurvePointInterpolation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TMultidimensionalPoint* tangentvector_;
    int interpolation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TCurvePoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TCurvePoint) */ {
 public:
  inline TCurvePoint() : TCurvePoint(nullptr) {}
  ~TCurvePoint() override;
  explicit PROTOBUF_CONSTEXPR TCurvePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCurvePoint(const TCurvePoint& from);
  TCurvePoint(TCurvePoint&& from) noexcept
    : TCurvePoint() {
    *this = ::std::move(from);
  }

  inline TCurvePoint& operator=(const TCurvePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCurvePoint& operator=(TCurvePoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCurvePoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCurvePoint* internal_default_instance() {
    return reinterpret_cast<const TCurvePoint*>(
               &_TCurvePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TCurvePoint& a, TCurvePoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TCurvePoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCurvePoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCurvePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCurvePoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCurvePoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCurvePoint& from) {
    TCurvePoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCurvePoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TCurvePoint";
  }
  protected:
  explicit TCurvePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kIncommingInterpolationFieldNumber = 2,
    kOutgoingInterpolationFieldNumber = 3,
  };
  // required .TMultidimensionalPoint point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::TMultidimensionalPoint& point() const;
  PROTOBUF_NODISCARD ::TMultidimensionalPoint* release_point();
  ::TMultidimensionalPoint* mutable_point();
  void set_allocated_point(::TMultidimensionalPoint* point);
  private:
  const ::TMultidimensionalPoint& _internal_point() const;
  ::TMultidimensionalPoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::TMultidimensionalPoint* point);
  ::TMultidimensionalPoint* unsafe_arena_release_point();

  // optional .TCurvePointInterpolation incommingInterpolation = 2;
  bool has_incomminginterpolation() const;
  private:
  bool _internal_has_incomminginterpolation() const;
  public:
  void clear_incomminginterpolation();
  const ::TCurvePointInterpolation& incomminginterpolation() const;
  PROTOBUF_NODISCARD ::TCurvePointInterpolation* release_incomminginterpolation();
  ::TCurvePointInterpolation* mutable_incomminginterpolation();
  void set_allocated_incomminginterpolation(::TCurvePointInterpolation* incomminginterpolation);
  private:
  const ::TCurvePointInterpolation& _internal_incomminginterpolation() const;
  ::TCurvePointInterpolation* _internal_mutable_incomminginterpolation();
  public:
  void unsafe_arena_set_allocated_incomminginterpolation(
      ::TCurvePointInterpolation* incomminginterpolation);
  ::TCurvePointInterpolation* unsafe_arena_release_incomminginterpolation();

  // optional .TCurvePointInterpolation outgoingInterpolation = 3;
  bool has_outgoinginterpolation() const;
  private:
  bool _internal_has_outgoinginterpolation() const;
  public:
  void clear_outgoinginterpolation();
  const ::TCurvePointInterpolation& outgoinginterpolation() const;
  PROTOBUF_NODISCARD ::TCurvePointInterpolation* release_outgoinginterpolation();
  ::TCurvePointInterpolation* mutable_outgoinginterpolation();
  void set_allocated_outgoinginterpolation(::TCurvePointInterpolation* outgoinginterpolation);
  private:
  const ::TCurvePointInterpolation& _internal_outgoinginterpolation() const;
  ::TCurvePointInterpolation* _internal_mutable_outgoinginterpolation();
  public:
  void unsafe_arena_set_allocated_outgoinginterpolation(
      ::TCurvePointInterpolation* outgoinginterpolation);
  ::TCurvePointInterpolation* unsafe_arena_release_outgoinginterpolation();

  // @@protoc_insertion_point(class_scope:TCurvePoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TMultidimensionalPoint* point_;
    ::TCurvePointInterpolation* incomminginterpolation_;
    ::TCurvePointInterpolation* outgoinginterpolation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TCurveDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TCurveDefinition) */ {
 public:
  inline TCurveDefinition() : TCurveDefinition(nullptr) {}
  ~TCurveDefinition() override;
  explicit PROTOBUF_CONSTEXPR TCurveDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCurveDefinition(const TCurveDefinition& from);
  TCurveDefinition(TCurveDefinition&& from) noexcept
    : TCurveDefinition() {
    *this = ::std::move(from);
  }

  inline TCurveDefinition& operator=(const TCurveDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCurveDefinition& operator=(TCurveDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCurveDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCurveDefinition* internal_default_instance() {
    return reinterpret_cast<const TCurveDefinition*>(
               &_TCurveDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TCurveDefinition& a, TCurveDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(TCurveDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCurveDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCurveDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCurveDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCurveDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCurveDefinition& from) {
    TCurveDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCurveDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TCurveDefinition";
  }
  protected:
  explicit TCurveDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 2,
    kCurveValueTypeFieldNumber = 1,
  };
  // repeated .TCurvePoint point = 2;
  int point_size() const;
  private:
  int _internal_point_size() const;
  public:
  void clear_point();
  ::TCurvePoint* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TCurvePoint >*
      mutable_point();
  private:
  const ::TCurvePoint& _internal_point(int index) const;
  ::TCurvePoint* _internal_add_point();
  public:
  const ::TCurvePoint& point(int index) const;
  ::TCurvePoint* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TCurvePoint >&
      point() const;

  // required .TENumericType curveValueType = 1;
  bool has_curvevaluetype() const;
  private:
  bool _internal_has_curvevaluetype() const;
  public:
  void clear_curvevaluetype();
  ::TENumericType curvevaluetype() const;
  void set_curvevaluetype(::TENumericType value);
  private:
  ::TENumericType _internal_curvevaluetype() const;
  void _internal_set_curvevaluetype(::TENumericType value);
  public:

  // @@protoc_insertion_point(class_scope:TCurveDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TCurvePoint > point_;
    int curvevaluetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TKeyFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TKeyFrame) */ {
 public:
  inline TKeyFrame() : TKeyFrame(nullptr) {}
  ~TKeyFrame() override;
  explicit PROTOBUF_CONSTEXPR TKeyFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TKeyFrame(const TKeyFrame& from);
  TKeyFrame(TKeyFrame&& from) noexcept
    : TKeyFrame() {
    *this = ::std::move(from);
  }

  inline TKeyFrame& operator=(const TKeyFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline TKeyFrame& operator=(TKeyFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TKeyFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const TKeyFrame* internal_default_instance() {
    return reinterpret_cast<const TKeyFrame*>(
               &_TKeyFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TKeyFrame& a, TKeyFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(TKeyFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TKeyFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TKeyFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TKeyFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TKeyFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TKeyFrame& from) {
    TKeyFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TKeyFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TKeyFrame";
  }
  protected:
  explicit TKeyFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kFrameFieldNumber = 1,
  };
  // optional .TNumericValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::TNumericValue& value() const;
  PROTOBUF_NODISCARD ::TNumericValue* release_value();
  ::TNumericValue* mutable_value();
  void set_allocated_value(::TNumericValue* value);
  private:
  const ::TNumericValue& _internal_value() const;
  ::TNumericValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::TNumericValue* value);
  ::TNumericValue* unsafe_arena_release_value();

  // required int32 frame = 1;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  int32_t frame() const;
  void set_frame(int32_t value);
  private:
  int32_t _internal_frame() const;
  void _internal_set_frame(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TKeyFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TNumericValue* value_;
    int32_t frame_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// -------------------------------------------------------------------

class TKeyFrameSequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TKeyFrameSequence) */ {
 public:
  inline TKeyFrameSequence() : TKeyFrameSequence(nullptr) {}
  ~TKeyFrameSequence() override;
  explicit PROTOBUF_CONSTEXPR TKeyFrameSequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TKeyFrameSequence(const TKeyFrameSequence& from);
  TKeyFrameSequence(TKeyFrameSequence&& from) noexcept
    : TKeyFrameSequence() {
    *this = ::std::move(from);
  }

  inline TKeyFrameSequence& operator=(const TKeyFrameSequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TKeyFrameSequence& operator=(TKeyFrameSequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TKeyFrameSequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TKeyFrameSequence* internal_default_instance() {
    return reinterpret_cast<const TKeyFrameSequence*>(
               &_TKeyFrameSequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TKeyFrameSequence& a, TKeyFrameSequence& b) {
    a.Swap(&b);
  }
  inline void Swap(TKeyFrameSequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TKeyFrameSequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TKeyFrameSequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TKeyFrameSequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TKeyFrameSequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TKeyFrameSequence& from) {
    TKeyFrameSequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TKeyFrameSequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TKeyFrameSequence";
  }
  protected:
  explicit TKeyFrameSequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFrameFieldNumber = 2,
    kFpsFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // repeated .TKeyFrame keyFrame = 2;
  int keyframe_size() const;
  private:
  int _internal_keyframe_size() const;
  public:
  void clear_keyframe();
  ::TKeyFrame* mutable_keyframe(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TKeyFrame >*
      mutable_keyframe();
  private:
  const ::TKeyFrame& _internal_keyframe(int index) const;
  ::TKeyFrame* _internal_add_keyframe();
  public:
  const ::TKeyFrame& keyframe(int index) const;
  ::TKeyFrame* add_keyframe();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TKeyFrame >&
      keyframe() const;

  // optional float fps = 1;
  bool has_fps() const;
  private:
  bool _internal_has_fps() const;
  public:
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // required .TENumericType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TENumericType type() const;
  void set_type(::TENumericType value);
  private:
  ::TENumericType _internal_type() const;
  void _internal_set_type(::TENumericType value);
  public:

  // @@protoc_insertion_point(class_scope:TKeyFrameSequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TKeyFrame > keyframe_;
    float fps_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Numeric_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TVector2i

// required int32 x = 1;
inline bool TVector2i::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector2i::has_x() const {
  return _internal_has_x();
}
inline void TVector2i::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TVector2i::_internal_x() const {
  return _impl_.x_;
}
inline int32_t TVector2i::x() const {
  // @@protoc_insertion_point(field_get:TVector2i.x)
  return _internal_x();
}
inline void TVector2i::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector2i::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector2i.x)
}

// required int32 y = 2;
inline bool TVector2i::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector2i::has_y() const {
  return _internal_has_y();
}
inline void TVector2i::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TVector2i::_internal_y() const {
  return _impl_.y_;
}
inline int32_t TVector2i::y() const {
  // @@protoc_insertion_point(field_get:TVector2i.y)
  return _internal_y();
}
inline void TVector2i::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector2i::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector2i.y)
}

// -------------------------------------------------------------------

// TVector3i

// required int32 x = 1;
inline bool TVector3i::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector3i::has_x() const {
  return _internal_has_x();
}
inline void TVector3i::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TVector3i::_internal_x() const {
  return _impl_.x_;
}
inline int32_t TVector3i::x() const {
  // @@protoc_insertion_point(field_get:TVector3i.x)
  return _internal_x();
}
inline void TVector3i::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector3i::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector3i.x)
}

// required int32 y = 2;
inline bool TVector3i::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector3i::has_y() const {
  return _internal_has_y();
}
inline void TVector3i::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TVector3i::_internal_y() const {
  return _impl_.y_;
}
inline int32_t TVector3i::y() const {
  // @@protoc_insertion_point(field_get:TVector3i.y)
  return _internal_y();
}
inline void TVector3i::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector3i::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector3i.y)
}

// required int32 z = 3;
inline bool TVector3i::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TVector3i::has_z() const {
  return _internal_has_z();
}
inline void TVector3i::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TVector3i::_internal_z() const {
  return _impl_.z_;
}
inline int32_t TVector3i::z() const {
  // @@protoc_insertion_point(field_get:TVector3i.z)
  return _internal_z();
}
inline void TVector3i::_internal_set_z(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void TVector3i::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:TVector3i.z)
}

// -------------------------------------------------------------------

// TVector4i

// required int32 x = 1;
inline bool TVector4i::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector4i::has_x() const {
  return _internal_has_x();
}
inline void TVector4i::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TVector4i::_internal_x() const {
  return _impl_.x_;
}
inline int32_t TVector4i::x() const {
  // @@protoc_insertion_point(field_get:TVector4i.x)
  return _internal_x();
}
inline void TVector4i::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector4i::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector4i.x)
}

// required int32 y = 2;
inline bool TVector4i::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector4i::has_y() const {
  return _internal_has_y();
}
inline void TVector4i::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TVector4i::_internal_y() const {
  return _impl_.y_;
}
inline int32_t TVector4i::y() const {
  // @@protoc_insertion_point(field_get:TVector4i.y)
  return _internal_y();
}
inline void TVector4i::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector4i::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector4i.y)
}

// required int32 z = 3;
inline bool TVector4i::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TVector4i::has_z() const {
  return _internal_has_z();
}
inline void TVector4i::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TVector4i::_internal_z() const {
  return _impl_.z_;
}
inline int32_t TVector4i::z() const {
  // @@protoc_insertion_point(field_get:TVector4i.z)
  return _internal_z();
}
inline void TVector4i::_internal_set_z(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void TVector4i::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:TVector4i.z)
}

// required int32 w = 4;
inline bool TVector4i::_internal_has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TVector4i::has_w() const {
  return _internal_has_w();
}
inline void TVector4i::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TVector4i::_internal_w() const {
  return _impl_.w_;
}
inline int32_t TVector4i::w() const {
  // @@protoc_insertion_point(field_get:TVector4i.w)
  return _internal_w();
}
inline void TVector4i::_internal_set_w(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.w_ = value;
}
inline void TVector4i::set_w(int32_t value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:TVector4i.w)
}

// -------------------------------------------------------------------

// TVector2f

// required float x = 1;
inline bool TVector2f::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector2f::has_x() const {
  return _internal_has_x();
}
inline void TVector2f::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TVector2f::_internal_x() const {
  return _impl_.x_;
}
inline float TVector2f::x() const {
  // @@protoc_insertion_point(field_get:TVector2f.x)
  return _internal_x();
}
inline void TVector2f::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector2f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector2f.x)
}

// required float y = 2;
inline bool TVector2f::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector2f::has_y() const {
  return _internal_has_y();
}
inline void TVector2f::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TVector2f::_internal_y() const {
  return _impl_.y_;
}
inline float TVector2f::y() const {
  // @@protoc_insertion_point(field_get:TVector2f.y)
  return _internal_y();
}
inline void TVector2f::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector2f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector2f.y)
}

// -------------------------------------------------------------------

// TVector3f

// required float x = 1;
inline bool TVector3f::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector3f::has_x() const {
  return _internal_has_x();
}
inline void TVector3f::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TVector3f::_internal_x() const {
  return _impl_.x_;
}
inline float TVector3f::x() const {
  // @@protoc_insertion_point(field_get:TVector3f.x)
  return _internal_x();
}
inline void TVector3f::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector3f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector3f.x)
}

// required float y = 2;
inline bool TVector3f::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector3f::has_y() const {
  return _internal_has_y();
}
inline void TVector3f::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TVector3f::_internal_y() const {
  return _impl_.y_;
}
inline float TVector3f::y() const {
  // @@protoc_insertion_point(field_get:TVector3f.y)
  return _internal_y();
}
inline void TVector3f::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector3f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector3f.y)
}

// required float z = 3;
inline bool TVector3f::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TVector3f::has_z() const {
  return _internal_has_z();
}
inline void TVector3f::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TVector3f::_internal_z() const {
  return _impl_.z_;
}
inline float TVector3f::z() const {
  // @@protoc_insertion_point(field_get:TVector3f.z)
  return _internal_z();
}
inline void TVector3f::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void TVector3f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:TVector3f.z)
}

// -------------------------------------------------------------------

// TVector4f

// required float x = 1;
inline bool TVector4f::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TVector4f::has_x() const {
  return _internal_has_x();
}
inline void TVector4f::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TVector4f::_internal_x() const {
  return _impl_.x_;
}
inline float TVector4f::x() const {
  // @@protoc_insertion_point(field_get:TVector4f.x)
  return _internal_x();
}
inline void TVector4f::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TVector4f::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TVector4f.x)
}

// required float y = 2;
inline bool TVector4f::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TVector4f::has_y() const {
  return _internal_has_y();
}
inline void TVector4f::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TVector4f::_internal_y() const {
  return _impl_.y_;
}
inline float TVector4f::y() const {
  // @@protoc_insertion_point(field_get:TVector4f.y)
  return _internal_y();
}
inline void TVector4f::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TVector4f::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TVector4f.y)
}

// required float z = 3;
inline bool TVector4f::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TVector4f::has_z() const {
  return _internal_has_z();
}
inline void TVector4f::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TVector4f::_internal_z() const {
  return _impl_.z_;
}
inline float TVector4f::z() const {
  // @@protoc_insertion_point(field_get:TVector4f.z)
  return _internal_z();
}
inline void TVector4f::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}
inline void TVector4f::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:TVector4f.z)
}

// required float w = 4;
inline bool TVector4f::_internal_has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TVector4f::has_w() const {
  return _internal_has_w();
}
inline void TVector4f::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float TVector4f::_internal_w() const {
  return _impl_.w_;
}
inline float TVector4f::w() const {
  // @@protoc_insertion_point(field_get:TVector4f.w)
  return _internal_w();
}
inline void TVector4f::_internal_set_w(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.w_ = value;
}
inline void TVector4f::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:TVector4f.w)
}

// -------------------------------------------------------------------

// TMatrix3x3f

// optional float m11 = 1;
inline bool TMatrix3x3f::_internal_has_m11() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m11() const {
  return _internal_has_m11();
}
inline void TMatrix3x3f::clear_m11() {
  _impl_.m11_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TMatrix3x3f::_internal_m11() const {
  return _impl_.m11_;
}
inline float TMatrix3x3f::m11() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m11)
  return _internal_m11();
}
inline void TMatrix3x3f::_internal_set_m11(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m11_ = value;
}
inline void TMatrix3x3f::set_m11(float value) {
  _internal_set_m11(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m11)
}

// optional float m12 = 2;
inline bool TMatrix3x3f::_internal_has_m12() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m12() const {
  return _internal_has_m12();
}
inline void TMatrix3x3f::clear_m12() {
  _impl_.m12_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TMatrix3x3f::_internal_m12() const {
  return _impl_.m12_;
}
inline float TMatrix3x3f::m12() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m12)
  return _internal_m12();
}
inline void TMatrix3x3f::_internal_set_m12(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m12_ = value;
}
inline void TMatrix3x3f::set_m12(float value) {
  _internal_set_m12(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m12)
}

// optional float m13 = 3;
inline bool TMatrix3x3f::_internal_has_m13() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m13() const {
  return _internal_has_m13();
}
inline void TMatrix3x3f::clear_m13() {
  _impl_.m13_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TMatrix3x3f::_internal_m13() const {
  return _impl_.m13_;
}
inline float TMatrix3x3f::m13() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m13)
  return _internal_m13();
}
inline void TMatrix3x3f::_internal_set_m13(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m13_ = value;
}
inline void TMatrix3x3f::set_m13(float value) {
  _internal_set_m13(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m13)
}

// optional float m21 = 4;
inline bool TMatrix3x3f::_internal_has_m21() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m21() const {
  return _internal_has_m21();
}
inline void TMatrix3x3f::clear_m21() {
  _impl_.m21_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float TMatrix3x3f::_internal_m21() const {
  return _impl_.m21_;
}
inline float TMatrix3x3f::m21() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m21)
  return _internal_m21();
}
inline void TMatrix3x3f::_internal_set_m21(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m21_ = value;
}
inline void TMatrix3x3f::set_m21(float value) {
  _internal_set_m21(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m21)
}

// optional float m22 = 5;
inline bool TMatrix3x3f::_internal_has_m22() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m22() const {
  return _internal_has_m22();
}
inline void TMatrix3x3f::clear_m22() {
  _impl_.m22_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float TMatrix3x3f::_internal_m22() const {
  return _impl_.m22_;
}
inline float TMatrix3x3f::m22() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m22)
  return _internal_m22();
}
inline void TMatrix3x3f::_internal_set_m22(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m22_ = value;
}
inline void TMatrix3x3f::set_m22(float value) {
  _internal_set_m22(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m22)
}

// optional float m23 = 6;
inline bool TMatrix3x3f::_internal_has_m23() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m23() const {
  return _internal_has_m23();
}
inline void TMatrix3x3f::clear_m23() {
  _impl_.m23_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float TMatrix3x3f::_internal_m23() const {
  return _impl_.m23_;
}
inline float TMatrix3x3f::m23() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m23)
  return _internal_m23();
}
inline void TMatrix3x3f::_internal_set_m23(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m23_ = value;
}
inline void TMatrix3x3f::set_m23(float value) {
  _internal_set_m23(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m23)
}

// optional float m31 = 7;
inline bool TMatrix3x3f::_internal_has_m31() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m31() const {
  return _internal_has_m31();
}
inline void TMatrix3x3f::clear_m31() {
  _impl_.m31_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float TMatrix3x3f::_internal_m31() const {
  return _impl_.m31_;
}
inline float TMatrix3x3f::m31() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m31)
  return _internal_m31();
}
inline void TMatrix3x3f::_internal_set_m31(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.m31_ = value;
}
inline void TMatrix3x3f::set_m31(float value) {
  _internal_set_m31(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m31)
}

// optional float m32 = 8;
inline bool TMatrix3x3f::_internal_has_m32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m32() const {
  return _internal_has_m32();
}
inline void TMatrix3x3f::clear_m32() {
  _impl_.m32_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float TMatrix3x3f::_internal_m32() const {
  return _impl_.m32_;
}
inline float TMatrix3x3f::m32() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m32)
  return _internal_m32();
}
inline void TMatrix3x3f::_internal_set_m32(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.m32_ = value;
}
inline void TMatrix3x3f::set_m32(float value) {
  _internal_set_m32(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m32)
}

// optional float m33 = 9;
inline bool TMatrix3x3f::_internal_has_m33() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TMatrix3x3f::has_m33() const {
  return _internal_has_m33();
}
inline void TMatrix3x3f::clear_m33() {
  _impl_.m33_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float TMatrix3x3f::_internal_m33() const {
  return _impl_.m33_;
}
inline float TMatrix3x3f::m33() const {
  // @@protoc_insertion_point(field_get:TMatrix3x3f.m33)
  return _internal_m33();
}
inline void TMatrix3x3f::_internal_set_m33(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.m33_ = value;
}
inline void TMatrix3x3f::set_m33(float value) {
  _internal_set_m33(value);
  // @@protoc_insertion_point(field_set:TMatrix3x3f.m33)
}

// -------------------------------------------------------------------

// TMatrix4x4f

// optional float m11 = 1;
inline bool TMatrix4x4f::_internal_has_m11() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m11() const {
  return _internal_has_m11();
}
inline void TMatrix4x4f::clear_m11() {
  _impl_.m11_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TMatrix4x4f::_internal_m11() const {
  return _impl_.m11_;
}
inline float TMatrix4x4f::m11() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m11)
  return _internal_m11();
}
inline void TMatrix4x4f::_internal_set_m11(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m11_ = value;
}
inline void TMatrix4x4f::set_m11(float value) {
  _internal_set_m11(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m11)
}

// optional float m12 = 2;
inline bool TMatrix4x4f::_internal_has_m12() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m12() const {
  return _internal_has_m12();
}
inline void TMatrix4x4f::clear_m12() {
  _impl_.m12_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TMatrix4x4f::_internal_m12() const {
  return _impl_.m12_;
}
inline float TMatrix4x4f::m12() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m12)
  return _internal_m12();
}
inline void TMatrix4x4f::_internal_set_m12(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m12_ = value;
}
inline void TMatrix4x4f::set_m12(float value) {
  _internal_set_m12(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m12)
}

// optional float m13 = 3;
inline bool TMatrix4x4f::_internal_has_m13() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m13() const {
  return _internal_has_m13();
}
inline void TMatrix4x4f::clear_m13() {
  _impl_.m13_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float TMatrix4x4f::_internal_m13() const {
  return _impl_.m13_;
}
inline float TMatrix4x4f::m13() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m13)
  return _internal_m13();
}
inline void TMatrix4x4f::_internal_set_m13(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m13_ = value;
}
inline void TMatrix4x4f::set_m13(float value) {
  _internal_set_m13(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m13)
}

// optional float m14 = 4;
inline bool TMatrix4x4f::_internal_has_m14() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m14() const {
  return _internal_has_m14();
}
inline void TMatrix4x4f::clear_m14() {
  _impl_.m14_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float TMatrix4x4f::_internal_m14() const {
  return _impl_.m14_;
}
inline float TMatrix4x4f::m14() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m14)
  return _internal_m14();
}
inline void TMatrix4x4f::_internal_set_m14(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m14_ = value;
}
inline void TMatrix4x4f::set_m14(float value) {
  _internal_set_m14(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m14)
}

// optional float m21 = 5;
inline bool TMatrix4x4f::_internal_has_m21() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m21() const {
  return _internal_has_m21();
}
inline void TMatrix4x4f::clear_m21() {
  _impl_.m21_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float TMatrix4x4f::_internal_m21() const {
  return _impl_.m21_;
}
inline float TMatrix4x4f::m21() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m21)
  return _internal_m21();
}
inline void TMatrix4x4f::_internal_set_m21(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m21_ = value;
}
inline void TMatrix4x4f::set_m21(float value) {
  _internal_set_m21(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m21)
}

// optional float m22 = 6;
inline bool TMatrix4x4f::_internal_has_m22() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m22() const {
  return _internal_has_m22();
}
inline void TMatrix4x4f::clear_m22() {
  _impl_.m22_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float TMatrix4x4f::_internal_m22() const {
  return _impl_.m22_;
}
inline float TMatrix4x4f::m22() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m22)
  return _internal_m22();
}
inline void TMatrix4x4f::_internal_set_m22(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m22_ = value;
}
inline void TMatrix4x4f::set_m22(float value) {
  _internal_set_m22(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m22)
}

// optional float m23 = 7;
inline bool TMatrix4x4f::_internal_has_m23() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m23() const {
  return _internal_has_m23();
}
inline void TMatrix4x4f::clear_m23() {
  _impl_.m23_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float TMatrix4x4f::_internal_m23() const {
  return _impl_.m23_;
}
inline float TMatrix4x4f::m23() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m23)
  return _internal_m23();
}
inline void TMatrix4x4f::_internal_set_m23(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.m23_ = value;
}
inline void TMatrix4x4f::set_m23(float value) {
  _internal_set_m23(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m23)
}

// optional float m24 = 8;
inline bool TMatrix4x4f::_internal_has_m24() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m24() const {
  return _internal_has_m24();
}
inline void TMatrix4x4f::clear_m24() {
  _impl_.m24_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float TMatrix4x4f::_internal_m24() const {
  return _impl_.m24_;
}
inline float TMatrix4x4f::m24() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m24)
  return _internal_m24();
}
inline void TMatrix4x4f::_internal_set_m24(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.m24_ = value;
}
inline void TMatrix4x4f::set_m24(float value) {
  _internal_set_m24(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m24)
}

// optional float m31 = 9;
inline bool TMatrix4x4f::_internal_has_m31() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m31() const {
  return _internal_has_m31();
}
inline void TMatrix4x4f::clear_m31() {
  _impl_.m31_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float TMatrix4x4f::_internal_m31() const {
  return _impl_.m31_;
}
inline float TMatrix4x4f::m31() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m31)
  return _internal_m31();
}
inline void TMatrix4x4f::_internal_set_m31(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.m31_ = value;
}
inline void TMatrix4x4f::set_m31(float value) {
  _internal_set_m31(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m31)
}

// optional float m32 = 10;
inline bool TMatrix4x4f::_internal_has_m32() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m32() const {
  return _internal_has_m32();
}
inline void TMatrix4x4f::clear_m32() {
  _impl_.m32_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float TMatrix4x4f::_internal_m32() const {
  return _impl_.m32_;
}
inline float TMatrix4x4f::m32() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m32)
  return _internal_m32();
}
inline void TMatrix4x4f::_internal_set_m32(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.m32_ = value;
}
inline void TMatrix4x4f::set_m32(float value) {
  _internal_set_m32(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m32)
}

// optional float m33 = 11;
inline bool TMatrix4x4f::_internal_has_m33() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m33() const {
  return _internal_has_m33();
}
inline void TMatrix4x4f::clear_m33() {
  _impl_.m33_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float TMatrix4x4f::_internal_m33() const {
  return _impl_.m33_;
}
inline float TMatrix4x4f::m33() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m33)
  return _internal_m33();
}
inline void TMatrix4x4f::_internal_set_m33(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.m33_ = value;
}
inline void TMatrix4x4f::set_m33(float value) {
  _internal_set_m33(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m33)
}

// optional float m34 = 12;
inline bool TMatrix4x4f::_internal_has_m34() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m34() const {
  return _internal_has_m34();
}
inline void TMatrix4x4f::clear_m34() {
  _impl_.m34_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float TMatrix4x4f::_internal_m34() const {
  return _impl_.m34_;
}
inline float TMatrix4x4f::m34() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m34)
  return _internal_m34();
}
inline void TMatrix4x4f::_internal_set_m34(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.m34_ = value;
}
inline void TMatrix4x4f::set_m34(float value) {
  _internal_set_m34(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m34)
}

// optional float m41 = 13;
inline bool TMatrix4x4f::_internal_has_m41() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m41() const {
  return _internal_has_m41();
}
inline void TMatrix4x4f::clear_m41() {
  _impl_.m41_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float TMatrix4x4f::_internal_m41() const {
  return _impl_.m41_;
}
inline float TMatrix4x4f::m41() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m41)
  return _internal_m41();
}
inline void TMatrix4x4f::_internal_set_m41(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.m41_ = value;
}
inline void TMatrix4x4f::set_m41(float value) {
  _internal_set_m41(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m41)
}

// optional float m42 = 14;
inline bool TMatrix4x4f::_internal_has_m42() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m42() const {
  return _internal_has_m42();
}
inline void TMatrix4x4f::clear_m42() {
  _impl_.m42_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float TMatrix4x4f::_internal_m42() const {
  return _impl_.m42_;
}
inline float TMatrix4x4f::m42() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m42)
  return _internal_m42();
}
inline void TMatrix4x4f::_internal_set_m42(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.m42_ = value;
}
inline void TMatrix4x4f::set_m42(float value) {
  _internal_set_m42(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m42)
}

// optional float m43 = 15;
inline bool TMatrix4x4f::_internal_has_m43() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m43() const {
  return _internal_has_m43();
}
inline void TMatrix4x4f::clear_m43() {
  _impl_.m43_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float TMatrix4x4f::_internal_m43() const {
  return _impl_.m43_;
}
inline float TMatrix4x4f::m43() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m43)
  return _internal_m43();
}
inline void TMatrix4x4f::_internal_set_m43(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.m43_ = value;
}
inline void TMatrix4x4f::set_m43(float value) {
  _internal_set_m43(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m43)
}

// optional float m44 = 16;
inline bool TMatrix4x4f::_internal_has_m44() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TMatrix4x4f::has_m44() const {
  return _internal_has_m44();
}
inline void TMatrix4x4f::clear_m44() {
  _impl_.m44_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float TMatrix4x4f::_internal_m44() const {
  return _impl_.m44_;
}
inline float TMatrix4x4f::m44() const {
  // @@protoc_insertion_point(field_get:TMatrix4x4f.m44)
  return _internal_m44();
}
inline void TMatrix4x4f::_internal_set_m44(float value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.m44_ = value;
}
inline void TMatrix4x4f::set_m44(float value) {
  _internal_set_m44(value);
  // @@protoc_insertion_point(field_set:TMatrix4x4f.m44)
}

// -------------------------------------------------------------------

// TAxisAlignedBoundingBox

// required .TVector3f min = 1;
inline bool TAxisAlignedBoundingBox::_internal_has_min() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.min_ != nullptr);
  return value;
}
inline bool TAxisAlignedBoundingBox::has_min() const {
  return _internal_has_min();
}
inline void TAxisAlignedBoundingBox::clear_min() {
  if (_impl_.min_ != nullptr) _impl_.min_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TVector3f& TAxisAlignedBoundingBox::_internal_min() const {
  const ::TVector3f* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TAxisAlignedBoundingBox::min() const {
  // @@protoc_insertion_point(field_get:TAxisAlignedBoundingBox.min)
  return _internal_min();
}
inline void TAxisAlignedBoundingBox::unsafe_arena_set_allocated_min(
    ::TVector3f* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TAxisAlignedBoundingBox.min)
}
inline ::TVector3f* TAxisAlignedBoundingBox::release_min() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TAxisAlignedBoundingBox::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:TAxisAlignedBoundingBox.min)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::TVector3f* TAxisAlignedBoundingBox::_internal_mutable_min() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::TVector3f* TAxisAlignedBoundingBox::mutable_min() {
  ::TVector3f* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:TAxisAlignedBoundingBox.min)
  return _msg;
}
inline void TAxisAlignedBoundingBox::set_allocated_min(::TVector3f* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.min_;
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(min);
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:TAxisAlignedBoundingBox.min)
}

// required .TVector3f max = 2;
inline bool TAxisAlignedBoundingBox::_internal_has_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.max_ != nullptr);
  return value;
}
inline bool TAxisAlignedBoundingBox::has_max() const {
  return _internal_has_max();
}
inline void TAxisAlignedBoundingBox::clear_max() {
  if (_impl_.max_ != nullptr) _impl_.max_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TVector3f& TAxisAlignedBoundingBox::_internal_max() const {
  const ::TVector3f* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TAxisAlignedBoundingBox::max() const {
  // @@protoc_insertion_point(field_get:TAxisAlignedBoundingBox.max)
  return _internal_max();
}
inline void TAxisAlignedBoundingBox::unsafe_arena_set_allocated_max(
    ::TVector3f* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TAxisAlignedBoundingBox.max)
}
inline ::TVector3f* TAxisAlignedBoundingBox::release_max() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TAxisAlignedBoundingBox::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:TAxisAlignedBoundingBox.max)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::TVector3f* TAxisAlignedBoundingBox::_internal_mutable_max() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::TVector3f* TAxisAlignedBoundingBox::mutable_max() {
  ::TVector3f* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:TAxisAlignedBoundingBox.max)
  return _msg;
}
inline void TAxisAlignedBoundingBox::set_allocated_max(::TVector3f* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.max_;
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(max);
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:TAxisAlignedBoundingBox.max)
}

// -------------------------------------------------------------------

// TNumericValue

// optional int32 Int = 1;
inline bool TNumericValue::_internal_has_int_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TNumericValue::has_int_() const {
  return _internal_has_int_();
}
inline void TNumericValue::clear_int_() {
  _impl_.int__ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t TNumericValue::_internal_int_() const {
  return _impl_.int__;
}
inline int32_t TNumericValue::int_() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Int)
  return _internal_int_();
}
inline void TNumericValue::_internal_set_int_(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.int__ = value;
}
inline void TNumericValue::set_int_(int32_t value) {
  _internal_set_int_(value);
  // @@protoc_insertion_point(field_set:TNumericValue.Int)
}

// optional uint32 UInt = 2;
inline bool TNumericValue::_internal_has_uint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TNumericValue::has_uint() const {
  return _internal_has_uint();
}
inline void TNumericValue::clear_uint() {
  _impl_.uint_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TNumericValue::_internal_uint() const {
  return _impl_.uint_;
}
inline uint32_t TNumericValue::uint() const {
  // @@protoc_insertion_point(field_get:TNumericValue.UInt)
  return _internal_uint();
}
inline void TNumericValue::_internal_set_uint(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.uint_ = value;
}
inline void TNumericValue::set_uint(uint32_t value) {
  _internal_set_uint(value);
  // @@protoc_insertion_point(field_set:TNumericValue.UInt)
}

// optional float Float = 3;
inline bool TNumericValue::_internal_has_float_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TNumericValue::has_float_() const {
  return _internal_has_float_();
}
inline void TNumericValue::clear_float_() {
  _impl_.float__ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float TNumericValue::_internal_float_() const {
  return _impl_.float__;
}
inline float TNumericValue::float_() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Float)
  return _internal_float_();
}
inline void TNumericValue::_internal_set_float_(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.float__ = value;
}
inline void TNumericValue::set_float_(float value) {
  _internal_set_float_(value);
  // @@protoc_insertion_point(field_set:TNumericValue.Float)
}

// optional .TVector2f Vec2f = 4;
inline bool TNumericValue::_internal_has_vec2f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec2f_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec2f() const {
  return _internal_has_vec2f();
}
inline void TNumericValue::clear_vec2f() {
  if (_impl_.vec2f_ != nullptr) _impl_.vec2f_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TVector2f& TNumericValue::_internal_vec2f() const {
  const ::TVector2f* p = _impl_.vec2f_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector2f&>(
      ::_TVector2f_default_instance_);
}
inline const ::TVector2f& TNumericValue::vec2f() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec2f)
  return _internal_vec2f();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec2f(
    ::TVector2f* vec2f) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec2f_);
  }
  _impl_.vec2f_ = vec2f;
  if (vec2f) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec2f)
}
inline ::TVector2f* TNumericValue::release_vec2f() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector2f* temp = _impl_.vec2f_;
  _impl_.vec2f_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector2f* TNumericValue::unsafe_arena_release_vec2f() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec2f)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector2f* temp = _impl_.vec2f_;
  _impl_.vec2f_ = nullptr;
  return temp;
}
inline ::TVector2f* TNumericValue::_internal_mutable_vec2f() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.vec2f_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector2f>(GetArenaForAllocation());
    _impl_.vec2f_ = p;
  }
  return _impl_.vec2f_;
}
inline ::TVector2f* TNumericValue::mutable_vec2f() {
  ::TVector2f* _msg = _internal_mutable_vec2f();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec2f)
  return _msg;
}
inline void TNumericValue::set_allocated_vec2f(::TVector2f* vec2f) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec2f_;
  }
  if (vec2f) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec2f);
    if (message_arena != submessage_arena) {
      vec2f = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec2f, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vec2f_ = vec2f;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec2f)
}

// optional .TVector3f Vec3f = 5;
inline bool TNumericValue::_internal_has_vec3f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec3f_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec3f() const {
  return _internal_has_vec3f();
}
inline void TNumericValue::clear_vec3f() {
  if (_impl_.vec3f_ != nullptr) _impl_.vec3f_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TVector3f& TNumericValue::_internal_vec3f() const {
  const ::TVector3f* p = _impl_.vec3f_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TNumericValue::vec3f() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec3f)
  return _internal_vec3f();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec3f(
    ::TVector3f* vec3f) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec3f_);
  }
  _impl_.vec3f_ = vec3f;
  if (vec3f) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec3f)
}
inline ::TVector3f* TNumericValue::release_vec3f() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.vec3f_;
  _impl_.vec3f_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TNumericValue::unsafe_arena_release_vec3f() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec3f)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.vec3f_;
  _impl_.vec3f_ = nullptr;
  return temp;
}
inline ::TVector3f* TNumericValue::_internal_mutable_vec3f() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vec3f_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.vec3f_ = p;
  }
  return _impl_.vec3f_;
}
inline ::TVector3f* TNumericValue::mutable_vec3f() {
  ::TVector3f* _msg = _internal_mutable_vec3f();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec3f)
  return _msg;
}
inline void TNumericValue::set_allocated_vec3f(::TVector3f* vec3f) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec3f_;
  }
  if (vec3f) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec3f);
    if (message_arena != submessage_arena) {
      vec3f = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec3f, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vec3f_ = vec3f;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec3f)
}

// optional .TVector4f Vec4f = 6;
inline bool TNumericValue::_internal_has_vec4f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec4f_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec4f() const {
  return _internal_has_vec4f();
}
inline void TNumericValue::clear_vec4f() {
  if (_impl_.vec4f_ != nullptr) _impl_.vec4f_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TVector4f& TNumericValue::_internal_vec4f() const {
  const ::TVector4f* p = _impl_.vec4f_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector4f&>(
      ::_TVector4f_default_instance_);
}
inline const ::TVector4f& TNumericValue::vec4f() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec4f)
  return _internal_vec4f();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec4f(
    ::TVector4f* vec4f) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec4f_);
  }
  _impl_.vec4f_ = vec4f;
  if (vec4f) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec4f)
}
inline ::TVector4f* TNumericValue::release_vec4f() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TVector4f* temp = _impl_.vec4f_;
  _impl_.vec4f_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector4f* TNumericValue::unsafe_arena_release_vec4f() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec4f)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TVector4f* temp = _impl_.vec4f_;
  _impl_.vec4f_ = nullptr;
  return temp;
}
inline ::TVector4f* TNumericValue::_internal_mutable_vec4f() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.vec4f_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector4f>(GetArenaForAllocation());
    _impl_.vec4f_ = p;
  }
  return _impl_.vec4f_;
}
inline ::TVector4f* TNumericValue::mutable_vec4f() {
  ::TVector4f* _msg = _internal_mutable_vec4f();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec4f)
  return _msg;
}
inline void TNumericValue::set_allocated_vec4f(::TVector4f* vec4f) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec4f_;
  }
  if (vec4f) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec4f);
    if (message_arena != submessage_arena) {
      vec4f = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec4f, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.vec4f_ = vec4f;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec4f)
}

// optional .TVector2i Vec2i = 7;
inline bool TNumericValue::_internal_has_vec2i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec2i_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec2i() const {
  return _internal_has_vec2i();
}
inline void TNumericValue::clear_vec2i() {
  if (_impl_.vec2i_ != nullptr) _impl_.vec2i_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TVector2i& TNumericValue::_internal_vec2i() const {
  const ::TVector2i* p = _impl_.vec2i_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector2i&>(
      ::_TVector2i_default_instance_);
}
inline const ::TVector2i& TNumericValue::vec2i() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec2i)
  return _internal_vec2i();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec2i(
    ::TVector2i* vec2i) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec2i_);
  }
  _impl_.vec2i_ = vec2i;
  if (vec2i) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec2i)
}
inline ::TVector2i* TNumericValue::release_vec2i() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector2i* temp = _impl_.vec2i_;
  _impl_.vec2i_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector2i* TNumericValue::unsafe_arena_release_vec2i() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec2i)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector2i* temp = _impl_.vec2i_;
  _impl_.vec2i_ = nullptr;
  return temp;
}
inline ::TVector2i* TNumericValue::_internal_mutable_vec2i() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vec2i_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector2i>(GetArenaForAllocation());
    _impl_.vec2i_ = p;
  }
  return _impl_.vec2i_;
}
inline ::TVector2i* TNumericValue::mutable_vec2i() {
  ::TVector2i* _msg = _internal_mutable_vec2i();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec2i)
  return _msg;
}
inline void TNumericValue::set_allocated_vec2i(::TVector2i* vec2i) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec2i_;
  }
  if (vec2i) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec2i);
    if (message_arena != submessage_arena) {
      vec2i = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec2i, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.vec2i_ = vec2i;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec2i)
}

// optional .TVector3i Vec3i = 8;
inline bool TNumericValue::_internal_has_vec3i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec3i_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec3i() const {
  return _internal_has_vec3i();
}
inline void TNumericValue::clear_vec3i() {
  if (_impl_.vec3i_ != nullptr) _impl_.vec3i_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TVector3i& TNumericValue::_internal_vec3i() const {
  const ::TVector3i* p = _impl_.vec3i_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3i&>(
      ::_TVector3i_default_instance_);
}
inline const ::TVector3i& TNumericValue::vec3i() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec3i)
  return _internal_vec3i();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec3i(
    ::TVector3i* vec3i) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec3i_);
  }
  _impl_.vec3i_ = vec3i;
  if (vec3i) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec3i)
}
inline ::TVector3i* TNumericValue::release_vec3i() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TVector3i* temp = _impl_.vec3i_;
  _impl_.vec3i_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3i* TNumericValue::unsafe_arena_release_vec3i() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec3i)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TVector3i* temp = _impl_.vec3i_;
  _impl_.vec3i_ = nullptr;
  return temp;
}
inline ::TVector3i* TNumericValue::_internal_mutable_vec3i() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.vec3i_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3i>(GetArenaForAllocation());
    _impl_.vec3i_ = p;
  }
  return _impl_.vec3i_;
}
inline ::TVector3i* TNumericValue::mutable_vec3i() {
  ::TVector3i* _msg = _internal_mutable_vec3i();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec3i)
  return _msg;
}
inline void TNumericValue::set_allocated_vec3i(::TVector3i* vec3i) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec3i_;
  }
  if (vec3i) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec3i);
    if (message_arena != submessage_arena) {
      vec3i = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec3i, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.vec3i_ = vec3i;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec3i)
}

// optional .TVector4i Vec4i = 9;
inline bool TNumericValue::_internal_has_vec4i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vec4i_ != nullptr);
  return value;
}
inline bool TNumericValue::has_vec4i() const {
  return _internal_has_vec4i();
}
inline void TNumericValue::clear_vec4i() {
  if (_impl_.vec4i_ != nullptr) _impl_.vec4i_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::TVector4i& TNumericValue::_internal_vec4i() const {
  const ::TVector4i* p = _impl_.vec4i_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector4i&>(
      ::_TVector4i_default_instance_);
}
inline const ::TVector4i& TNumericValue::vec4i() const {
  // @@protoc_insertion_point(field_get:TNumericValue.Vec4i)
  return _internal_vec4i();
}
inline void TNumericValue::unsafe_arena_set_allocated_vec4i(
    ::TVector4i* vec4i) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vec4i_);
  }
  _impl_.vec4i_ = vec4i;
  if (vec4i) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.Vec4i)
}
inline ::TVector4i* TNumericValue::release_vec4i() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TVector4i* temp = _impl_.vec4i_;
  _impl_.vec4i_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector4i* TNumericValue::unsafe_arena_release_vec4i() {
  // @@protoc_insertion_point(field_release:TNumericValue.Vec4i)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TVector4i* temp = _impl_.vec4i_;
  _impl_.vec4i_ = nullptr;
  return temp;
}
inline ::TVector4i* TNumericValue::_internal_mutable_vec4i() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.vec4i_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector4i>(GetArenaForAllocation());
    _impl_.vec4i_ = p;
  }
  return _impl_.vec4i_;
}
inline ::TVector4i* TNumericValue::mutable_vec4i() {
  ::TVector4i* _msg = _internal_mutable_vec4i();
  // @@protoc_insertion_point(field_mutable:TNumericValue.Vec4i)
  return _msg;
}
inline void TNumericValue::set_allocated_vec4i(::TVector4i* vec4i) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vec4i_;
  }
  if (vec4i) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vec4i);
    if (message_arena != submessage_arena) {
      vec4i = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec4i, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.vec4i_ = vec4i;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.Vec4i)
}

// optional .TMatrix3x3f FloatMatrix3 = 10;
inline bool TNumericValue::_internal_has_floatmatrix3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.floatmatrix3_ != nullptr);
  return value;
}
inline bool TNumericValue::has_floatmatrix3() const {
  return _internal_has_floatmatrix3();
}
inline void TNumericValue::clear_floatmatrix3() {
  if (_impl_.floatmatrix3_ != nullptr) _impl_.floatmatrix3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::TMatrix3x3f& TNumericValue::_internal_floatmatrix3() const {
  const ::TMatrix3x3f* p = _impl_.floatmatrix3_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMatrix3x3f&>(
      ::_TMatrix3x3f_default_instance_);
}
inline const ::TMatrix3x3f& TNumericValue::floatmatrix3() const {
  // @@protoc_insertion_point(field_get:TNumericValue.FloatMatrix3)
  return _internal_floatmatrix3();
}
inline void TNumericValue::unsafe_arena_set_allocated_floatmatrix3(
    ::TMatrix3x3f* floatmatrix3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.floatmatrix3_);
  }
  _impl_.floatmatrix3_ = floatmatrix3;
  if (floatmatrix3) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.FloatMatrix3)
}
inline ::TMatrix3x3f* TNumericValue::release_floatmatrix3() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TMatrix3x3f* temp = _impl_.floatmatrix3_;
  _impl_.floatmatrix3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMatrix3x3f* TNumericValue::unsafe_arena_release_floatmatrix3() {
  // @@protoc_insertion_point(field_release:TNumericValue.FloatMatrix3)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TMatrix3x3f* temp = _impl_.floatmatrix3_;
  _impl_.floatmatrix3_ = nullptr;
  return temp;
}
inline ::TMatrix3x3f* TNumericValue::_internal_mutable_floatmatrix3() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.floatmatrix3_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMatrix3x3f>(GetArenaForAllocation());
    _impl_.floatmatrix3_ = p;
  }
  return _impl_.floatmatrix3_;
}
inline ::TMatrix3x3f* TNumericValue::mutable_floatmatrix3() {
  ::TMatrix3x3f* _msg = _internal_mutable_floatmatrix3();
  // @@protoc_insertion_point(field_mutable:TNumericValue.FloatMatrix3)
  return _msg;
}
inline void TNumericValue::set_allocated_floatmatrix3(::TMatrix3x3f* floatmatrix3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.floatmatrix3_;
  }
  if (floatmatrix3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(floatmatrix3);
    if (message_arena != submessage_arena) {
      floatmatrix3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floatmatrix3, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.floatmatrix3_ = floatmatrix3;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.FloatMatrix3)
}

// optional .TMatrix4x4f FloatMatrix4 = 11;
inline bool TNumericValue::_internal_has_floatmatrix4() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.floatmatrix4_ != nullptr);
  return value;
}
inline bool TNumericValue::has_floatmatrix4() const {
  return _internal_has_floatmatrix4();
}
inline void TNumericValue::clear_floatmatrix4() {
  if (_impl_.floatmatrix4_ != nullptr) _impl_.floatmatrix4_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::TMatrix4x4f& TNumericValue::_internal_floatmatrix4() const {
  const ::TMatrix4x4f* p = _impl_.floatmatrix4_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMatrix4x4f&>(
      ::_TMatrix4x4f_default_instance_);
}
inline const ::TMatrix4x4f& TNumericValue::floatmatrix4() const {
  // @@protoc_insertion_point(field_get:TNumericValue.FloatMatrix4)
  return _internal_floatmatrix4();
}
inline void TNumericValue::unsafe_arena_set_allocated_floatmatrix4(
    ::TMatrix4x4f* floatmatrix4) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.floatmatrix4_);
  }
  _impl_.floatmatrix4_ = floatmatrix4;
  if (floatmatrix4) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TNumericValue.FloatMatrix4)
}
inline ::TMatrix4x4f* TNumericValue::release_floatmatrix4() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TMatrix4x4f* temp = _impl_.floatmatrix4_;
  _impl_.floatmatrix4_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMatrix4x4f* TNumericValue::unsafe_arena_release_floatmatrix4() {
  // @@protoc_insertion_point(field_release:TNumericValue.FloatMatrix4)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TMatrix4x4f* temp = _impl_.floatmatrix4_;
  _impl_.floatmatrix4_ = nullptr;
  return temp;
}
inline ::TMatrix4x4f* TNumericValue::_internal_mutable_floatmatrix4() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.floatmatrix4_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMatrix4x4f>(GetArenaForAllocation());
    _impl_.floatmatrix4_ = p;
  }
  return _impl_.floatmatrix4_;
}
inline ::TMatrix4x4f* TNumericValue::mutable_floatmatrix4() {
  ::TMatrix4x4f* _msg = _internal_mutable_floatmatrix4();
  // @@protoc_insertion_point(field_mutable:TNumericValue.FloatMatrix4)
  return _msg;
}
inline void TNumericValue::set_allocated_floatmatrix4(::TMatrix4x4f* floatmatrix4) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.floatmatrix4_;
  }
  if (floatmatrix4) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(floatmatrix4);
    if (message_arena != submessage_arena) {
      floatmatrix4 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floatmatrix4, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.floatmatrix4_ = floatmatrix4;
  // @@protoc_insertion_point(field_set_allocated:TNumericValue.FloatMatrix4)
}

// -------------------------------------------------------------------

// TMultidimensionalPoint

// required .TNumericValue value = 1;
inline bool TMultidimensionalPoint::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool TMultidimensionalPoint::has_value() const {
  return _internal_has_value();
}
inline void TMultidimensionalPoint::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TNumericValue& TMultidimensionalPoint::_internal_value() const {
  const ::TNumericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TNumericValue&>(
      ::_TNumericValue_default_instance_);
}
inline const ::TNumericValue& TMultidimensionalPoint::value() const {
  // @@protoc_insertion_point(field_get:TMultidimensionalPoint.value)
  return _internal_value();
}
inline void TMultidimensionalPoint::unsafe_arena_set_allocated_value(
    ::TNumericValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TMultidimensionalPoint.value)
}
inline ::TNumericValue* TMultidimensionalPoint::release_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TNumericValue* TMultidimensionalPoint::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:TMultidimensionalPoint.value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::TNumericValue* TMultidimensionalPoint::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TNumericValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::TNumericValue* TMultidimensionalPoint::mutable_value() {
  ::TNumericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TMultidimensionalPoint.value)
  return _msg;
}
inline void TMultidimensionalPoint::set_allocated_value(::TNumericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:TMultidimensionalPoint.value)
}

// required float domain = 2;
inline bool TMultidimensionalPoint::_internal_has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMultidimensionalPoint::has_domain() const {
  return _internal_has_domain();
}
inline void TMultidimensionalPoint::clear_domain() {
  _impl_.domain_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TMultidimensionalPoint::_internal_domain() const {
  return _impl_.domain_;
}
inline float TMultidimensionalPoint::domain() const {
  // @@protoc_insertion_point(field_get:TMultidimensionalPoint.domain)
  return _internal_domain();
}
inline void TMultidimensionalPoint::_internal_set_domain(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.domain_ = value;
}
inline void TMultidimensionalPoint::set_domain(float value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:TMultidimensionalPoint.domain)
}

// -------------------------------------------------------------------

// TCurvePointInterpolation

// required .TCurvePointInterpolationType interpolation = 1;
inline bool TCurvePointInterpolation::_internal_has_interpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TCurvePointInterpolation::has_interpolation() const {
  return _internal_has_interpolation();
}
inline void TCurvePointInterpolation::clear_interpolation() {
  _impl_.interpolation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TCurvePointInterpolationType TCurvePointInterpolation::_internal_interpolation() const {
  return static_cast< ::TCurvePointInterpolationType >(_impl_.interpolation_);
}
inline ::TCurvePointInterpolationType TCurvePointInterpolation::interpolation() const {
  // @@protoc_insertion_point(field_get:TCurvePointInterpolation.interpolation)
  return _internal_interpolation();
}
inline void TCurvePointInterpolation::_internal_set_interpolation(::TCurvePointInterpolationType value) {
  assert(::TCurvePointInterpolationType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.interpolation_ = value;
}
inline void TCurvePointInterpolation::set_interpolation(::TCurvePointInterpolationType value) {
  _internal_set_interpolation(value);
  // @@protoc_insertion_point(field_set:TCurvePointInterpolation.interpolation)
}

// optional .TMultidimensionalPoint tangentVector = 2;
inline bool TCurvePointInterpolation::_internal_has_tangentvector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tangentvector_ != nullptr);
  return value;
}
inline bool TCurvePointInterpolation::has_tangentvector() const {
  return _internal_has_tangentvector();
}
inline void TCurvePointInterpolation::clear_tangentvector() {
  if (_impl_.tangentvector_ != nullptr) _impl_.tangentvector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TMultidimensionalPoint& TCurvePointInterpolation::_internal_tangentvector() const {
  const ::TMultidimensionalPoint* p = _impl_.tangentvector_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMultidimensionalPoint&>(
      ::_TMultidimensionalPoint_default_instance_);
}
inline const ::TMultidimensionalPoint& TCurvePointInterpolation::tangentvector() const {
  // @@protoc_insertion_point(field_get:TCurvePointInterpolation.tangentVector)
  return _internal_tangentvector();
}
inline void TCurvePointInterpolation::unsafe_arena_set_allocated_tangentvector(
    ::TMultidimensionalPoint* tangentvector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tangentvector_);
  }
  _impl_.tangentvector_ = tangentvector;
  if (tangentvector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCurvePointInterpolation.tangentVector)
}
inline ::TMultidimensionalPoint* TCurvePointInterpolation::release_tangentvector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMultidimensionalPoint* temp = _impl_.tangentvector_;
  _impl_.tangentvector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMultidimensionalPoint* TCurvePointInterpolation::unsafe_arena_release_tangentvector() {
  // @@protoc_insertion_point(field_release:TCurvePointInterpolation.tangentVector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMultidimensionalPoint* temp = _impl_.tangentvector_;
  _impl_.tangentvector_ = nullptr;
  return temp;
}
inline ::TMultidimensionalPoint* TCurvePointInterpolation::_internal_mutable_tangentvector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tangentvector_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMultidimensionalPoint>(GetArenaForAllocation());
    _impl_.tangentvector_ = p;
  }
  return _impl_.tangentvector_;
}
inline ::TMultidimensionalPoint* TCurvePointInterpolation::mutable_tangentvector() {
  ::TMultidimensionalPoint* _msg = _internal_mutable_tangentvector();
  // @@protoc_insertion_point(field_mutable:TCurvePointInterpolation.tangentVector)
  return _msg;
}
inline void TCurvePointInterpolation::set_allocated_tangentvector(::TMultidimensionalPoint* tangentvector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tangentvector_;
  }
  if (tangentvector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tangentvector);
    if (message_arena != submessage_arena) {
      tangentvector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tangentvector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tangentvector_ = tangentvector;
  // @@protoc_insertion_point(field_set_allocated:TCurvePointInterpolation.tangentVector)
}

// -------------------------------------------------------------------

// TCurvePoint

// required .TMultidimensionalPoint point = 1;
inline bool TCurvePoint::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline bool TCurvePoint::has_point() const {
  return _internal_has_point();
}
inline void TCurvePoint::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TMultidimensionalPoint& TCurvePoint::_internal_point() const {
  const ::TMultidimensionalPoint* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMultidimensionalPoint&>(
      ::_TMultidimensionalPoint_default_instance_);
}
inline const ::TMultidimensionalPoint& TCurvePoint::point() const {
  // @@protoc_insertion_point(field_get:TCurvePoint.point)
  return _internal_point();
}
inline void TCurvePoint::unsafe_arena_set_allocated_point(
    ::TMultidimensionalPoint* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCurvePoint.point)
}
inline ::TMultidimensionalPoint* TCurvePoint::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMultidimensionalPoint* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMultidimensionalPoint* TCurvePoint::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:TCurvePoint.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMultidimensionalPoint* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::TMultidimensionalPoint* TCurvePoint::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMultidimensionalPoint>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::TMultidimensionalPoint* TCurvePoint::mutable_point() {
  ::TMultidimensionalPoint* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:TCurvePoint.point)
  return _msg;
}
inline void TCurvePoint::set_allocated_point(::TMultidimensionalPoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:TCurvePoint.point)
}

// optional .TCurvePointInterpolation incommingInterpolation = 2;
inline bool TCurvePoint::_internal_has_incomminginterpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.incomminginterpolation_ != nullptr);
  return value;
}
inline bool TCurvePoint::has_incomminginterpolation() const {
  return _internal_has_incomminginterpolation();
}
inline void TCurvePoint::clear_incomminginterpolation() {
  if (_impl_.incomminginterpolation_ != nullptr) _impl_.incomminginterpolation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TCurvePointInterpolation& TCurvePoint::_internal_incomminginterpolation() const {
  const ::TCurvePointInterpolation* p = _impl_.incomminginterpolation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TCurvePointInterpolation&>(
      ::_TCurvePointInterpolation_default_instance_);
}
inline const ::TCurvePointInterpolation& TCurvePoint::incomminginterpolation() const {
  // @@protoc_insertion_point(field_get:TCurvePoint.incommingInterpolation)
  return _internal_incomminginterpolation();
}
inline void TCurvePoint::unsafe_arena_set_allocated_incomminginterpolation(
    ::TCurvePointInterpolation* incomminginterpolation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.incomminginterpolation_);
  }
  _impl_.incomminginterpolation_ = incomminginterpolation;
  if (incomminginterpolation) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCurvePoint.incommingInterpolation)
}
inline ::TCurvePointInterpolation* TCurvePoint::release_incomminginterpolation() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TCurvePointInterpolation* temp = _impl_.incomminginterpolation_;
  _impl_.incomminginterpolation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TCurvePointInterpolation* TCurvePoint::unsafe_arena_release_incomminginterpolation() {
  // @@protoc_insertion_point(field_release:TCurvePoint.incommingInterpolation)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TCurvePointInterpolation* temp = _impl_.incomminginterpolation_;
  _impl_.incomminginterpolation_ = nullptr;
  return temp;
}
inline ::TCurvePointInterpolation* TCurvePoint::_internal_mutable_incomminginterpolation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.incomminginterpolation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TCurvePointInterpolation>(GetArenaForAllocation());
    _impl_.incomminginterpolation_ = p;
  }
  return _impl_.incomminginterpolation_;
}
inline ::TCurvePointInterpolation* TCurvePoint::mutable_incomminginterpolation() {
  ::TCurvePointInterpolation* _msg = _internal_mutable_incomminginterpolation();
  // @@protoc_insertion_point(field_mutable:TCurvePoint.incommingInterpolation)
  return _msg;
}
inline void TCurvePoint::set_allocated_incomminginterpolation(::TCurvePointInterpolation* incomminginterpolation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.incomminginterpolation_;
  }
  if (incomminginterpolation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(incomminginterpolation);
    if (message_arena != submessage_arena) {
      incomminginterpolation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incomminginterpolation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.incomminginterpolation_ = incomminginterpolation;
  // @@protoc_insertion_point(field_set_allocated:TCurvePoint.incommingInterpolation)
}

// optional .TCurvePointInterpolation outgoingInterpolation = 3;
inline bool TCurvePoint::_internal_has_outgoinginterpolation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outgoinginterpolation_ != nullptr);
  return value;
}
inline bool TCurvePoint::has_outgoinginterpolation() const {
  return _internal_has_outgoinginterpolation();
}
inline void TCurvePoint::clear_outgoinginterpolation() {
  if (_impl_.outgoinginterpolation_ != nullptr) _impl_.outgoinginterpolation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TCurvePointInterpolation& TCurvePoint::_internal_outgoinginterpolation() const {
  const ::TCurvePointInterpolation* p = _impl_.outgoinginterpolation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TCurvePointInterpolation&>(
      ::_TCurvePointInterpolation_default_instance_);
}
inline const ::TCurvePointInterpolation& TCurvePoint::outgoinginterpolation() const {
  // @@protoc_insertion_point(field_get:TCurvePoint.outgoingInterpolation)
  return _internal_outgoinginterpolation();
}
inline void TCurvePoint::unsafe_arena_set_allocated_outgoinginterpolation(
    ::TCurvePointInterpolation* outgoinginterpolation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outgoinginterpolation_);
  }
  _impl_.outgoinginterpolation_ = outgoinginterpolation;
  if (outgoinginterpolation) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TCurvePoint.outgoingInterpolation)
}
inline ::TCurvePointInterpolation* TCurvePoint::release_outgoinginterpolation() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TCurvePointInterpolation* temp = _impl_.outgoinginterpolation_;
  _impl_.outgoinginterpolation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TCurvePointInterpolation* TCurvePoint::unsafe_arena_release_outgoinginterpolation() {
  // @@protoc_insertion_point(field_release:TCurvePoint.outgoingInterpolation)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TCurvePointInterpolation* temp = _impl_.outgoinginterpolation_;
  _impl_.outgoinginterpolation_ = nullptr;
  return temp;
}
inline ::TCurvePointInterpolation* TCurvePoint::_internal_mutable_outgoinginterpolation() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.outgoinginterpolation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TCurvePointInterpolation>(GetArenaForAllocation());
    _impl_.outgoinginterpolation_ = p;
  }
  return _impl_.outgoinginterpolation_;
}
inline ::TCurvePointInterpolation* TCurvePoint::mutable_outgoinginterpolation() {
  ::TCurvePointInterpolation* _msg = _internal_mutable_outgoinginterpolation();
  // @@protoc_insertion_point(field_mutable:TCurvePoint.outgoingInterpolation)
  return _msg;
}
inline void TCurvePoint::set_allocated_outgoinginterpolation(::TCurvePointInterpolation* outgoinginterpolation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outgoinginterpolation_;
  }
  if (outgoinginterpolation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outgoinginterpolation);
    if (message_arena != submessage_arena) {
      outgoinginterpolation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outgoinginterpolation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.outgoinginterpolation_ = outgoinginterpolation;
  // @@protoc_insertion_point(field_set_allocated:TCurvePoint.outgoingInterpolation)
}

// -------------------------------------------------------------------

// TCurveDefinition

// required .TENumericType curveValueType = 1;
inline bool TCurveDefinition::_internal_has_curvevaluetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TCurveDefinition::has_curvevaluetype() const {
  return _internal_has_curvevaluetype();
}
inline void TCurveDefinition::clear_curvevaluetype() {
  _impl_.curvevaluetype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TENumericType TCurveDefinition::_internal_curvevaluetype() const {
  return static_cast< ::TENumericType >(_impl_.curvevaluetype_);
}
inline ::TENumericType TCurveDefinition::curvevaluetype() const {
  // @@protoc_insertion_point(field_get:TCurveDefinition.curveValueType)
  return _internal_curvevaluetype();
}
inline void TCurveDefinition::_internal_set_curvevaluetype(::TENumericType value) {
  assert(::TENumericType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.curvevaluetype_ = value;
}
inline void TCurveDefinition::set_curvevaluetype(::TENumericType value) {
  _internal_set_curvevaluetype(value);
  // @@protoc_insertion_point(field_set:TCurveDefinition.curveValueType)
}

// repeated .TCurvePoint point = 2;
inline int TCurveDefinition::_internal_point_size() const {
  return _impl_.point_.size();
}
inline int TCurveDefinition::point_size() const {
  return _internal_point_size();
}
inline void TCurveDefinition::clear_point() {
  _impl_.point_.Clear();
}
inline ::TCurvePoint* TCurveDefinition::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:TCurveDefinition.point)
  return _impl_.point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TCurvePoint >*
TCurveDefinition::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:TCurveDefinition.point)
  return &_impl_.point_;
}
inline const ::TCurvePoint& TCurveDefinition::_internal_point(int index) const {
  return _impl_.point_.Get(index);
}
inline const ::TCurvePoint& TCurveDefinition::point(int index) const {
  // @@protoc_insertion_point(field_get:TCurveDefinition.point)
  return _internal_point(index);
}
inline ::TCurvePoint* TCurveDefinition::_internal_add_point() {
  return _impl_.point_.Add();
}
inline ::TCurvePoint* TCurveDefinition::add_point() {
  ::TCurvePoint* _add = _internal_add_point();
  // @@protoc_insertion_point(field_add:TCurveDefinition.point)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TCurvePoint >&
TCurveDefinition::point() const {
  // @@protoc_insertion_point(field_list:TCurveDefinition.point)
  return _impl_.point_;
}

// -------------------------------------------------------------------

// TKeyFrame

// required int32 frame = 1;
inline bool TKeyFrame::_internal_has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TKeyFrame::has_frame() const {
  return _internal_has_frame();
}
inline void TKeyFrame::clear_frame() {
  _impl_.frame_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TKeyFrame::_internal_frame() const {
  return _impl_.frame_;
}
inline int32_t TKeyFrame::frame() const {
  // @@protoc_insertion_point(field_get:TKeyFrame.frame)
  return _internal_frame();
}
inline void TKeyFrame::_internal_set_frame(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.frame_ = value;
}
inline void TKeyFrame::set_frame(int32_t value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:TKeyFrame.frame)
}

// optional .TNumericValue value = 2;
inline bool TKeyFrame::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool TKeyFrame::has_value() const {
  return _internal_has_value();
}
inline void TKeyFrame::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TNumericValue& TKeyFrame::_internal_value() const {
  const ::TNumericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TNumericValue&>(
      ::_TNumericValue_default_instance_);
}
inline const ::TNumericValue& TKeyFrame::value() const {
  // @@protoc_insertion_point(field_get:TKeyFrame.value)
  return _internal_value();
}
inline void TKeyFrame::unsafe_arena_set_allocated_value(
    ::TNumericValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TKeyFrame.value)
}
inline ::TNumericValue* TKeyFrame::release_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TNumericValue* TKeyFrame::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:TKeyFrame.value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::TNumericValue* TKeyFrame::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TNumericValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::TNumericValue* TKeyFrame::mutable_value() {
  ::TNumericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TKeyFrame.value)
  return _msg;
}
inline void TKeyFrame::set_allocated_value(::TNumericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:TKeyFrame.value)
}

// -------------------------------------------------------------------

// TKeyFrameSequence

// optional float fps = 1;
inline bool TKeyFrameSequence::_internal_has_fps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TKeyFrameSequence::has_fps() const {
  return _internal_has_fps();
}
inline void TKeyFrameSequence::clear_fps() {
  _impl_.fps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float TKeyFrameSequence::_internal_fps() const {
  return _impl_.fps_;
}
inline float TKeyFrameSequence::fps() const {
  // @@protoc_insertion_point(field_get:TKeyFrameSequence.fps)
  return _internal_fps();
}
inline void TKeyFrameSequence::_internal_set_fps(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fps_ = value;
}
inline void TKeyFrameSequence::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:TKeyFrameSequence.fps)
}

// repeated .TKeyFrame keyFrame = 2;
inline int TKeyFrameSequence::_internal_keyframe_size() const {
  return _impl_.keyframe_.size();
}
inline int TKeyFrameSequence::keyframe_size() const {
  return _internal_keyframe_size();
}
inline void TKeyFrameSequence::clear_keyframe() {
  _impl_.keyframe_.Clear();
}
inline ::TKeyFrame* TKeyFrameSequence::mutable_keyframe(int index) {
  // @@protoc_insertion_point(field_mutable:TKeyFrameSequence.keyFrame)
  return _impl_.keyframe_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TKeyFrame >*
TKeyFrameSequence::mutable_keyframe() {
  // @@protoc_insertion_point(field_mutable_list:TKeyFrameSequence.keyFrame)
  return &_impl_.keyframe_;
}
inline const ::TKeyFrame& TKeyFrameSequence::_internal_keyframe(int index) const {
  return _impl_.keyframe_.Get(index);
}
inline const ::TKeyFrame& TKeyFrameSequence::keyframe(int index) const {
  // @@protoc_insertion_point(field_get:TKeyFrameSequence.keyFrame)
  return _internal_keyframe(index);
}
inline ::TKeyFrame* TKeyFrameSequence::_internal_add_keyframe() {
  return _impl_.keyframe_.Add();
}
inline ::TKeyFrame* TKeyFrameSequence::add_keyframe() {
  ::TKeyFrame* _add = _internal_add_keyframe();
  // @@protoc_insertion_point(field_add:TKeyFrameSequence.keyFrame)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TKeyFrame >&
TKeyFrameSequence::keyframe() const {
  // @@protoc_insertion_point(field_list:TKeyFrameSequence.keyFrame)
  return _impl_.keyframe_;
}

// required .TENumericType type = 3;
inline bool TKeyFrameSequence::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TKeyFrameSequence::has_type() const {
  return _internal_has_type();
}
inline void TKeyFrameSequence::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TENumericType TKeyFrameSequence::_internal_type() const {
  return static_cast< ::TENumericType >(_impl_.type_);
}
inline ::TENumericType TKeyFrameSequence::type() const {
  // @@protoc_insertion_point(field_get:TKeyFrameSequence.type)
  return _internal_type();
}
inline void TKeyFrameSequence::_internal_set_type(::TENumericType value) {
  assert(::TENumericType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void TKeyFrameSequence::set_type(::TENumericType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TKeyFrameSequence.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TENumericType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TENumericType>() {
  return ::TENumericType_descriptor();
}
template <> struct is_proto_enum< ::TCurvePointInterpolationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TCurvePointInterpolationType>() {
  return ::TCurvePointInterpolationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Numeric_2eproto
