// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Scenegraph.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Scenegraph_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Scenegraph_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Numeric.pb.h"
#include "Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Scenegraph_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Scenegraph_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Scenegraph_2eproto;
namespace HmiScenegraph {
class TAttributeMapping;
struct TAttributeMappingDefaultTypeInternal;
extern TAttributeMappingDefaultTypeInternal _TAttributeMapping_default_instance_;
class TBitmap;
struct TBitmapDefaultTypeInternal;
extern TBitmapDefaultTypeInternal _TBitmap_default_instance_;
class TBitmap_TCubeMap;
struct TBitmap_TCubeMapDefaultTypeInternal;
extern TBitmap_TCubeMapDefaultTypeInternal _TBitmap_TCubeMap_default_instance_;
class TBitmap_TCubeMapResource;
struct TBitmap_TCubeMapResourceDefaultTypeInternal;
extern TBitmap_TCubeMapResourceDefaultTypeInternal _TBitmap_TCubeMapResource_default_instance_;
class TBlendMode;
struct TBlendModeDefaultTypeInternal;
extern TBlendModeDefaultTypeInternal _TBlendMode_default_instance_;
class TBlitPass;
struct TBlitPassDefaultTypeInternal;
extern TBlitPassDefaultTypeInternal _TBlitPass_default_instance_;
class TBoundingVolume;
struct TBoundingVolumeDefaultTypeInternal;
extern TBoundingVolumeDefaultTypeInternal _TBoundingVolume_default_instance_;
class TBoundingVolume_TBoundingBox;
struct TBoundingVolume_TBoundingBoxDefaultTypeInternal;
extern TBoundingVolume_TBoundingBoxDefaultTypeInternal _TBoundingVolume_TBoundingBox_default_instance_;
class TBoundingVolume_TBoundingSphere;
struct TBoundingVolume_TBoundingSphereDefaultTypeInternal;
extern TBoundingVolume_TBoundingSphereDefaultTypeInternal _TBoundingVolume_TBoundingSphere_default_instance_;
class TCamera;
struct TCameraDefaultTypeInternal;
extern TCameraDefaultTypeInternal _TCamera_default_instance_;
class TClearMode;
struct TClearModeDefaultTypeInternal;
extern TClearModeDefaultTypeInternal _TClearMode_default_instance_;
class TDiscardFramebuffer;
struct TDiscardFramebufferDefaultTypeInternal;
extern TDiscardFramebufferDefaultTypeInternal _TDiscardFramebuffer_default_instance_;
class TGeometry;
struct TGeometryDefaultTypeInternal;
extern TGeometryDefaultTypeInternal _TGeometry_default_instance_;
class TGeometry_TAttributeParamteter;
struct TGeometry_TAttributeParamteterDefaultTypeInternal;
extern TGeometry_TAttributeParamteterDefaultTypeInternal _TGeometry_TAttributeParamteter_default_instance_;
class TMaterial;
struct TMaterialDefaultTypeInternal;
extern TMaterialDefaultTypeInternal _TMaterial_default_instance_;
class TMaterialLib;
struct TMaterialLibDefaultTypeInternal;
extern TMaterialLibDefaultTypeInternal _TMaterialLib_default_instance_;
class TMesh;
struct TMeshDefaultTypeInternal;
extern TMeshDefaultTypeInternal _TMesh_default_instance_;
class TMesh_TAttributeParamteter;
struct TMesh_TAttributeParamteterDefaultTypeInternal;
extern TMesh_TAttributeParamteterDefaultTypeInternal _TMesh_TAttributeParamteter_default_instance_;
class TNode;
struct TNodeDefaultTypeInternal;
extern TNodeDefaultTypeInternal _TNode_default_instance_;
class TNode_TRenderPassName;
struct TNode_TRenderPassNameDefaultTypeInternal;
extern TNode_TRenderPassNameDefaultTypeInternal _TNode_TRenderPassName_default_instance_;
class TRenderLayer;
struct TRenderLayerDefaultTypeInternal;
extern TRenderLayerDefaultTypeInternal _TRenderLayer_default_instance_;
class TRenderMode;
struct TRenderModeDefaultTypeInternal;
extern TRenderModeDefaultTypeInternal _TRenderMode_default_instance_;
class TRenderMode_TColorWrite;
struct TRenderMode_TColorWriteDefaultTypeInternal;
extern TRenderMode_TColorWriteDefaultTypeInternal _TRenderMode_TColorWrite_default_instance_;
class TRenderOrder;
struct TRenderOrderDefaultTypeInternal;
extern TRenderOrderDefaultTypeInternal _TRenderOrder_default_instance_;
class TRenderOrderBin;
struct TRenderOrderBinDefaultTypeInternal;
extern TRenderOrderBinDefaultTypeInternal _TRenderOrderBin_default_instance_;
class TRenderPass;
struct TRenderPassDefaultTypeInternal;
extern TRenderPassDefaultTypeInternal _TRenderPass_default_instance_;
class TRenderTarget;
struct TRenderTargetDefaultTypeInternal;
extern TRenderTargetDefaultTypeInternal _TRenderTarget_default_instance_;
class TResourceCacheId;
struct TResourceCacheIdDefaultTypeInternal;
extern TResourceCacheIdDefaultTypeInternal _TResourceCacheId_default_instance_;
class TScene;
struct TSceneDefaultTypeInternal;
extern TSceneDefaultTypeInternal _TScene_default_instance_;
class TScissorTest;
struct TScissorTestDefaultTypeInternal;
extern TScissorTestDefaultTypeInternal _TScissorTest_default_instance_;
class TShader;
struct TShaderDefaultTypeInternal;
extern TShaderDefaultTypeInternal _TShader_default_instance_;
class TStencilMode;
struct TStencilModeDefaultTypeInternal;
extern TStencilModeDefaultTypeInternal _TStencilMode_default_instance_;
class TTexture;
struct TTextureDefaultTypeInternal;
extern TTextureDefaultTypeInternal _TTexture_default_instance_;
class TUniform;
struct TUniformDefaultTypeInternal;
extern TUniformDefaultTypeInternal _TUniform_default_instance_;
}  // namespace HmiScenegraph
PROTOBUF_NAMESPACE_OPEN
template<> ::HmiScenegraph::TAttributeMapping* Arena::CreateMaybeMessage<::HmiScenegraph::TAttributeMapping>(Arena*);
template<> ::HmiScenegraph::TBitmap* Arena::CreateMaybeMessage<::HmiScenegraph::TBitmap>(Arena*);
template<> ::HmiScenegraph::TBitmap_TCubeMap* Arena::CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMap>(Arena*);
template<> ::HmiScenegraph::TBitmap_TCubeMapResource* Arena::CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(Arena*);
template<> ::HmiScenegraph::TBlendMode* Arena::CreateMaybeMessage<::HmiScenegraph::TBlendMode>(Arena*);
template<> ::HmiScenegraph::TBlitPass* Arena::CreateMaybeMessage<::HmiScenegraph::TBlitPass>(Arena*);
template<> ::HmiScenegraph::TBoundingVolume* Arena::CreateMaybeMessage<::HmiScenegraph::TBoundingVolume>(Arena*);
template<> ::HmiScenegraph::TBoundingVolume_TBoundingBox* Arena::CreateMaybeMessage<::HmiScenegraph::TBoundingVolume_TBoundingBox>(Arena*);
template<> ::HmiScenegraph::TBoundingVolume_TBoundingSphere* Arena::CreateMaybeMessage<::HmiScenegraph::TBoundingVolume_TBoundingSphere>(Arena*);
template<> ::HmiScenegraph::TCamera* Arena::CreateMaybeMessage<::HmiScenegraph::TCamera>(Arena*);
template<> ::HmiScenegraph::TClearMode* Arena::CreateMaybeMessage<::HmiScenegraph::TClearMode>(Arena*);
template<> ::HmiScenegraph::TDiscardFramebuffer* Arena::CreateMaybeMessage<::HmiScenegraph::TDiscardFramebuffer>(Arena*);
template<> ::HmiScenegraph::TGeometry* Arena::CreateMaybeMessage<::HmiScenegraph::TGeometry>(Arena*);
template<> ::HmiScenegraph::TGeometry_TAttributeParamteter* Arena::CreateMaybeMessage<::HmiScenegraph::TGeometry_TAttributeParamteter>(Arena*);
template<> ::HmiScenegraph::TMaterial* Arena::CreateMaybeMessage<::HmiScenegraph::TMaterial>(Arena*);
template<> ::HmiScenegraph::TMaterialLib* Arena::CreateMaybeMessage<::HmiScenegraph::TMaterialLib>(Arena*);
template<> ::HmiScenegraph::TMesh* Arena::CreateMaybeMessage<::HmiScenegraph::TMesh>(Arena*);
template<> ::HmiScenegraph::TMesh_TAttributeParamteter* Arena::CreateMaybeMessage<::HmiScenegraph::TMesh_TAttributeParamteter>(Arena*);
template<> ::HmiScenegraph::TNode* Arena::CreateMaybeMessage<::HmiScenegraph::TNode>(Arena*);
template<> ::HmiScenegraph::TNode_TRenderPassName* Arena::CreateMaybeMessage<::HmiScenegraph::TNode_TRenderPassName>(Arena*);
template<> ::HmiScenegraph::TRenderLayer* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderLayer>(Arena*);
template<> ::HmiScenegraph::TRenderMode* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderMode>(Arena*);
template<> ::HmiScenegraph::TRenderMode_TColorWrite* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderMode_TColorWrite>(Arena*);
template<> ::HmiScenegraph::TRenderOrder* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderOrder>(Arena*);
template<> ::HmiScenegraph::TRenderOrderBin* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderOrderBin>(Arena*);
template<> ::HmiScenegraph::TRenderPass* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderPass>(Arena*);
template<> ::HmiScenegraph::TRenderTarget* Arena::CreateMaybeMessage<::HmiScenegraph::TRenderTarget>(Arena*);
template<> ::HmiScenegraph::TResourceCacheId* Arena::CreateMaybeMessage<::HmiScenegraph::TResourceCacheId>(Arena*);
template<> ::HmiScenegraph::TScene* Arena::CreateMaybeMessage<::HmiScenegraph::TScene>(Arena*);
template<> ::HmiScenegraph::TScissorTest* Arena::CreateMaybeMessage<::HmiScenegraph::TScissorTest>(Arena*);
template<> ::HmiScenegraph::TShader* Arena::CreateMaybeMessage<::HmiScenegraph::TShader>(Arena*);
template<> ::HmiScenegraph::TStencilMode* Arena::CreateMaybeMessage<::HmiScenegraph::TStencilMode>(Arena*);
template<> ::HmiScenegraph::TTexture* Arena::CreateMaybeMessage<::HmiScenegraph::TTexture>(Arena*);
template<> ::HmiScenegraph::TUniform* Arena::CreateMaybeMessage<::HmiScenegraph::TUniform>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace HmiScenegraph {

enum TECameraProjectionType : int {
  TECameraProjectionType_Matrix = 0,
  TECameraProjectionType_FOV = 1,
  TECameraProjectionType_FocalLength = 2,
  TECameraProjectionType_Frustum = 3
};
bool TECameraProjectionType_IsValid(int value);
constexpr TECameraProjectionType TECameraProjectionType_MIN = TECameraProjectionType_Matrix;
constexpr TECameraProjectionType TECameraProjectionType_MAX = TECameraProjectionType_Frustum;
constexpr int TECameraProjectionType_ARRAYSIZE = TECameraProjectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TECameraProjectionType_descriptor();
template<typename T>
inline const std::string& TECameraProjectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TECameraProjectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TECameraProjectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TECameraProjectionType_descriptor(), enum_t_value);
}
inline bool TECameraProjectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TECameraProjectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TECameraProjectionType>(
    TECameraProjectionType_descriptor(), name, value);
}
enum TEAttributeUsage : int {
  TEAttributeUsage_Vertex = 0,
  TEAttributeUsage_TexCoord = 1,
  TEAttributeUsage_Normal = 2,
  TEAttributeUsage_Custom = 3
};
bool TEAttributeUsage_IsValid(int value);
constexpr TEAttributeUsage TEAttributeUsage_MIN = TEAttributeUsage_Vertex;
constexpr TEAttributeUsage TEAttributeUsage_MAX = TEAttributeUsage_Custom;
constexpr int TEAttributeUsage_ARRAYSIZE = TEAttributeUsage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeUsage_descriptor();
template<typename T>
inline const std::string& TEAttributeUsage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAttributeUsage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAttributeUsage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAttributeUsage_descriptor(), enum_t_value);
}
inline bool TEAttributeUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAttributeUsage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAttributeUsage>(
    TEAttributeUsage_descriptor(), name, value);
}
enum TEBitmapType : int {
  TEBitmapType_Resource = 0,
  TEBitmapType_Texture = 1,
  TEBitmapType_RenderBuffer = 2
};
bool TEBitmapType_IsValid(int value);
constexpr TEBitmapType TEBitmapType_MIN = TEBitmapType_Resource;
constexpr TEBitmapType TEBitmapType_MAX = TEBitmapType_RenderBuffer;
constexpr int TEBitmapType_ARRAYSIZE = TEBitmapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEBitmapType_descriptor();
template<typename T>
inline const std::string& TEBitmapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEBitmapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEBitmapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEBitmapType_descriptor(), enum_t_value);
}
inline bool TEBitmapType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEBitmapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEBitmapType>(
    TEBitmapType_descriptor(), name, value);
}
enum TESemanticValue : int {
  TESemanticValue_ScreenWidth = 0,
  TESemanticValue_ScreenHeight = 1,
  TESemanticValue_SplitscreenWidth = 2,
  TESemanticValue_SplitscreenHeight = 3
};
bool TESemanticValue_IsValid(int value);
constexpr TESemanticValue TESemanticValue_MIN = TESemanticValue_ScreenWidth;
constexpr TESemanticValue TESemanticValue_MAX = TESemanticValue_SplitscreenHeight;
constexpr int TESemanticValue_ARRAYSIZE = TESemanticValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TESemanticValue_descriptor();
template<typename T>
inline const std::string& TESemanticValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TESemanticValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TESemanticValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TESemanticValue_descriptor(), enum_t_value);
}
inline bool TESemanticValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TESemanticValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TESemanticValue>(
    TESemanticValue_descriptor(), name, value);
}
enum TERenderBufferAccessMode : int {
  TERenderBufferAccessMode_WriteOnly = 0,
  TERenderBufferAccessMode_ReadWrite = 1
};
bool TERenderBufferAccessMode_IsValid(int value);
constexpr TERenderBufferAccessMode TERenderBufferAccessMode_MIN = TERenderBufferAccessMode_WriteOnly;
constexpr TERenderBufferAccessMode TERenderBufferAccessMode_MAX = TERenderBufferAccessMode_ReadWrite;
constexpr int TERenderBufferAccessMode_ARRAYSIZE = TERenderBufferAccessMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TERenderBufferAccessMode_descriptor();
template<typename T>
inline const std::string& TERenderBufferAccessMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TERenderBufferAccessMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TERenderBufferAccessMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TERenderBufferAccessMode_descriptor(), enum_t_value);
}
inline bool TERenderBufferAccessMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TERenderBufferAccessMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TERenderBufferAccessMode>(
    TERenderBufferAccessMode_descriptor(), name, value);
}
enum TEPrimitiveType : int {
  TEPrimitiveType_Points = 0,
  TEPrimitiveType_Lines = 1,
  TEPrimitiveType_LineStrip = 2,
  TEPrimitiveType_LineLoop = 3,
  TEPrimitiveType_Triangles = 4,
  TEPrimitiveType_TriangleStrip = 5,
  TEPrimitiveType_TriangleFan = 6
};
bool TEPrimitiveType_IsValid(int value);
constexpr TEPrimitiveType TEPrimitiveType_MIN = TEPrimitiveType_Points;
constexpr TEPrimitiveType TEPrimitiveType_MAX = TEPrimitiveType_TriangleFan;
constexpr int TEPrimitiveType_ARRAYSIZE = TEPrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEPrimitiveType_descriptor();
template<typename T>
inline const std::string& TEPrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEPrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEPrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEPrimitiveType_descriptor(), enum_t_value);
}
inline bool TEPrimitiveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEPrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEPrimitiveType>(
    TEPrimitiveType_descriptor(), name, value);
}
enum TEIndexDataType : int {
  TEIndexDataType_UInt8 = 0,
  TEIndexDataType_UInt16 = 1,
  TEIndexDataType_UInt32 = 2,
  TEIndexDataType_UInt64 = 3
};
bool TEIndexDataType_IsValid(int value);
constexpr TEIndexDataType TEIndexDataType_MIN = TEIndexDataType_UInt8;
constexpr TEIndexDataType TEIndexDataType_MAX = TEIndexDataType_UInt64;
constexpr int TEIndexDataType_ARRAYSIZE = TEIndexDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEIndexDataType_descriptor();
template<typename T>
inline const std::string& TEIndexDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEIndexDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEIndexDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEIndexDataType_descriptor(), enum_t_value);
}
inline bool TEIndexDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEIndexDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEIndexDataType>(
    TEIndexDataType_descriptor(), name, value);
}
enum TEAttributePrecision : int {
  TEAttributePrecision_low = 0,
  TEAttributePrecision_medium = 1,
  TEAttributePrecision_high = 2
};
bool TEAttributePrecision_IsValid(int value);
constexpr TEAttributePrecision TEAttributePrecision_MIN = TEAttributePrecision_low;
constexpr TEAttributePrecision TEAttributePrecision_MAX = TEAttributePrecision_high;
constexpr int TEAttributePrecision_ARRAYSIZE = TEAttributePrecision_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributePrecision_descriptor();
template<typename T>
inline const std::string& TEAttributePrecision_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAttributePrecision>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAttributePrecision_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAttributePrecision_descriptor(), enum_t_value);
}
inline bool TEAttributePrecision_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAttributePrecision* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAttributePrecision>(
    TEAttributePrecision_descriptor(), name, value);
}
enum TEAttributeSize : int {
  TEAttributeSize_scalar = 1,
  TEAttributeSize_vec2 = 2,
  TEAttributeSize_vec3 = 3,
  TEAttributeSize_vec4 = 4
};
bool TEAttributeSize_IsValid(int value);
constexpr TEAttributeSize TEAttributeSize_MIN = TEAttributeSize_scalar;
constexpr TEAttributeSize TEAttributeSize_MAX = TEAttributeSize_vec4;
constexpr int TEAttributeSize_ARRAYSIZE = TEAttributeSize_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeSize_descriptor();
template<typename T>
inline const std::string& TEAttributeSize_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAttributeSize>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAttributeSize_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAttributeSize_descriptor(), enum_t_value);
}
inline bool TEAttributeSize_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAttributeSize* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAttributeSize>(
    TEAttributeSize_descriptor(), name, value);
}
enum TEAttributeSemantic : int {
  TEAttributeSemantic_Invalid = 1,
  TEAttributeSemantic_Position = 2,
  TEAttributeSemantic_Color = 3,
  TEAttributeSemantic_TextureCoordinate = 4,
  TEAttributeSemantic_Normal = 5,
  TEAttributeSemantic_Tangent = 6,
  TEAttributeSemantic_Bitangent = 7,
  TEAttributeSemantic_Custom = 8
};
bool TEAttributeSemantic_IsValid(int value);
constexpr TEAttributeSemantic TEAttributeSemantic_MIN = TEAttributeSemantic_Invalid;
constexpr TEAttributeSemantic TEAttributeSemantic_MAX = TEAttributeSemantic_Custom;
constexpr int TEAttributeSemantic_ARRAYSIZE = TEAttributeSemantic_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeSemantic_descriptor();
template<typename T>
inline const std::string& TEAttributeSemantic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAttributeSemantic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAttributeSemantic_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAttributeSemantic_descriptor(), enum_t_value);
}
inline bool TEAttributeSemantic_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAttributeSemantic* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAttributeSemantic>(
    TEAttributeSemantic_descriptor(), name, value);
}
enum TEAxis : int {
  TEAxis_X = 0,
  TEAxis_Y = 1,
  TEAxis_Z = 2,
  TEAxis_NegX = 3,
  TEAxis_NegY = 4,
  TEAxis_NegZ = 5
};
bool TEAxis_IsValid(int value);
constexpr TEAxis TEAxis_MIN = TEAxis_X;
constexpr TEAxis TEAxis_MAX = TEAxis_NegZ;
constexpr int TEAxis_ARRAYSIZE = TEAxis_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAxis_descriptor();
template<typename T>
inline const std::string& TEAxis_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TEAxis>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TEAxis_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TEAxis_descriptor(), enum_t_value);
}
inline bool TEAxis_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TEAxis* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TEAxis>(
    TEAxis_descriptor(), name, value);
}
enum TERenderBinSortOrder : int {
  TERenderBinSortOrder_ChildSortOrder = 0,
  TERenderBinSortOrder_InverseChildSortOrder = 1,
  TERenderBinSortOrder_RenderOrderRank = 2,
  TERenderBinSortOrder_InverseRenderOrderRank = 3,
  TERenderBinSortOrder_Undefined = 4
};
bool TERenderBinSortOrder_IsValid(int value);
constexpr TERenderBinSortOrder TERenderBinSortOrder_MIN = TERenderBinSortOrder_ChildSortOrder;
constexpr TERenderBinSortOrder TERenderBinSortOrder_MAX = TERenderBinSortOrder_Undefined;
constexpr int TERenderBinSortOrder_ARRAYSIZE = TERenderBinSortOrder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TERenderBinSortOrder_descriptor();
template<typename T>
inline const std::string& TERenderBinSortOrder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TERenderBinSortOrder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TERenderBinSortOrder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TERenderBinSortOrder_descriptor(), enum_t_value);
}
inline bool TERenderBinSortOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TERenderBinSortOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TERenderBinSortOrder>(
    TERenderBinSortOrder_descriptor(), name, value);
}
// ===================================================================

class TResourceCacheId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TResourceCacheId) */ {
 public:
  inline TResourceCacheId() : TResourceCacheId(nullptr) {}
  ~TResourceCacheId() override;
  explicit PROTOBUF_CONSTEXPR TResourceCacheId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TResourceCacheId(const TResourceCacheId& from);
  TResourceCacheId(TResourceCacheId&& from) noexcept
    : TResourceCacheId() {
    *this = ::std::move(from);
  }

  inline TResourceCacheId& operator=(const TResourceCacheId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TResourceCacheId& operator=(TResourceCacheId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TResourceCacheId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TResourceCacheId* internal_default_instance() {
    return reinterpret_cast<const TResourceCacheId*>(
               &_TResourceCacheId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TResourceCacheId& a, TResourceCacheId& b) {
    a.Swap(&b);
  }
  inline void Swap(TResourceCacheId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TResourceCacheId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TResourceCacheId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TResourceCacheId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TResourceCacheId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TResourceCacheId& from) {
    TResourceCacheId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TResourceCacheId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TResourceCacheId";
  }
  protected:
  explicit TResourceCacheId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowFieldNumber = 1,
    kHighFieldNumber = 2,
  };
  // optional uint64 low = 1;
  bool has_low() const;
  private:
  bool _internal_has_low() const;
  public:
  void clear_low();
  uint64_t low() const;
  void set_low(uint64_t value);
  private:
  uint64_t _internal_low() const;
  void _internal_set_low(uint64_t value);
  public:

  // optional uint64 high = 2;
  bool has_high() const;
  private:
  bool _internal_has_high() const;
  public:
  void clear_high();
  uint64_t high() const;
  void set_high(uint64_t value);
  private:
  uint64_t _internal_high() const;
  void _internal_set_high(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TResourceCacheId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t low_;
    uint64_t high_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TUniform final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TUniform) */ {
 public:
  inline TUniform() : TUniform(nullptr) {}
  ~TUniform() override;
  explicit PROTOBUF_CONSTEXPR TUniform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TUniform(const TUniform& from);
  TUniform(TUniform&& from) noexcept
    : TUniform() {
    *this = ::std::move(from);
  }

  inline TUniform& operator=(const TUniform& from) {
    CopyFrom(from);
    return *this;
  }
  inline TUniform& operator=(TUniform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TUniform& default_instance() {
    return *internal_default_instance();
  }
  static inline const TUniform* internal_default_instance() {
    return reinterpret_cast<const TUniform*>(
               &_TUniform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TUniform& a, TUniform& b) {
    a.Swap(&b);
  }
  inline void Swap(TUniform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TUniform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TUniform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TUniform>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TUniform& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TUniform& from) {
    TUniform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TUniform* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TUniform";
  }
  protected:
  explicit TUniform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .TNumericValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::TNumericValue& value() const;
  PROTOBUF_NODISCARD ::TNumericValue* release_value();
  ::TNumericValue* mutable_value();
  void set_allocated_value(::TNumericValue* value);
  private:
  const ::TNumericValue& _internal_value() const;
  ::TNumericValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::TNumericValue* value);
  ::TNumericValue* unsafe_arena_release_value();

  // required .TENumericType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TENumericType type() const;
  void set_type(::TENumericType value);
  private:
  ::TENumericType _internal_type() const;
  void _internal_set_type(::TENumericType value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TUniform)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TNumericValue* value_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TCamera final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TCamera) */ {
 public:
  inline TCamera() : TCamera(nullptr) {}
  ~TCamera() override;
  explicit PROTOBUF_CONSTEXPR TCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TCamera(const TCamera& from);
  TCamera(TCamera&& from) noexcept
    : TCamera() {
    *this = ::std::move(from);
  }

  inline TCamera& operator=(const TCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline TCamera& operator=(TCamera&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const TCamera* internal_default_instance() {
    return reinterpret_cast<const TCamera*>(
               &_TCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TCamera& a, TCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(TCamera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TCamera>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TCamera& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TCamera& from) {
    TCamera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TCamera* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TCamera";
  }
  protected:
  explicit TCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectionMatrixFieldNumber = 3,
    kRotationFieldNumber = 4,
    kTranslationFieldNumber = 5,
    kViewportFieldNumber = 16,
    kHorizontalFOVFieldNumber = 6,
    kAspectRatioFieldNumber = 7,
    kNearPlaneFieldNumber = 8,
    kFarPlaneFieldNumber = 9,
    kRightPlaneFieldNumber = 10,
    kLeftPlaneFieldNumber = 11,
    kTopPlaneFieldNumber = 12,
    kBottomPlaneFieldNumber = 13,
    kProjectionTypeFieldNumber = 14,
    kHorizontalFocalLengthFieldNumber = 15,
    kScopeFieldNumber = 17,
  };
  // optional .TMatrix4x4f projectionMatrix = 3;
  bool has_projectionmatrix() const;
  private:
  bool _internal_has_projectionmatrix() const;
  public:
  void clear_projectionmatrix();
  const ::TMatrix4x4f& projectionmatrix() const;
  PROTOBUF_NODISCARD ::TMatrix4x4f* release_projectionmatrix();
  ::TMatrix4x4f* mutable_projectionmatrix();
  void set_allocated_projectionmatrix(::TMatrix4x4f* projectionmatrix);
  private:
  const ::TMatrix4x4f& _internal_projectionmatrix() const;
  ::TMatrix4x4f* _internal_mutable_projectionmatrix();
  public:
  void unsafe_arena_set_allocated_projectionmatrix(
      ::TMatrix4x4f* projectionmatrix);
  ::TMatrix4x4f* unsafe_arena_release_projectionmatrix();

  // optional .TVector3f rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::TVector3f& rotation() const;
  PROTOBUF_NODISCARD ::TVector3f* release_rotation();
  ::TVector3f* mutable_rotation();
  void set_allocated_rotation(::TVector3f* rotation);
  private:
  const ::TVector3f& _internal_rotation() const;
  ::TVector3f* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::TVector3f* rotation);
  ::TVector3f* unsafe_arena_release_rotation();

  // optional .TVector3f translation = 5;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::TVector3f& translation() const;
  PROTOBUF_NODISCARD ::TVector3f* release_translation();
  ::TVector3f* mutable_translation();
  void set_allocated_translation(::TVector3f* translation);
  private:
  const ::TVector3f& _internal_translation() const;
  ::TVector3f* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::TVector3f* translation);
  ::TVector3f* unsafe_arena_release_translation();

  // optional .TVector4f viewport = 16;
  bool has_viewport() const;
  private:
  bool _internal_has_viewport() const;
  public:
  void clear_viewport();
  const ::TVector4f& viewport() const;
  PROTOBUF_NODISCARD ::TVector4f* release_viewport();
  ::TVector4f* mutable_viewport();
  void set_allocated_viewport(::TVector4f* viewport);
  private:
  const ::TVector4f& _internal_viewport() const;
  ::TVector4f* _internal_mutable_viewport();
  public:
  void unsafe_arena_set_allocated_viewport(
      ::TVector4f* viewport);
  ::TVector4f* unsafe_arena_release_viewport();

  // optional float horizontalFOV = 6;
  bool has_horizontalfov() const;
  private:
  bool _internal_has_horizontalfov() const;
  public:
  void clear_horizontalfov();
  float horizontalfov() const;
  void set_horizontalfov(float value);
  private:
  float _internal_horizontalfov() const;
  void _internal_set_horizontalfov(float value);
  public:

  // optional float aspectRatio = 7;
  bool has_aspectratio() const;
  private:
  bool _internal_has_aspectratio() const;
  public:
  void clear_aspectratio();
  float aspectratio() const;
  void set_aspectratio(float value);
  private:
  float _internal_aspectratio() const;
  void _internal_set_aspectratio(float value);
  public:

  // optional float nearPlane = 8;
  bool has_nearplane() const;
  private:
  bool _internal_has_nearplane() const;
  public:
  void clear_nearplane();
  float nearplane() const;
  void set_nearplane(float value);
  private:
  float _internal_nearplane() const;
  void _internal_set_nearplane(float value);
  public:

  // optional float farPlane = 9;
  bool has_farplane() const;
  private:
  bool _internal_has_farplane() const;
  public:
  void clear_farplane();
  float farplane() const;
  void set_farplane(float value);
  private:
  float _internal_farplane() const;
  void _internal_set_farplane(float value);
  public:

  // optional float rightPlane = 10;
  bool has_rightplane() const;
  private:
  bool _internal_has_rightplane() const;
  public:
  void clear_rightplane();
  float rightplane() const;
  void set_rightplane(float value);
  private:
  float _internal_rightplane() const;
  void _internal_set_rightplane(float value);
  public:

  // optional float leftPlane = 11;
  bool has_leftplane() const;
  private:
  bool _internal_has_leftplane() const;
  public:
  void clear_leftplane();
  float leftplane() const;
  void set_leftplane(float value);
  private:
  float _internal_leftplane() const;
  void _internal_set_leftplane(float value);
  public:

  // optional float topPlane = 12;
  bool has_topplane() const;
  private:
  bool _internal_has_topplane() const;
  public:
  void clear_topplane();
  float topplane() const;
  void set_topplane(float value);
  private:
  float _internal_topplane() const;
  void _internal_set_topplane(float value);
  public:

  // optional float bottomPlane = 13;
  bool has_bottomplane() const;
  private:
  bool _internal_has_bottomplane() const;
  public:
  void clear_bottomplane();
  float bottomplane() const;
  void set_bottomplane(float value);
  private:
  float _internal_bottomplane() const;
  void _internal_set_bottomplane(float value);
  public:

  // optional .HmiScenegraph.TECameraProjectionType projectionType = 14;
  bool has_projectiontype() const;
  private:
  bool _internal_has_projectiontype() const;
  public:
  void clear_projectiontype();
  ::HmiScenegraph::TECameraProjectionType projectiontype() const;
  void set_projectiontype(::HmiScenegraph::TECameraProjectionType value);
  private:
  ::HmiScenegraph::TECameraProjectionType _internal_projectiontype() const;
  void _internal_set_projectiontype(::HmiScenegraph::TECameraProjectionType value);
  public:

  // optional float horizontalFocalLength = 15;
  bool has_horizontalfocallength() const;
  private:
  bool _internal_has_horizontalfocallength() const;
  public:
  void clear_horizontalfocallength();
  float horizontalfocallength() const;
  void set_horizontalfocallength(float value);
  private:
  float _internal_horizontalfocallength() const;
  void _internal_set_horizontalfocallength(float value);
  public:

  // optional .TEScope scope = 17 [default = TEScope_Scene];
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TCamera)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TMatrix4x4f* projectionmatrix_;
    ::TVector3f* rotation_;
    ::TVector3f* translation_;
    ::TVector4f* viewport_;
    float horizontalfov_;
    float aspectratio_;
    float nearplane_;
    float farplane_;
    float rightplane_;
    float leftplane_;
    float topplane_;
    float bottomplane_;
    int projectiontype_;
    float horizontalfocallength_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBlendMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBlendMode) */ {
 public:
  inline TBlendMode() : TBlendMode(nullptr) {}
  ~TBlendMode() override;
  explicit PROTOBUF_CONSTEXPR TBlendMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBlendMode(const TBlendMode& from);
  TBlendMode(TBlendMode&& from) noexcept
    : TBlendMode() {
    *this = ::std::move(from);
  }

  inline TBlendMode& operator=(const TBlendMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBlendMode& operator=(TBlendMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBlendMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBlendMode* internal_default_instance() {
    return reinterpret_cast<const TBlendMode*>(
               &_TBlendMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TBlendMode& a, TBlendMode& b) {
    a.Swap(&b);
  }
  inline void Swap(TBlendMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBlendMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBlendMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBlendMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBlendMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBlendMode& from) {
    TBlendMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBlendMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBlendMode";
  }
  protected:
  explicit TBlendMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlendOperationColorFieldNumber = 1,
    kBlendOperationAlphaFieldNumber = 2,
    kSourceColorFactorFieldNumber = 3,
    kSourceAlphaFactorFieldNumber = 4,
    kDestinationColorFactorFieldNumber = 5,
    kDestinationAlphaFactorFieldNumber = 6,
  };
  // required .TEBlendOperation blendOperationColor = 1;
  bool has_blendoperationcolor() const;
  private:
  bool _internal_has_blendoperationcolor() const;
  public:
  void clear_blendoperationcolor();
  ::TEBlendOperation blendoperationcolor() const;
  void set_blendoperationcolor(::TEBlendOperation value);
  private:
  ::TEBlendOperation _internal_blendoperationcolor() const;
  void _internal_set_blendoperationcolor(::TEBlendOperation value);
  public:

  // required .TEBlendOperation blendOperationAlpha = 2;
  bool has_blendoperationalpha() const;
  private:
  bool _internal_has_blendoperationalpha() const;
  public:
  void clear_blendoperationalpha();
  ::TEBlendOperation blendoperationalpha() const;
  void set_blendoperationalpha(::TEBlendOperation value);
  private:
  ::TEBlendOperation _internal_blendoperationalpha() const;
  void _internal_set_blendoperationalpha(::TEBlendOperation value);
  public:

  // optional .TEBlendFactor sourceColorFactor = 3;
  bool has_sourcecolorfactor() const;
  private:
  bool _internal_has_sourcecolorfactor() const;
  public:
  void clear_sourcecolorfactor();
  ::TEBlendFactor sourcecolorfactor() const;
  void set_sourcecolorfactor(::TEBlendFactor value);
  private:
  ::TEBlendFactor _internal_sourcecolorfactor() const;
  void _internal_set_sourcecolorfactor(::TEBlendFactor value);
  public:

  // optional .TEBlendFactor sourceAlphaFactor = 4;
  bool has_sourcealphafactor() const;
  private:
  bool _internal_has_sourcealphafactor() const;
  public:
  void clear_sourcealphafactor();
  ::TEBlendFactor sourcealphafactor() const;
  void set_sourcealphafactor(::TEBlendFactor value);
  private:
  ::TEBlendFactor _internal_sourcealphafactor() const;
  void _internal_set_sourcealphafactor(::TEBlendFactor value);
  public:

  // optional .TEBlendFactor destinationColorFactor = 5;
  bool has_destinationcolorfactor() const;
  private:
  bool _internal_has_destinationcolorfactor() const;
  public:
  void clear_destinationcolorfactor();
  ::TEBlendFactor destinationcolorfactor() const;
  void set_destinationcolorfactor(::TEBlendFactor value);
  private:
  ::TEBlendFactor _internal_destinationcolorfactor() const;
  void _internal_set_destinationcolorfactor(::TEBlendFactor value);
  public:

  // optional .TEBlendFactor destinationAlphaFactor = 6;
  bool has_destinationalphafactor() const;
  private:
  bool _internal_has_destinationalphafactor() const;
  public:
  void clear_destinationalphafactor();
  ::TEBlendFactor destinationalphafactor() const;
  void set_destinationalphafactor(::TEBlendFactor value);
  private:
  ::TEBlendFactor _internal_destinationalphafactor() const;
  void _internal_set_destinationalphafactor(::TEBlendFactor value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBlendMode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int blendoperationcolor_;
    int blendoperationalpha_;
    int sourcecolorfactor_;
    int sourcealphafactor_;
    int destinationcolorfactor_;
    int destinationalphafactor_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TStencilMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TStencilMode) */ {
 public:
  inline TStencilMode() : TStencilMode(nullptr) {}
  ~TStencilMode() override;
  explicit PROTOBUF_CONSTEXPR TStencilMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TStencilMode(const TStencilMode& from);
  TStencilMode(TStencilMode&& from) noexcept
    : TStencilMode() {
    *this = ::std::move(from);
  }

  inline TStencilMode& operator=(const TStencilMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TStencilMode& operator=(TStencilMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TStencilMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TStencilMode* internal_default_instance() {
    return reinterpret_cast<const TStencilMode*>(
               &_TStencilMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TStencilMode& a, TStencilMode& b) {
    a.Swap(&b);
  }
  inline void Swap(TStencilMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TStencilMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TStencilMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TStencilMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TStencilMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TStencilMode& from) {
    TStencilMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TStencilMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TStencilMode";
  }
  protected:
  explicit TStencilMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceValueFieldNumber = 2,
    kMaskFieldNumber = 3,
    kOperationFieldNumber = 1,
    kStencilFailFieldNumber = 4,
    kDepthFailFieldNumber = 5,
    kPassFieldNumber = 6,
  };
  // required int32 referenceValue = 2;
  bool has_referencevalue() const;
  private:
  bool _internal_has_referencevalue() const;
  public:
  void clear_referencevalue();
  int32_t referencevalue() const;
  void set_referencevalue(int32_t value);
  private:
  int32_t _internal_referencevalue() const;
  void _internal_set_referencevalue(int32_t value);
  public:

  // required fixed32 mask = 3;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  uint32_t mask() const;
  void set_mask(uint32_t value);
  private:
  uint32_t _internal_mask() const;
  void _internal_set_mask(uint32_t value);
  public:

  // required .TEStencilOperation operation = 1;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  ::TEStencilOperation operation() const;
  void set_operation(::TEStencilOperation value);
  private:
  ::TEStencilOperation _internal_operation() const;
  void _internal_set_operation(::TEStencilOperation value);
  public:

  // required .TEStencilOperation stencilFail = 4;
  bool has_stencilfail() const;
  private:
  bool _internal_has_stencilfail() const;
  public:
  void clear_stencilfail();
  ::TEStencilOperation stencilfail() const;
  void set_stencilfail(::TEStencilOperation value);
  private:
  ::TEStencilOperation _internal_stencilfail() const;
  void _internal_set_stencilfail(::TEStencilOperation value);
  public:

  // required .TEStencilOperation depthFail = 5;
  bool has_depthfail() const;
  private:
  bool _internal_has_depthfail() const;
  public:
  void clear_depthfail();
  ::TEStencilOperation depthfail() const;
  void set_depthfail(::TEStencilOperation value);
  private:
  ::TEStencilOperation _internal_depthfail() const;
  void _internal_set_depthfail(::TEStencilOperation value);
  public:

  // required .TEStencilOperation pass = 6;
  bool has_pass() const;
  private:
  bool _internal_has_pass() const;
  public:
  void clear_pass();
  ::TEStencilOperation pass() const;
  void set_pass(::TEStencilOperation value);
  private:
  ::TEStencilOperation _internal_pass() const;
  void _internal_set_pass(::TEStencilOperation value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TStencilMode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t referencevalue_;
    uint32_t mask_;
    int operation_;
    int stencilfail_;
    int depthfail_;
    int pass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TScissorTest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TScissorTest) */ {
 public:
  inline TScissorTest() : TScissorTest(nullptr) {}
  ~TScissorTest() override;
  explicit PROTOBUF_CONSTEXPR TScissorTest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TScissorTest(const TScissorTest& from);
  TScissorTest(TScissorTest&& from) noexcept
    : TScissorTest() {
    *this = ::std::move(from);
  }

  inline TScissorTest& operator=(const TScissorTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TScissorTest& operator=(TScissorTest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TScissorTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TScissorTest* internal_default_instance() {
    return reinterpret_cast<const TScissorTest*>(
               &_TScissorTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TScissorTest& a, TScissorTest& b) {
    a.Swap(&b);
  }
  inline void Swap(TScissorTest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TScissorTest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TScissorTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TScissorTest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TScissorTest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TScissorTest& from) {
    TScissorTest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TScissorTest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TScissorTest";
  }
  protected:
  explicit TScissorTest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kHeightFieldNumber = 3,
    kWidthFieldNumber = 4,
  };
  // required int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // required int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // required int32 height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // required int32 width = 4;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TScissorTest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
    int32_t height_;
    int32_t width_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderMode_TColorWrite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderMode.TColorWrite) */ {
 public:
  inline TRenderMode_TColorWrite() : TRenderMode_TColorWrite(nullptr) {}
  ~TRenderMode_TColorWrite() override;
  explicit PROTOBUF_CONSTEXPR TRenderMode_TColorWrite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderMode_TColorWrite(const TRenderMode_TColorWrite& from);
  TRenderMode_TColorWrite(TRenderMode_TColorWrite&& from) noexcept
    : TRenderMode_TColorWrite() {
    *this = ::std::move(from);
  }

  inline TRenderMode_TColorWrite& operator=(const TRenderMode_TColorWrite& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderMode_TColorWrite& operator=(TRenderMode_TColorWrite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderMode_TColorWrite& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderMode_TColorWrite* internal_default_instance() {
    return reinterpret_cast<const TRenderMode_TColorWrite*>(
               &_TRenderMode_TColorWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TRenderMode_TColorWrite& a, TRenderMode_TColorWrite& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderMode_TColorWrite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderMode_TColorWrite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderMode_TColorWrite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderMode_TColorWrite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderMode_TColorWrite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderMode_TColorWrite& from) {
    TRenderMode_TColorWrite::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderMode_TColorWrite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderMode.TColorWrite";
  }
  protected:
  explicit TRenderMode_TColorWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
    kAlphaFieldNumber = 4,
  };
  // optional bool red = 1 [default = true];
  bool has_red() const;
  private:
  bool _internal_has_red() const;
  public:
  void clear_red();
  bool red() const;
  void set_red(bool value);
  private:
  bool _internal_red() const;
  void _internal_set_red(bool value);
  public:

  // optional bool green = 2 [default = true];
  bool has_green() const;
  private:
  bool _internal_has_green() const;
  public:
  void clear_green();
  bool green() const;
  void set_green(bool value);
  private:
  bool _internal_green() const;
  void _internal_set_green(bool value);
  public:

  // optional bool blue = 3 [default = true];
  bool has_blue() const;
  private:
  bool _internal_has_blue() const;
  public:
  void clear_blue();
  bool blue() const;
  void set_blue(bool value);
  private:
  bool _internal_blue() const;
  void _internal_set_blue(bool value);
  public:

  // optional bool alpha = 4 [default = true];
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  bool alpha() const;
  void set_alpha(bool value);
  private:
  bool _internal_alpha() const;
  void _internal_set_alpha(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderMode.TColorWrite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool red_;
    bool green_;
    bool blue_;
    bool alpha_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderMode) */ {
 public:
  inline TRenderMode() : TRenderMode(nullptr) {}
  ~TRenderMode() override;
  explicit PROTOBUF_CONSTEXPR TRenderMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderMode(const TRenderMode& from);
  TRenderMode(TRenderMode&& from) noexcept
    : TRenderMode() {
    *this = ::std::move(from);
  }

  inline TRenderMode& operator=(const TRenderMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderMode& operator=(TRenderMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderMode* internal_default_instance() {
    return reinterpret_cast<const TRenderMode*>(
               &_TRenderMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TRenderMode& a, TRenderMode& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderMode& from) {
    TRenderMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderMode";
  }
  protected:
  explicit TRenderMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TRenderMode_TColorWrite TColorWrite;

  // accessors -------------------------------------------------------

  enum : int {
    kBlendingFieldNumber = 3,
    kStencilFrontFaceFieldNumber = 7,
    kStencilBackFaceFieldNumber = 8,
    kScissorTestFieldNumber = 9,
    kColorWriteFieldNumber = 10,
    kBlendColorFieldNumber = 4,
    kDepthWriteFieldNumber = 6,
    kDepthCompareFieldNumber = 5,
    kWindingFieldNumber = 1,
    kCullingFieldNumber = 2,
  };
  // required .HmiScenegraph.TBlendMode blending = 3;
  bool has_blending() const;
  private:
  bool _internal_has_blending() const;
  public:
  void clear_blending();
  const ::HmiScenegraph::TBlendMode& blending() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBlendMode* release_blending();
  ::HmiScenegraph::TBlendMode* mutable_blending();
  void set_allocated_blending(::HmiScenegraph::TBlendMode* blending);
  private:
  const ::HmiScenegraph::TBlendMode& _internal_blending() const;
  ::HmiScenegraph::TBlendMode* _internal_mutable_blending();
  public:
  void unsafe_arena_set_allocated_blending(
      ::HmiScenegraph::TBlendMode* blending);
  ::HmiScenegraph::TBlendMode* unsafe_arena_release_blending();

  // optional .HmiScenegraph.TStencilMode stencilFrontFace = 7;
  bool has_stencilfrontface() const;
  private:
  bool _internal_has_stencilfrontface() const;
  public:
  void clear_stencilfrontface();
  const ::HmiScenegraph::TStencilMode& stencilfrontface() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TStencilMode* release_stencilfrontface();
  ::HmiScenegraph::TStencilMode* mutable_stencilfrontface();
  void set_allocated_stencilfrontface(::HmiScenegraph::TStencilMode* stencilfrontface);
  private:
  const ::HmiScenegraph::TStencilMode& _internal_stencilfrontface() const;
  ::HmiScenegraph::TStencilMode* _internal_mutable_stencilfrontface();
  public:
  void unsafe_arena_set_allocated_stencilfrontface(
      ::HmiScenegraph::TStencilMode* stencilfrontface);
  ::HmiScenegraph::TStencilMode* unsafe_arena_release_stencilfrontface();

  // optional .HmiScenegraph.TStencilMode stencilBackFace = 8;
  bool has_stencilbackface() const;
  private:
  bool _internal_has_stencilbackface() const;
  public:
  void clear_stencilbackface();
  const ::HmiScenegraph::TStencilMode& stencilbackface() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TStencilMode* release_stencilbackface();
  ::HmiScenegraph::TStencilMode* mutable_stencilbackface();
  void set_allocated_stencilbackface(::HmiScenegraph::TStencilMode* stencilbackface);
  private:
  const ::HmiScenegraph::TStencilMode& _internal_stencilbackface() const;
  ::HmiScenegraph::TStencilMode* _internal_mutable_stencilbackface();
  public:
  void unsafe_arena_set_allocated_stencilbackface(
      ::HmiScenegraph::TStencilMode* stencilbackface);
  ::HmiScenegraph::TStencilMode* unsafe_arena_release_stencilbackface();

  // optional .HmiScenegraph.TScissorTest scissorTest = 9;
  bool has_scissortest() const;
  private:
  bool _internal_has_scissortest() const;
  public:
  void clear_scissortest();
  const ::HmiScenegraph::TScissorTest& scissortest() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TScissorTest* release_scissortest();
  ::HmiScenegraph::TScissorTest* mutable_scissortest();
  void set_allocated_scissortest(::HmiScenegraph::TScissorTest* scissortest);
  private:
  const ::HmiScenegraph::TScissorTest& _internal_scissortest() const;
  ::HmiScenegraph::TScissorTest* _internal_mutable_scissortest();
  public:
  void unsafe_arena_set_allocated_scissortest(
      ::HmiScenegraph::TScissorTest* scissortest);
  ::HmiScenegraph::TScissorTest* unsafe_arena_release_scissortest();

  // optional .HmiScenegraph.TRenderMode.TColorWrite colorWrite = 10;
  bool has_colorwrite() const;
  private:
  bool _internal_has_colorwrite() const;
  public:
  void clear_colorwrite();
  const ::HmiScenegraph::TRenderMode_TColorWrite& colorwrite() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TRenderMode_TColorWrite* release_colorwrite();
  ::HmiScenegraph::TRenderMode_TColorWrite* mutable_colorwrite();
  void set_allocated_colorwrite(::HmiScenegraph::TRenderMode_TColorWrite* colorwrite);
  private:
  const ::HmiScenegraph::TRenderMode_TColorWrite& _internal_colorwrite() const;
  ::HmiScenegraph::TRenderMode_TColorWrite* _internal_mutable_colorwrite();
  public:
  void unsafe_arena_set_allocated_colorwrite(
      ::HmiScenegraph::TRenderMode_TColorWrite* colorwrite);
  ::HmiScenegraph::TRenderMode_TColorWrite* unsafe_arena_release_colorwrite();

  // optional fixed32 blendColor = 4;
  bool has_blendcolor() const;
  private:
  bool _internal_has_blendcolor() const;
  public:
  void clear_blendcolor();
  uint32_t blendcolor() const;
  void set_blendcolor(uint32_t value);
  private:
  uint32_t _internal_blendcolor() const;
  void _internal_set_blendcolor(uint32_t value);
  public:

  // optional bool depthWrite = 6;
  bool has_depthwrite() const;
  private:
  bool _internal_has_depthwrite() const;
  public:
  void clear_depthwrite();
  bool depthwrite() const;
  void set_depthwrite(bool value);
  private:
  bool _internal_depthwrite() const;
  void _internal_set_depthwrite(bool value);
  public:

  // required .TECompareFunction depthCompare = 5;
  bool has_depthcompare() const;
  private:
  bool _internal_has_depthcompare() const;
  public:
  void clear_depthcompare();
  ::TECompareFunction depthcompare() const;
  void set_depthcompare(::TECompareFunction value);
  private:
  ::TECompareFunction _internal_depthcompare() const;
  void _internal_set_depthcompare(::TECompareFunction value);
  public:

  // required .TEWinding winding = 1;
  bool has_winding() const;
  private:
  bool _internal_has_winding() const;
  public:
  void clear_winding();
  ::TEWinding winding() const;
  void set_winding(::TEWinding value);
  private:
  ::TEWinding _internal_winding() const;
  void _internal_set_winding(::TEWinding value);
  public:

  // required .TEFace culling = 2;
  bool has_culling() const;
  private:
  bool _internal_has_culling() const;
  public:
  void clear_culling();
  ::TEFace culling() const;
  void set_culling(::TEFace value);
  private:
  ::TEFace _internal_culling() const;
  void _internal_set_culling(::TEFace value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderMode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::HmiScenegraph::TBlendMode* blending_;
    ::HmiScenegraph::TStencilMode* stencilfrontface_;
    ::HmiScenegraph::TStencilMode* stencilbackface_;
    ::HmiScenegraph::TScissorTest* scissortest_;
    ::HmiScenegraph::TRenderMode_TColorWrite* colorwrite_;
    uint32_t blendcolor_;
    bool depthwrite_;
    int depthcompare_;
    int winding_;
    int culling_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TAttributeMapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TAttributeMapping) */ {
 public:
  inline TAttributeMapping() : TAttributeMapping(nullptr) {}
  ~TAttributeMapping() override;
  explicit PROTOBUF_CONSTEXPR TAttributeMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TAttributeMapping(const TAttributeMapping& from);
  TAttributeMapping(TAttributeMapping&& from) noexcept
    : TAttributeMapping() {
    *this = ::std::move(from);
  }

  inline TAttributeMapping& operator=(const TAttributeMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline TAttributeMapping& operator=(TAttributeMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TAttributeMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const TAttributeMapping* internal_default_instance() {
    return reinterpret_cast<const TAttributeMapping*>(
               &_TAttributeMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TAttributeMapping& a, TAttributeMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(TAttributeMapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TAttributeMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TAttributeMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TAttributeMapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TAttributeMapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TAttributeMapping& from) {
    TAttributeMapping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TAttributeMapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TAttributeMapping";
  }
  protected:
  explicit TAttributeMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeNameFieldNumber = 3,
    kUsageFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // required string attributeName = 3;
  bool has_attributename() const;
  private:
  bool _internal_has_attributename() const;
  public:
  void clear_attributename();
  const std::string& attributename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributename();
  PROTOBUF_NODISCARD std::string* release_attributename();
  void set_allocated_attributename(std::string* attributename);
  private:
  const std::string& _internal_attributename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributename(const std::string& value);
  std::string* _internal_mutable_attributename();
  public:

  // required .HmiScenegraph.TEAttributeUsage usage = 1;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  ::HmiScenegraph::TEAttributeUsage usage() const;
  void set_usage(::HmiScenegraph::TEAttributeUsage value);
  private:
  ::HmiScenegraph::TEAttributeUsage _internal_usage() const;
  void _internal_set_usage(::HmiScenegraph::TEAttributeUsage value);
  public:

  // optional uint32 index = 2;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TAttributeMapping)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributename_;
    int usage_;
    uint32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TShader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TShader) */ {
 public:
  inline TShader() : TShader(nullptr) {}
  ~TShader() override;
  explicit PROTOBUF_CONSTEXPR TShader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TShader(const TShader& from);
  TShader(TShader&& from) noexcept
    : TShader() {
    *this = ::std::move(from);
  }

  inline TShader& operator=(const TShader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TShader& operator=(TShader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TShader& default_instance() {
    return *internal_default_instance();
  }
  static inline const TShader* internal_default_instance() {
    return reinterpret_cast<const TShader*>(
               &_TShader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TShader& a, TShader& b) {
    a.Swap(&b);
  }
  inline void Swap(TShader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TShader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TShader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TShader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TShader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TShader& from) {
    TShader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TShader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TShader";
  }
  protected:
  explicit TShader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMappingFieldNumber = 4,
    kCompilerDefineFieldNumber = 5,
    kNameFieldNumber = 1,
    kVertexShaderFieldNumber = 2,
    kFragmentShaderFieldNumber = 3,
    kCacheIdFieldNumber = 7,
    kScopeFieldNumber = 6,
  };
  // repeated .HmiScenegraph.TAttributeMapping mapping = 4;
  int mapping_size() const;
  private:
  int _internal_mapping_size() const;
  public:
  void clear_mapping();
  ::HmiScenegraph::TAttributeMapping* mutable_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TAttributeMapping >*
      mutable_mapping();
  private:
  const ::HmiScenegraph::TAttributeMapping& _internal_mapping(int index) const;
  ::HmiScenegraph::TAttributeMapping* _internal_add_mapping();
  public:
  const ::HmiScenegraph::TAttributeMapping& mapping(int index) const;
  ::HmiScenegraph::TAttributeMapping* add_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TAttributeMapping >&
      mapping() const;

  // repeated string compilerDefine = 5;
  int compilerdefine_size() const;
  private:
  int _internal_compilerdefine_size() const;
  public:
  void clear_compilerdefine();
  const std::string& compilerdefine(int index) const;
  std::string* mutable_compilerdefine(int index);
  void set_compilerdefine(int index, const std::string& value);
  void set_compilerdefine(int index, std::string&& value);
  void set_compilerdefine(int index, const char* value);
  void set_compilerdefine(int index, const char* value, size_t size);
  std::string* add_compilerdefine();
  void add_compilerdefine(const std::string& value);
  void add_compilerdefine(std::string&& value);
  void add_compilerdefine(const char* value);
  void add_compilerdefine(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& compilerdefine() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_compilerdefine();
  private:
  const std::string& _internal_compilerdefine(int index) const;
  std::string* _internal_add_compilerdefine();
  public:

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string vertexShader = 2;
  bool has_vertexshader() const;
  private:
  bool _internal_has_vertexshader() const;
  public:
  void clear_vertexshader();
  const std::string& vertexshader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vertexshader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vertexshader();
  PROTOBUF_NODISCARD std::string* release_vertexshader();
  void set_allocated_vertexshader(std::string* vertexshader);
  private:
  const std::string& _internal_vertexshader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vertexshader(const std::string& value);
  std::string* _internal_mutable_vertexshader();
  public:

  // required string fragmentShader = 3;
  bool has_fragmentshader() const;
  private:
  bool _internal_has_fragmentshader() const;
  public:
  void clear_fragmentshader();
  const std::string& fragmentshader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragmentshader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragmentshader();
  PROTOBUF_NODISCARD std::string* release_fragmentshader();
  void set_allocated_fragmentshader(std::string* fragmentshader);
  private:
  const std::string& _internal_fragmentshader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragmentshader(const std::string& value);
  std::string* _internal_mutable_fragmentshader();
  public:

  // optional .HmiScenegraph.TResourceCacheId cacheId = 7;
  bool has_cacheid() const;
  private:
  bool _internal_has_cacheid() const;
  public:
  void clear_cacheid();
  const ::HmiScenegraph::TResourceCacheId& cacheid() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TResourceCacheId* release_cacheid();
  ::HmiScenegraph::TResourceCacheId* mutable_cacheid();
  void set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid);
  private:
  const ::HmiScenegraph::TResourceCacheId& _internal_cacheid() const;
  ::HmiScenegraph::TResourceCacheId* _internal_mutable_cacheid();
  public:
  void unsafe_arena_set_allocated_cacheid(
      ::HmiScenegraph::TResourceCacheId* cacheid);
  ::HmiScenegraph::TResourceCacheId* unsafe_arena_release_cacheid();

  // optional .TEScope scope = 6;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TShader)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TAttributeMapping > mapping_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> compilerdefine_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vertexshader_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragmentshader_;
    ::HmiScenegraph::TResourceCacheId* cacheid_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBitmap_TCubeMapResource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBitmap.TCubeMapResource) */ {
 public:
  inline TBitmap_TCubeMapResource() : TBitmap_TCubeMapResource(nullptr) {}
  ~TBitmap_TCubeMapResource() override;
  explicit PROTOBUF_CONSTEXPR TBitmap_TCubeMapResource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBitmap_TCubeMapResource(const TBitmap_TCubeMapResource& from);
  TBitmap_TCubeMapResource(TBitmap_TCubeMapResource&& from) noexcept
    : TBitmap_TCubeMapResource() {
    *this = ::std::move(from);
  }

  inline TBitmap_TCubeMapResource& operator=(const TBitmap_TCubeMapResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBitmap_TCubeMapResource& operator=(TBitmap_TCubeMapResource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBitmap_TCubeMapResource& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBitmap_TCubeMapResource* internal_default_instance() {
    return reinterpret_cast<const TBitmap_TCubeMapResource*>(
               &_TBitmap_TCubeMapResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TBitmap_TCubeMapResource& a, TBitmap_TCubeMapResource& b) {
    a.Swap(&b);
  }
  inline void Swap(TBitmap_TCubeMapResource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBitmap_TCubeMapResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBitmap_TCubeMapResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBitmap_TCubeMapResource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBitmap_TCubeMapResource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBitmap_TCubeMapResource& from) {
    TBitmap_TCubeMapResource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBitmap_TCubeMapResource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBitmap.TCubeMapResource";
  }
  protected:
  explicit TBitmap_TCubeMapResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMipmapFieldNumber = 2,
    kResourceFieldNumber = 1,
  };
  // repeated string mipmap = 2;
  int mipmap_size() const;
  private:
  int _internal_mipmap_size() const;
  public:
  void clear_mipmap();
  const std::string& mipmap(int index) const;
  std::string* mutable_mipmap(int index);
  void set_mipmap(int index, const std::string& value);
  void set_mipmap(int index, std::string&& value);
  void set_mipmap(int index, const char* value);
  void set_mipmap(int index, const char* value, size_t size);
  std::string* add_mipmap();
  void add_mipmap(const std::string& value);
  void add_mipmap(std::string&& value);
  void add_mipmap(const char* value);
  void add_mipmap(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mipmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mipmap();
  private:
  const std::string& _internal_mipmap(int index) const;
  std::string* _internal_add_mipmap();
  public:

  // optional string resource = 1;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBitmap.TCubeMapResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mipmap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBitmap_TCubeMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBitmap.TCubeMap) */ {
 public:
  inline TBitmap_TCubeMap() : TBitmap_TCubeMap(nullptr) {}
  ~TBitmap_TCubeMap() override;
  explicit PROTOBUF_CONSTEXPR TBitmap_TCubeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBitmap_TCubeMap(const TBitmap_TCubeMap& from);
  TBitmap_TCubeMap(TBitmap_TCubeMap&& from) noexcept
    : TBitmap_TCubeMap() {
    *this = ::std::move(from);
  }

  inline TBitmap_TCubeMap& operator=(const TBitmap_TCubeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBitmap_TCubeMap& operator=(TBitmap_TCubeMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBitmap_TCubeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBitmap_TCubeMap* internal_default_instance() {
    return reinterpret_cast<const TBitmap_TCubeMap*>(
               &_TBitmap_TCubeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TBitmap_TCubeMap& a, TBitmap_TCubeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(TBitmap_TCubeMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBitmap_TCubeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBitmap_TCubeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBitmap_TCubeMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBitmap_TCubeMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBitmap_TCubeMap& from) {
    TBitmap_TCubeMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBitmap_TCubeMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBitmap.TCubeMap";
  }
  protected:
  explicit TBitmap_TCubeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCombinedFieldNumber = 1,
    kPositiveXFieldNumber = 2,
    kNegativeXFieldNumber = 3,
    kPositiveYFieldNumber = 4,
    kNegativeYFieldNumber = 5,
    kPositiveZFieldNumber = 6,
    kNegativeZFieldNumber = 7,
  };
  // optional .HmiScenegraph.TBitmap.TCubeMapResource combined = 1;
  bool has_combined() const;
  private:
  bool _internal_has_combined() const;
  public:
  void clear_combined();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& combined() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_combined();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_combined();
  void set_allocated_combined(::HmiScenegraph::TBitmap_TCubeMapResource* combined);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_combined() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_combined();
  public:
  void unsafe_arena_set_allocated_combined(
      ::HmiScenegraph::TBitmap_TCubeMapResource* combined);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_combined();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_x = 2;
  bool has_positive_x() const;
  private:
  bool _internal_has_positive_x() const;
  public:
  void clear_positive_x();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_x() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_positive_x();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_positive_x();
  void set_allocated_positive_x(::HmiScenegraph::TBitmap_TCubeMapResource* positive_x);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_positive_x() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_positive_x();
  public:
  void unsafe_arena_set_allocated_positive_x(
      ::HmiScenegraph::TBitmap_TCubeMapResource* positive_x);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_positive_x();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_x = 3;
  bool has_negative_x() const;
  private:
  bool _internal_has_negative_x() const;
  public:
  void clear_negative_x();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_x() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_negative_x();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_negative_x();
  void set_allocated_negative_x(::HmiScenegraph::TBitmap_TCubeMapResource* negative_x);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_negative_x() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_negative_x();
  public:
  void unsafe_arena_set_allocated_negative_x(
      ::HmiScenegraph::TBitmap_TCubeMapResource* negative_x);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_negative_x();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_y = 4;
  bool has_positive_y() const;
  private:
  bool _internal_has_positive_y() const;
  public:
  void clear_positive_y();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_y() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_positive_y();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_positive_y();
  void set_allocated_positive_y(::HmiScenegraph::TBitmap_TCubeMapResource* positive_y);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_positive_y() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_positive_y();
  public:
  void unsafe_arena_set_allocated_positive_y(
      ::HmiScenegraph::TBitmap_TCubeMapResource* positive_y);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_positive_y();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_y = 5;
  bool has_negative_y() const;
  private:
  bool _internal_has_negative_y() const;
  public:
  void clear_negative_y();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_y() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_negative_y();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_negative_y();
  void set_allocated_negative_y(::HmiScenegraph::TBitmap_TCubeMapResource* negative_y);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_negative_y() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_negative_y();
  public:
  void unsafe_arena_set_allocated_negative_y(
      ::HmiScenegraph::TBitmap_TCubeMapResource* negative_y);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_negative_y();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_z = 6;
  bool has_positive_z() const;
  private:
  bool _internal_has_positive_z() const;
  public:
  void clear_positive_z();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_z() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_positive_z();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_positive_z();
  void set_allocated_positive_z(::HmiScenegraph::TBitmap_TCubeMapResource* positive_z);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_positive_z() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_positive_z();
  public:
  void unsafe_arena_set_allocated_positive_z(
      ::HmiScenegraph::TBitmap_TCubeMapResource* positive_z);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_positive_z();

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_z = 7;
  bool has_negative_z() const;
  private:
  bool _internal_has_negative_z() const;
  public:
  void clear_negative_z();
  const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_z() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMapResource* release_negative_z();
  ::HmiScenegraph::TBitmap_TCubeMapResource* mutable_negative_z();
  void set_allocated_negative_z(::HmiScenegraph::TBitmap_TCubeMapResource* negative_z);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMapResource& _internal_negative_z() const;
  ::HmiScenegraph::TBitmap_TCubeMapResource* _internal_mutable_negative_z();
  public:
  void unsafe_arena_set_allocated_negative_z(
      ::HmiScenegraph::TBitmap_TCubeMapResource* negative_z);
  ::HmiScenegraph::TBitmap_TCubeMapResource* unsafe_arena_release_negative_z();

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBitmap.TCubeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* combined_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_x_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_x_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_y_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_y_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_z_;
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_z_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBitmap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBitmap) */ {
 public:
  inline TBitmap() : TBitmap(nullptr) {}
  ~TBitmap() override;
  explicit PROTOBUF_CONSTEXPR TBitmap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBitmap(const TBitmap& from);
  TBitmap(TBitmap&& from) noexcept
    : TBitmap() {
    *this = ::std::move(from);
  }

  inline TBitmap& operator=(const TBitmap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBitmap& operator=(TBitmap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBitmap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBitmap* internal_default_instance() {
    return reinterpret_cast<const TBitmap*>(
               &_TBitmap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TBitmap& a, TBitmap& b) {
    a.Swap(&b);
  }
  inline void Swap(TBitmap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBitmap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBitmap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBitmap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBitmap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBitmap& from) {
    TBitmap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBitmap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBitmap";
  }
  protected:
  explicit TBitmap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TBitmap_TCubeMapResource TCubeMapResource;
  typedef TBitmap_TCubeMap TCubeMap;

  // accessors -------------------------------------------------------

  enum : int {
    kMipmapFieldNumber = 10,
    kNameFieldNumber = 1,
    kResourceFieldNumber = 2,
    kCubemapFieldNumber = 11,
    kCacheIdFieldNumber = 17,
    kTypeFieldNumber = 3,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kDepthFieldNumber = 6,
    kSamplesFieldNumber = 7,
    kPixelFormatFieldNumber = 8,
    kGenerateMipmapsFieldNumber = 9,
    kSemanticWidthFieldNumber = 12,
    kSemanticHeightFieldNumber = 13,
    kSemanticDepthFieldNumber = 14,
    kResolutionMultiplierFieldNumber = 15,
    kRenderBufferAccessModeFieldNumber = 18,
    kScopeFieldNumber = 16,
  };
  // repeated string mipmap = 10;
  int mipmap_size() const;
  private:
  int _internal_mipmap_size() const;
  public:
  void clear_mipmap();
  const std::string& mipmap(int index) const;
  std::string* mutable_mipmap(int index);
  void set_mipmap(int index, const std::string& value);
  void set_mipmap(int index, std::string&& value);
  void set_mipmap(int index, const char* value);
  void set_mipmap(int index, const char* value, size_t size);
  std::string* add_mipmap();
  void add_mipmap(const std::string& value);
  void add_mipmap(std::string&& value);
  void add_mipmap(const char* value);
  void add_mipmap(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mipmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mipmap();
  private:
  const std::string& _internal_mipmap(int index) const;
  std::string* _internal_add_mipmap();
  public:

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string resource = 2;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // optional .HmiScenegraph.TBitmap.TCubeMap cubemap = 11;
  bool has_cubemap() const;
  private:
  bool _internal_has_cubemap() const;
  public:
  void clear_cubemap();
  const ::HmiScenegraph::TBitmap_TCubeMap& cubemap() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBitmap_TCubeMap* release_cubemap();
  ::HmiScenegraph::TBitmap_TCubeMap* mutable_cubemap();
  void set_allocated_cubemap(::HmiScenegraph::TBitmap_TCubeMap* cubemap);
  private:
  const ::HmiScenegraph::TBitmap_TCubeMap& _internal_cubemap() const;
  ::HmiScenegraph::TBitmap_TCubeMap* _internal_mutable_cubemap();
  public:
  void unsafe_arena_set_allocated_cubemap(
      ::HmiScenegraph::TBitmap_TCubeMap* cubemap);
  ::HmiScenegraph::TBitmap_TCubeMap* unsafe_arena_release_cubemap();

  // optional .HmiScenegraph.TResourceCacheId cacheId = 17;
  bool has_cacheid() const;
  private:
  bool _internal_has_cacheid() const;
  public:
  void clear_cacheid();
  const ::HmiScenegraph::TResourceCacheId& cacheid() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TResourceCacheId* release_cacheid();
  ::HmiScenegraph::TResourceCacheId* mutable_cacheid();
  void set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid);
  private:
  const ::HmiScenegraph::TResourceCacheId& _internal_cacheid() const;
  ::HmiScenegraph::TResourceCacheId* _internal_mutable_cacheid();
  public:
  void unsafe_arena_set_allocated_cacheid(
      ::HmiScenegraph::TResourceCacheId* cacheid);
  ::HmiScenegraph::TResourceCacheId* unsafe_arena_release_cacheid();

  // optional .HmiScenegraph.TEBitmapType type = 3 [default = TEBitmapType_Resource];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HmiScenegraph::TEBitmapType type() const;
  void set_type(::HmiScenegraph::TEBitmapType value);
  private:
  ::HmiScenegraph::TEBitmapType _internal_type() const;
  void _internal_set_type(::HmiScenegraph::TEBitmapType value);
  public:

  // optional uint32 width = 4;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 5;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 depth = 6;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  uint32_t depth() const;
  void set_depth(uint32_t value);
  private:
  uint32_t _internal_depth() const;
  void _internal_set_depth(uint32_t value);
  public:

  // optional uint32 samples = 7 [default = 0];
  bool has_samples() const;
  private:
  bool _internal_has_samples() const;
  public:
  void clear_samples();
  uint32_t samples() const;
  void set_samples(uint32_t value);
  private:
  uint32_t _internal_samples() const;
  void _internal_set_samples(uint32_t value);
  public:

  // optional .TEPixelFormat pixelFormat = 8;
  bool has_pixelformat() const;
  private:
  bool _internal_has_pixelformat() const;
  public:
  void clear_pixelformat();
  ::TEPixelFormat pixelformat() const;
  void set_pixelformat(::TEPixelFormat value);
  private:
  ::TEPixelFormat _internal_pixelformat() const;
  void _internal_set_pixelformat(::TEPixelFormat value);
  public:

  // optional bool generateMipmaps = 9;
  bool has_generatemipmaps() const;
  private:
  bool _internal_has_generatemipmaps() const;
  public:
  void clear_generatemipmaps();
  bool generatemipmaps() const;
  void set_generatemipmaps(bool value);
  private:
  bool _internal_generatemipmaps() const;
  void _internal_set_generatemipmaps(bool value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticWidth = 12;
  bool has_semanticwidth() const;
  private:
  bool _internal_has_semanticwidth() const;
  public:
  void clear_semanticwidth();
  ::HmiScenegraph::TESemanticValue semanticwidth() const;
  void set_semanticwidth(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticwidth() const;
  void _internal_set_semanticwidth(::HmiScenegraph::TESemanticValue value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticHeight = 13;
  bool has_semanticheight() const;
  private:
  bool _internal_has_semanticheight() const;
  public:
  void clear_semanticheight();
  ::HmiScenegraph::TESemanticValue semanticheight() const;
  void set_semanticheight(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticheight() const;
  void _internal_set_semanticheight(::HmiScenegraph::TESemanticValue value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticDepth = 14;
  bool has_semanticdepth() const;
  private:
  bool _internal_has_semanticdepth() const;
  public:
  void clear_semanticdepth();
  ::HmiScenegraph::TESemanticValue semanticdepth() const;
  void set_semanticdepth(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticdepth() const;
  void _internal_set_semanticdepth(::HmiScenegraph::TESemanticValue value);
  public:

  // optional float resolutionMultiplier = 15;
  bool has_resolutionmultiplier() const;
  private:
  bool _internal_has_resolutionmultiplier() const;
  public:
  void clear_resolutionmultiplier();
  float resolutionmultiplier() const;
  void set_resolutionmultiplier(float value);
  private:
  float _internal_resolutionmultiplier() const;
  void _internal_set_resolutionmultiplier(float value);
  public:

  // optional .HmiScenegraph.TERenderBufferAccessMode renderBufferAccessMode = 18 [default = TERenderBufferAccessMode_WriteOnly];
  bool has_renderbufferaccessmode() const;
  private:
  bool _internal_has_renderbufferaccessmode() const;
  public:
  void clear_renderbufferaccessmode();
  ::HmiScenegraph::TERenderBufferAccessMode renderbufferaccessmode() const;
  void set_renderbufferaccessmode(::HmiScenegraph::TERenderBufferAccessMode value);
  private:
  ::HmiScenegraph::TERenderBufferAccessMode _internal_renderbufferaccessmode() const;
  void _internal_set_renderbufferaccessmode(::HmiScenegraph::TERenderBufferAccessMode value);
  public:

  // optional .TEScope scope = 16;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBitmap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mipmap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
    ::HmiScenegraph::TBitmap_TCubeMap* cubemap_;
    ::HmiScenegraph::TResourceCacheId* cacheid_;
    int type_;
    uint32_t width_;
    uint32_t height_;
    uint32_t depth_;
    uint32_t samples_;
    int pixelformat_;
    bool generatemipmaps_;
    int semanticwidth_;
    int semanticheight_;
    int semanticdepth_;
    float resolutionmultiplier_;
    int renderbufferaccessmode_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TTexture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TTexture) */ {
 public:
  inline TTexture() : TTexture(nullptr) {}
  ~TTexture() override;
  explicit PROTOBUF_CONSTEXPR TTexture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TTexture(const TTexture& from);
  TTexture(TTexture&& from) noexcept
    : TTexture() {
    *this = ::std::move(from);
  }

  inline TTexture& operator=(const TTexture& from) {
    CopyFrom(from);
    return *this;
  }
  inline TTexture& operator=(TTexture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TTexture& default_instance() {
    return *internal_default_instance();
  }
  static inline const TTexture* internal_default_instance() {
    return reinterpret_cast<const TTexture*>(
               &_TTexture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TTexture& a, TTexture& b) {
    a.Swap(&b);
  }
  inline void Swap(TTexture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TTexture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TTexture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TTexture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TTexture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TTexture& from) {
    TTexture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTexture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TTexture";
  }
  protected:
  explicit TTexture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kBitmapReferenceFieldNumber = 2,
    kUniformNameFieldNumber = 9,
    kAnisotropicSamplesFieldNumber = 6,
    kMinFilterFieldNumber = 3,
    kMagFilterFieldNumber = 4,
    kWrapModeUFieldNumber = 7,
    kWrapModeVFieldNumber = 8,
  };
  // required string name = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  PROTOBUF_DEPRECATED void clear_name();
  PROTOBUF_DEPRECATED const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_name(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_name();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_name();
  PROTOBUF_DEPRECATED void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string bitmapReference = 2;
  bool has_bitmapreference() const;
  private:
  bool _internal_has_bitmapreference() const;
  public:
  void clear_bitmapreference();
  const std::string& bitmapreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bitmapreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bitmapreference();
  PROTOBUF_NODISCARD std::string* release_bitmapreference();
  void set_allocated_bitmapreference(std::string* bitmapreference);
  private:
  const std::string& _internal_bitmapreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bitmapreference(const std::string& value);
  std::string* _internal_mutable_bitmapreference();
  public:

  // optional string uniformName = 9;
  bool has_uniformname() const;
  private:
  bool _internal_has_uniformname() const;
  public:
  void clear_uniformname();
  const std::string& uniformname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniformname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniformname();
  PROTOBUF_NODISCARD std::string* release_uniformname();
  void set_allocated_uniformname(std::string* uniformname);
  private:
  const std::string& _internal_uniformname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniformname(const std::string& value);
  std::string* _internal_mutable_uniformname();
  public:

  // optional float anisotropicSamples = 6;
  bool has_anisotropicsamples() const;
  private:
  bool _internal_has_anisotropicsamples() const;
  public:
  void clear_anisotropicsamples();
  float anisotropicsamples() const;
  void set_anisotropicsamples(float value);
  private:
  float _internal_anisotropicsamples() const;
  void _internal_set_anisotropicsamples(float value);
  public:

  // optional .TETextureFilter minFilter = 3;
  bool has_minfilter() const;
  private:
  bool _internal_has_minfilter() const;
  public:
  void clear_minfilter();
  ::TETextureFilter minfilter() const;
  void set_minfilter(::TETextureFilter value);
  private:
  ::TETextureFilter _internal_minfilter() const;
  void _internal_set_minfilter(::TETextureFilter value);
  public:

  // optional .TETextureFilter magFilter = 4;
  bool has_magfilter() const;
  private:
  bool _internal_has_magfilter() const;
  public:
  void clear_magfilter();
  ::TETextureFilter magfilter() const;
  void set_magfilter(::TETextureFilter value);
  private:
  ::TETextureFilter _internal_magfilter() const;
  void _internal_set_magfilter(::TETextureFilter value);
  public:

  // optional .TETextureWrapMode wrapModeU = 7;
  bool has_wrapmodeu() const;
  private:
  bool _internal_has_wrapmodeu() const;
  public:
  void clear_wrapmodeu();
  ::TETextureWrapMode wrapmodeu() const;
  void set_wrapmodeu(::TETextureWrapMode value);
  private:
  ::TETextureWrapMode _internal_wrapmodeu() const;
  void _internal_set_wrapmodeu(::TETextureWrapMode value);
  public:

  // optional .TETextureWrapMode wrapModeV = 8;
  bool has_wrapmodev() const;
  private:
  bool _internal_has_wrapmodev() const;
  public:
  void clear_wrapmodev();
  ::TETextureWrapMode wrapmodev() const;
  void set_wrapmodev(::TETextureWrapMode value);
  private:
  ::TETextureWrapMode _internal_wrapmodev() const;
  void _internal_set_wrapmodev(::TETextureWrapMode value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TTexture)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bitmapreference_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniformname_;
    float anisotropicsamples_;
    int minfilter_;
    int magfilter_;
    int wrapmodeu_;
    int wrapmodev_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TMaterial final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TMaterial) */ {
 public:
  inline TMaterial() : TMaterial(nullptr) {}
  ~TMaterial() override;
  explicit PROTOBUF_CONSTEXPR TMaterial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMaterial(const TMaterial& from);
  TMaterial(TMaterial&& from) noexcept
    : TMaterial() {
    *this = ::std::move(from);
  }

  inline TMaterial& operator=(const TMaterial& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMaterial& operator=(TMaterial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMaterial& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMaterial* internal_default_instance() {
    return reinterpret_cast<const TMaterial*>(
               &_TMaterial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TMaterial& a, TMaterial& b) {
    a.Swap(&b);
  }
  inline void Swap(TMaterial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMaterial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMaterial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMaterial>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMaterial& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMaterial& from) {
    TMaterial::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMaterial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TMaterial";
  }
  protected:
  explicit TMaterial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextureFieldNumber = 4,
    kUniformFieldNumber = 6,
    kNameFieldNumber = 1,
    kShaderReferenceFieldNumber = 3,
    kRenderModeFieldNumber = 2,
    kScopeFieldNumber = 5,
  };
  // repeated .HmiScenegraph.TTexture texture = 4;
  int texture_size() const;
  private:
  int _internal_texture_size() const;
  public:
  void clear_texture();
  ::HmiScenegraph::TTexture* mutable_texture(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >*
      mutable_texture();
  private:
  const ::HmiScenegraph::TTexture& _internal_texture(int index) const;
  ::HmiScenegraph::TTexture* _internal_add_texture();
  public:
  const ::HmiScenegraph::TTexture& texture(int index) const;
  ::HmiScenegraph::TTexture* add_texture();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >&
      texture() const;

  // repeated .HmiScenegraph.TUniform uniform = 6;
  int uniform_size() const;
  private:
  int _internal_uniform_size() const;
  public:
  void clear_uniform();
  ::HmiScenegraph::TUniform* mutable_uniform(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
      mutable_uniform();
  private:
  const ::HmiScenegraph::TUniform& _internal_uniform(int index) const;
  ::HmiScenegraph::TUniform* _internal_add_uniform();
  public:
  const ::HmiScenegraph::TUniform& uniform(int index) const;
  ::HmiScenegraph::TUniform* add_uniform();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
      uniform() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string shaderReference = 3;
  bool has_shaderreference() const;
  private:
  bool _internal_has_shaderreference() const;
  public:
  void clear_shaderreference();
  const std::string& shaderreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shaderreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shaderreference();
  PROTOBUF_NODISCARD std::string* release_shaderreference();
  void set_allocated_shaderreference(std::string* shaderreference);
  private:
  const std::string& _internal_shaderreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shaderreference(const std::string& value);
  std::string* _internal_mutable_shaderreference();
  public:

  // required .HmiScenegraph.TRenderMode renderMode = 2;
  bool has_rendermode() const;
  private:
  bool _internal_has_rendermode() const;
  public:
  void clear_rendermode();
  const ::HmiScenegraph::TRenderMode& rendermode() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TRenderMode* release_rendermode();
  ::HmiScenegraph::TRenderMode* mutable_rendermode();
  void set_allocated_rendermode(::HmiScenegraph::TRenderMode* rendermode);
  private:
  const ::HmiScenegraph::TRenderMode& _internal_rendermode() const;
  ::HmiScenegraph::TRenderMode* _internal_mutable_rendermode();
  public:
  void unsafe_arena_set_allocated_rendermode(
      ::HmiScenegraph::TRenderMode* rendermode);
  ::HmiScenegraph::TRenderMode* unsafe_arena_release_rendermode();

  // optional .TEScope scope = 5;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TMaterial)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture > texture_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform > uniform_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shaderreference_;
    ::HmiScenegraph::TRenderMode* rendermode_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TMesh_TAttributeParamteter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TMesh.TAttributeParamteter) */ {
 public:
  inline TMesh_TAttributeParamteter() : TMesh_TAttributeParamteter(nullptr) {}
  ~TMesh_TAttributeParamteter() override;
  explicit PROTOBUF_CONSTEXPR TMesh_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMesh_TAttributeParamteter(const TMesh_TAttributeParamteter& from);
  TMesh_TAttributeParamteter(TMesh_TAttributeParamteter&& from) noexcept
    : TMesh_TAttributeParamteter() {
    *this = ::std::move(from);
  }

  inline TMesh_TAttributeParamteter& operator=(const TMesh_TAttributeParamteter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMesh_TAttributeParamteter& operator=(TMesh_TAttributeParamteter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMesh_TAttributeParamteter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMesh_TAttributeParamteter* internal_default_instance() {
    return reinterpret_cast<const TMesh_TAttributeParamteter*>(
               &_TMesh_TAttributeParamteter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TMesh_TAttributeParamteter& a, TMesh_TAttributeParamteter& b) {
    a.Swap(&b);
  }
  inline void Swap(TMesh_TAttributeParamteter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMesh_TAttributeParamteter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMesh_TAttributeParamteter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMesh_TAttributeParamteter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMesh_TAttributeParamteter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMesh_TAttributeParamteter& from) {
    TMesh_TAttributeParamteter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMesh_TAttributeParamteter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TMesh.TAttributeParamteter";
  }
  protected:
  explicit TMesh_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .HmiScenegraph.TEAttributePrecision precision = 2;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  ::HmiScenegraph::TEAttributePrecision precision() const;
  void set_precision(::HmiScenegraph::TEAttributePrecision value);
  private:
  ::HmiScenegraph::TEAttributePrecision _internal_precision() const;
  void _internal_set_precision(::HmiScenegraph::TEAttributePrecision value);
  public:

  // optional .HmiScenegraph.TEAttributeSize size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::HmiScenegraph::TEAttributeSize size() const;
  void set_size(::HmiScenegraph::TEAttributeSize value);
  private:
  ::HmiScenegraph::TEAttributeSize _internal_size() const;
  void _internal_set_size(::HmiScenegraph::TEAttributeSize value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TMesh.TAttributeParamteter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int precision_;
    int size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TMesh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TMesh) */ {
 public:
  inline TMesh() : TMesh(nullptr) {}
  ~TMesh() override;
  explicit PROTOBUF_CONSTEXPR TMesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMesh(const TMesh& from);
  TMesh(TMesh&& from) noexcept
    : TMesh() {
    *this = ::std::move(from);
  }

  inline TMesh& operator=(const TMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMesh& operator=(TMesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMesh* internal_default_instance() {
    return reinterpret_cast<const TMesh*>(
               &_TMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TMesh& a, TMesh& b) {
    a.Swap(&b);
  }
  inline void Swap(TMesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMesh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMesh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMesh& from) {
    TMesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMesh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TMesh";
  }
  protected:
  explicit TMesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TMesh_TAttributeParamteter TAttributeParamteter;

  // accessors -------------------------------------------------------

  enum : int {
    kUniformFieldNumber = 4,
    kAttributeParameterFieldNumber = 5,
    kRenderPassDependencyFieldNumber = 6,
    kTextureFieldNumber = 8,
    kMeshResourceFieldNumber = 2,
    kMaterialReferenceFieldNumber = 3,
    kMeshReferenceFieldNumber = 7,
    kBaseNodeFieldNumber = 1,
  };
  // repeated .HmiScenegraph.TUniform uniform = 4;
  int uniform_size() const;
  private:
  int _internal_uniform_size() const;
  public:
  void clear_uniform();
  ::HmiScenegraph::TUniform* mutable_uniform(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
      mutable_uniform();
  private:
  const ::HmiScenegraph::TUniform& _internal_uniform(int index) const;
  ::HmiScenegraph::TUniform* _internal_add_uniform();
  public:
  const ::HmiScenegraph::TUniform& uniform(int index) const;
  ::HmiScenegraph::TUniform* add_uniform();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
      uniform() const;

  // repeated .HmiScenegraph.TMesh.TAttributeParamteter attributeParameter = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int attributeparameter_size() const;
  private:
  int _internal_attributeparameter_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_attributeparameter();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TMesh_TAttributeParamteter* mutable_attributeparameter(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh_TAttributeParamteter >*
      mutable_attributeparameter();
  private:
  const ::HmiScenegraph::TMesh_TAttributeParamteter& _internal_attributeparameter(int index) const;
  ::HmiScenegraph::TMesh_TAttributeParamteter* _internal_add_attributeparameter();
  public:
  PROTOBUF_DEPRECATED const ::HmiScenegraph::TMesh_TAttributeParamteter& attributeparameter(int index) const;
  PROTOBUF_DEPRECATED ::HmiScenegraph::TMesh_TAttributeParamteter* add_attributeparameter();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh_TAttributeParamteter >&
      attributeparameter() const;

  // repeated string renderPassDependency = 6;
  int renderpassdependency_size() const;
  private:
  int _internal_renderpassdependency_size() const;
  public:
  void clear_renderpassdependency();
  const std::string& renderpassdependency(int index) const;
  std::string* mutable_renderpassdependency(int index);
  void set_renderpassdependency(int index, const std::string& value);
  void set_renderpassdependency(int index, std::string&& value);
  void set_renderpassdependency(int index, const char* value);
  void set_renderpassdependency(int index, const char* value, size_t size);
  std::string* add_renderpassdependency();
  void add_renderpassdependency(const std::string& value);
  void add_renderpassdependency(std::string&& value);
  void add_renderpassdependency(const char* value);
  void add_renderpassdependency(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& renderpassdependency() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_renderpassdependency();
  private:
  const std::string& _internal_renderpassdependency(int index) const;
  std::string* _internal_add_renderpassdependency();
  public:

  // repeated .HmiScenegraph.TTexture texture = 8;
  int texture_size() const;
  private:
  int _internal_texture_size() const;
  public:
  void clear_texture();
  ::HmiScenegraph::TTexture* mutable_texture(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >*
      mutable_texture();
  private:
  const ::HmiScenegraph::TTexture& _internal_texture(int index) const;
  ::HmiScenegraph::TTexture* _internal_add_texture();
  public:
  const ::HmiScenegraph::TTexture& texture(int index) const;
  ::HmiScenegraph::TTexture* add_texture();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >&
      texture() const;

  // required string meshResource = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_meshresource() const;
  private:
  bool _internal_has_meshresource() const;
  public:
  PROTOBUF_DEPRECATED void clear_meshresource();
  PROTOBUF_DEPRECATED const std::string& meshresource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_meshresource(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_meshresource();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_meshresource();
  PROTOBUF_DEPRECATED void set_allocated_meshresource(std::string* meshresource);
  private:
  const std::string& _internal_meshresource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meshresource(const std::string& value);
  std::string* _internal_mutable_meshresource();
  public:

  // required string materialReference = 3;
  bool has_materialreference() const;
  private:
  bool _internal_has_materialreference() const;
  public:
  void clear_materialreference();
  const std::string& materialreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_materialreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_materialreference();
  PROTOBUF_NODISCARD std::string* release_materialreference();
  void set_allocated_materialreference(std::string* materialreference);
  private:
  const std::string& _internal_materialreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialreference(const std::string& value);
  std::string* _internal_mutable_materialreference();
  public:

  // optional string meshReference = 7;
  bool has_meshreference() const;
  private:
  bool _internal_has_meshreference() const;
  public:
  void clear_meshreference();
  const std::string& meshreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meshreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meshreference();
  PROTOBUF_NODISCARD std::string* release_meshreference();
  void set_allocated_meshreference(std::string* meshreference);
  private:
  const std::string& _internal_meshreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meshreference(const std::string& value);
  std::string* _internal_mutable_meshreference();
  public:

  // required .HmiScenegraph.TNode baseNode = 1;
  bool has_basenode() const;
  private:
  bool _internal_has_basenode() const;
  public:
  void clear_basenode();
  const ::HmiScenegraph::TNode& basenode() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TNode* release_basenode();
  ::HmiScenegraph::TNode* mutable_basenode();
  void set_allocated_basenode(::HmiScenegraph::TNode* basenode);
  private:
  const ::HmiScenegraph::TNode& _internal_basenode() const;
  ::HmiScenegraph::TNode* _internal_mutable_basenode();
  public:
  void unsafe_arena_set_allocated_basenode(
      ::HmiScenegraph::TNode* basenode);
  ::HmiScenegraph::TNode* unsafe_arena_release_basenode();

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TMesh)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform > uniform_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh_TAttributeParamteter > attributeparameter_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> renderpassdependency_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture > texture_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meshresource_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr materialreference_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meshreference_;
    ::HmiScenegraph::TNode* basenode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderLayer) */ {
 public:
  inline TRenderLayer() : TRenderLayer(nullptr) {}
  ~TRenderLayer() override;
  explicit PROTOBUF_CONSTEXPR TRenderLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderLayer(const TRenderLayer& from);
  TRenderLayer(TRenderLayer&& from) noexcept
    : TRenderLayer() {
    *this = ::std::move(from);
  }

  inline TRenderLayer& operator=(const TRenderLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderLayer& operator=(TRenderLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderLayer* internal_default_instance() {
    return reinterpret_cast<const TRenderLayer*>(
               &_TRenderLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TRenderLayer& a, TRenderLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderLayer& from) {
    TRenderLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderLayer";
  }
  protected:
  explicit TRenderLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniformFieldNumber = 3,
    kChildFieldNumber = 8,
    kMaterialReferenceFieldNumber = 2,
    kBoundingBoxRootNameFieldNumber = 6,
    kBaseNodeFieldNumber = 1,
    kRenderPassFieldNumber = 4,
    kRenderTargetScaleFieldNumber = 5,
    kBorderSizeFieldNumber = 7,
  };
  // repeated .HmiScenegraph.TUniform uniform = 3;
  int uniform_size() const;
  private:
  int _internal_uniform_size() const;
  public:
  void clear_uniform();
  ::HmiScenegraph::TUniform* mutable_uniform(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
      mutable_uniform();
  private:
  const ::HmiScenegraph::TUniform& _internal_uniform(int index) const;
  ::HmiScenegraph::TUniform* _internal_add_uniform();
  public:
  const ::HmiScenegraph::TUniform& uniform(int index) const;
  ::HmiScenegraph::TUniform* add_uniform();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
      uniform() const;

  // repeated .HmiScenegraph.TNode child = 8;
  int child_size() const;
  private:
  int _internal_child_size() const;
  public:
  void clear_child();
  ::HmiScenegraph::TNode* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >*
      mutable_child();
  private:
  const ::HmiScenegraph::TNode& _internal_child(int index) const;
  ::HmiScenegraph::TNode* _internal_add_child();
  public:
  const ::HmiScenegraph::TNode& child(int index) const;
  ::HmiScenegraph::TNode* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >&
      child() const;

  // optional string materialReference = 2;
  bool has_materialreference() const;
  private:
  bool _internal_has_materialreference() const;
  public:
  void clear_materialreference();
  const std::string& materialreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_materialreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_materialreference();
  PROTOBUF_NODISCARD std::string* release_materialreference();
  void set_allocated_materialreference(std::string* materialreference);
  private:
  const std::string& _internal_materialreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_materialreference(const std::string& value);
  std::string* _internal_mutable_materialreference();
  public:

  // optional string boundingBoxRootName = 6;
  bool has_boundingboxrootname() const;
  private:
  bool _internal_has_boundingboxrootname() const;
  public:
  void clear_boundingboxrootname();
  const std::string& boundingboxrootname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_boundingboxrootname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_boundingboxrootname();
  PROTOBUF_NODISCARD std::string* release_boundingboxrootname();
  void set_allocated_boundingboxrootname(std::string* boundingboxrootname);
  private:
  const std::string& _internal_boundingboxrootname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_boundingboxrootname(const std::string& value);
  std::string* _internal_mutable_boundingboxrootname();
  public:

  // required .HmiScenegraph.TNode baseNode = 1;
  bool has_basenode() const;
  private:
  bool _internal_has_basenode() const;
  public:
  void clear_basenode();
  const ::HmiScenegraph::TNode& basenode() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TNode* release_basenode();
  ::HmiScenegraph::TNode* mutable_basenode();
  void set_allocated_basenode(::HmiScenegraph::TNode* basenode);
  private:
  const ::HmiScenegraph::TNode& _internal_basenode() const;
  ::HmiScenegraph::TNode* _internal_mutable_basenode();
  public:
  void unsafe_arena_set_allocated_basenode(
      ::HmiScenegraph::TNode* basenode);
  ::HmiScenegraph::TNode* unsafe_arena_release_basenode();

  // optional .HmiScenegraph.TRenderPass renderPass = 4;
  bool has_renderpass() const;
  private:
  bool _internal_has_renderpass() const;
  public:
  void clear_renderpass();
  const ::HmiScenegraph::TRenderPass& renderpass() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TRenderPass* release_renderpass();
  ::HmiScenegraph::TRenderPass* mutable_renderpass();
  void set_allocated_renderpass(::HmiScenegraph::TRenderPass* renderpass);
  private:
  const ::HmiScenegraph::TRenderPass& _internal_renderpass() const;
  ::HmiScenegraph::TRenderPass* _internal_mutable_renderpass();
  public:
  void unsafe_arena_set_allocated_renderpass(
      ::HmiScenegraph::TRenderPass* renderpass);
  ::HmiScenegraph::TRenderPass* unsafe_arena_release_renderpass();

  // optional float renderTargetScale = 5 [default = 0];
  bool has_rendertargetscale() const;
  private:
  bool _internal_has_rendertargetscale() const;
  public:
  void clear_rendertargetscale();
  float rendertargetscale() const;
  void set_rendertargetscale(float value);
  private:
  float _internal_rendertargetscale() const;
  void _internal_set_rendertargetscale(float value);
  public:

  // optional int32 borderSize = 7 [default = 0];
  bool has_bordersize() const;
  private:
  bool _internal_has_bordersize() const;
  public:
  void clear_bordersize();
  int32_t bordersize() const;
  void set_bordersize(int32_t value);
  private:
  int32_t _internal_bordersize() const;
  void _internal_set_bordersize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform > uniform_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode > child_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr materialreference_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr boundingboxrootname_;
    ::HmiScenegraph::TNode* basenode_;
    ::HmiScenegraph::TRenderPass* renderpass_;
    float rendertargetscale_;
    int32_t bordersize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBoundingVolume_TBoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBoundingVolume.TBoundingBox) */ {
 public:
  inline TBoundingVolume_TBoundingBox() : TBoundingVolume_TBoundingBox(nullptr) {}
  ~TBoundingVolume_TBoundingBox() override;
  explicit PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBoundingVolume_TBoundingBox(const TBoundingVolume_TBoundingBox& from);
  TBoundingVolume_TBoundingBox(TBoundingVolume_TBoundingBox&& from) noexcept
    : TBoundingVolume_TBoundingBox() {
    *this = ::std::move(from);
  }

  inline TBoundingVolume_TBoundingBox& operator=(const TBoundingVolume_TBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBoundingVolume_TBoundingBox& operator=(TBoundingVolume_TBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBoundingVolume_TBoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBoundingVolume_TBoundingBox* internal_default_instance() {
    return reinterpret_cast<const TBoundingVolume_TBoundingBox*>(
               &_TBoundingVolume_TBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TBoundingVolume_TBoundingBox& a, TBoundingVolume_TBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(TBoundingVolume_TBoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBoundingVolume_TBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBoundingVolume_TBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBoundingVolume_TBoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBoundingVolume_TBoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBoundingVolume_TBoundingBox& from) {
    TBoundingVolume_TBoundingBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBoundingVolume_TBoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBoundingVolume.TBoundingBox";
  }
  protected:
  explicit TBoundingVolume_TBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinBoundFieldNumber = 1,
    kMaxBoundFieldNumber = 2,
  };
  // optional .TVector3f minBound = 1;
  bool has_minbound() const;
  private:
  bool _internal_has_minbound() const;
  public:
  void clear_minbound();
  const ::TVector3f& minbound() const;
  PROTOBUF_NODISCARD ::TVector3f* release_minbound();
  ::TVector3f* mutable_minbound();
  void set_allocated_minbound(::TVector3f* minbound);
  private:
  const ::TVector3f& _internal_minbound() const;
  ::TVector3f* _internal_mutable_minbound();
  public:
  void unsafe_arena_set_allocated_minbound(
      ::TVector3f* minbound);
  ::TVector3f* unsafe_arena_release_minbound();

  // optional .TVector3f maxBound = 2;
  bool has_maxbound() const;
  private:
  bool _internal_has_maxbound() const;
  public:
  void clear_maxbound();
  const ::TVector3f& maxbound() const;
  PROTOBUF_NODISCARD ::TVector3f* release_maxbound();
  ::TVector3f* mutable_maxbound();
  void set_allocated_maxbound(::TVector3f* maxbound);
  private:
  const ::TVector3f& _internal_maxbound() const;
  ::TVector3f* _internal_mutable_maxbound();
  public:
  void unsafe_arena_set_allocated_maxbound(
      ::TVector3f* maxbound);
  ::TVector3f* unsafe_arena_release_maxbound();

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBoundingVolume.TBoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TVector3f* minbound_;
    ::TVector3f* maxbound_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBoundingVolume_TBoundingSphere final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBoundingVolume.TBoundingSphere) */ {
 public:
  inline TBoundingVolume_TBoundingSphere() : TBoundingVolume_TBoundingSphere(nullptr) {}
  ~TBoundingVolume_TBoundingSphere() override;
  explicit PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingSphere(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBoundingVolume_TBoundingSphere(const TBoundingVolume_TBoundingSphere& from);
  TBoundingVolume_TBoundingSphere(TBoundingVolume_TBoundingSphere&& from) noexcept
    : TBoundingVolume_TBoundingSphere() {
    *this = ::std::move(from);
  }

  inline TBoundingVolume_TBoundingSphere& operator=(const TBoundingVolume_TBoundingSphere& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBoundingVolume_TBoundingSphere& operator=(TBoundingVolume_TBoundingSphere&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBoundingVolume_TBoundingSphere& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBoundingVolume_TBoundingSphere* internal_default_instance() {
    return reinterpret_cast<const TBoundingVolume_TBoundingSphere*>(
               &_TBoundingVolume_TBoundingSphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TBoundingVolume_TBoundingSphere& a, TBoundingVolume_TBoundingSphere& b) {
    a.Swap(&b);
  }
  inline void Swap(TBoundingVolume_TBoundingSphere* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBoundingVolume_TBoundingSphere* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBoundingVolume_TBoundingSphere* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBoundingVolume_TBoundingSphere>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBoundingVolume_TBoundingSphere& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBoundingVolume_TBoundingSphere& from) {
    TBoundingVolume_TBoundingSphere::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBoundingVolume_TBoundingSphere* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBoundingVolume.TBoundingSphere";
  }
  protected:
  explicit TBoundingVolume_TBoundingSphere(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPositionFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // optional .TVector3f centerPosition = 1;
  bool has_centerposition() const;
  private:
  bool _internal_has_centerposition() const;
  public:
  void clear_centerposition();
  const ::TVector3f& centerposition() const;
  PROTOBUF_NODISCARD ::TVector3f* release_centerposition();
  ::TVector3f* mutable_centerposition();
  void set_allocated_centerposition(::TVector3f* centerposition);
  private:
  const ::TVector3f& _internal_centerposition() const;
  ::TVector3f* _internal_mutable_centerposition();
  public:
  void unsafe_arena_set_allocated_centerposition(
      ::TVector3f* centerposition);
  ::TVector3f* unsafe_arena_release_centerposition();

  // optional float radius = 2;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBoundingVolume.TBoundingSphere)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TVector3f* centerposition_;
    float radius_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBoundingVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBoundingVolume) */ {
 public:
  inline TBoundingVolume() : TBoundingVolume(nullptr) {}
  ~TBoundingVolume() override;
  explicit PROTOBUF_CONSTEXPR TBoundingVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBoundingVolume(const TBoundingVolume& from);
  TBoundingVolume(TBoundingVolume&& from) noexcept
    : TBoundingVolume() {
    *this = ::std::move(from);
  }

  inline TBoundingVolume& operator=(const TBoundingVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBoundingVolume& operator=(TBoundingVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBoundingVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBoundingVolume* internal_default_instance() {
    return reinterpret_cast<const TBoundingVolume*>(
               &_TBoundingVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TBoundingVolume& a, TBoundingVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(TBoundingVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBoundingVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBoundingVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBoundingVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBoundingVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBoundingVolume& from) {
    TBoundingVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBoundingVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBoundingVolume";
  }
  protected:
  explicit TBoundingVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TBoundingVolume_TBoundingBox TBoundingBox;
  typedef TBoundingVolume_TBoundingSphere TBoundingSphere;

  // accessors -------------------------------------------------------

  enum : int {
    kBoundingBoxFieldNumber = 1,
    kBoundingSphereFieldNumber = 2,
  };
  // optional .HmiScenegraph.TBoundingVolume.TBoundingBox boundingBox = 1;
  bool has_boundingbox() const;
  private:
  bool _internal_has_boundingbox() const;
  public:
  void clear_boundingbox();
  const ::HmiScenegraph::TBoundingVolume_TBoundingBox& boundingbox() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBoundingVolume_TBoundingBox* release_boundingbox();
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* mutable_boundingbox();
  void set_allocated_boundingbox(::HmiScenegraph::TBoundingVolume_TBoundingBox* boundingbox);
  private:
  const ::HmiScenegraph::TBoundingVolume_TBoundingBox& _internal_boundingbox() const;
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* _internal_mutable_boundingbox();
  public:
  void unsafe_arena_set_allocated_boundingbox(
      ::HmiScenegraph::TBoundingVolume_TBoundingBox* boundingbox);
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* unsafe_arena_release_boundingbox();

  // optional .HmiScenegraph.TBoundingVolume.TBoundingSphere boundingSphere = 2;
  bool has_boundingsphere() const;
  private:
  bool _internal_has_boundingsphere() const;
  public:
  void clear_boundingsphere();
  const ::HmiScenegraph::TBoundingVolume_TBoundingSphere& boundingsphere() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBoundingVolume_TBoundingSphere* release_boundingsphere();
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* mutable_boundingsphere();
  void set_allocated_boundingsphere(::HmiScenegraph::TBoundingVolume_TBoundingSphere* boundingsphere);
  private:
  const ::HmiScenegraph::TBoundingVolume_TBoundingSphere& _internal_boundingsphere() const;
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* _internal_mutable_boundingsphere();
  public:
  void unsafe_arena_set_allocated_boundingsphere(
      ::HmiScenegraph::TBoundingVolume_TBoundingSphere* boundingsphere);
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* unsafe_arena_release_boundingsphere();

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBoundingVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::HmiScenegraph::TBoundingVolume_TBoundingBox* boundingbox_;
    ::HmiScenegraph::TBoundingVolume_TBoundingSphere* boundingsphere_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TNode_TRenderPassName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TNode.TRenderPassName) */ {
 public:
  inline TNode_TRenderPassName() : TNode_TRenderPassName(nullptr) {}
  ~TNode_TRenderPassName() override;
  explicit PROTOBUF_CONSTEXPR TNode_TRenderPassName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TNode_TRenderPassName(const TNode_TRenderPassName& from);
  TNode_TRenderPassName(TNode_TRenderPassName&& from) noexcept
    : TNode_TRenderPassName() {
    *this = ::std::move(from);
  }

  inline TNode_TRenderPassName& operator=(const TNode_TRenderPassName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TNode_TRenderPassName& operator=(TNode_TRenderPassName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TNode_TRenderPassName& default_instance() {
    return *internal_default_instance();
  }
  static inline const TNode_TRenderPassName* internal_default_instance() {
    return reinterpret_cast<const TNode_TRenderPassName*>(
               &_TNode_TRenderPassName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TNode_TRenderPassName& a, TNode_TRenderPassName& b) {
    a.Swap(&b);
  }
  inline void Swap(TNode_TRenderPassName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TNode_TRenderPassName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TNode_TRenderPassName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TNode_TRenderPassName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TNode_TRenderPassName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TNode_TRenderPassName& from) {
    TNode_TRenderPassName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TNode_TRenderPassName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TNode.TRenderPassName";
  }
  protected:
  explicit TNode_TRenderPassName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEnabledFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool enabled = 2 [default = false];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TNode.TRenderPassName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TNode) */ {
 public:
  inline TNode() : TNode(nullptr) {}
  ~TNode() override;
  explicit PROTOBUF_CONSTEXPR TNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TNode(const TNode& from);
  TNode(TNode&& from) noexcept
    : TNode() {
    *this = ::std::move(from);
  }

  inline TNode& operator=(const TNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TNode& operator=(TNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TNode* internal_default_instance() {
    return reinterpret_cast<const TNode*>(
               &_TNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TNode& a, TNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TNode& from) {
    TNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TNode";
  }
  protected:
  explicit TNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TNode_TRenderPassName TRenderPassName;

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 10,
    kMeshFieldNumber = 11,
    kRenderLayerFieldNumber = 13,
    kRenderPassNameEXTFieldNumber = 21,
    kRenderPassFieldNumber = 24,
    kNameFieldNumber = 1,
    kLookAtTargetNameFieldNumber = 14,
    kRenderPassNameFieldNumber = 19,
    kScaleFieldNumber = 4,
    kRotationFieldNumber = 5,
    kTranslationFieldNumber = 6,
    kTransformationFieldNumber = 7,
    kCameraFieldNumber = 12,
    kLookAtUpVectorFieldNumber = 15,
    kRenderOrderBinFieldNumber = 22,
    kBoundingVolumeFieldNumber = 23,
    kRenderOrderFieldNumber = 2,
    kChildSortOrderRankFieldNumber = 3,
    kLookAtUpAxisFieldNumber = 16,
    kLookAtForwardAxisFieldNumber = 17,
    kLookAtAlignToTargetAxisFieldNumber = 18,
    kRenderPassEnabledFieldNumber = 20,
  };
  // repeated .HmiScenegraph.TNode child = 10;
  int child_size() const;
  private:
  int _internal_child_size() const;
  public:
  void clear_child();
  ::HmiScenegraph::TNode* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >*
      mutable_child();
  private:
  const ::HmiScenegraph::TNode& _internal_child(int index) const;
  ::HmiScenegraph::TNode* _internal_add_child();
  public:
  const ::HmiScenegraph::TNode& child(int index) const;
  ::HmiScenegraph::TNode* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >&
      child() const;

  // repeated .HmiScenegraph.TMesh mesh = 11;
  int mesh_size() const;
  private:
  int _internal_mesh_size() const;
  public:
  void clear_mesh();
  ::HmiScenegraph::TMesh* mutable_mesh(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh >*
      mutable_mesh();
  private:
  const ::HmiScenegraph::TMesh& _internal_mesh(int index) const;
  ::HmiScenegraph::TMesh* _internal_add_mesh();
  public:
  const ::HmiScenegraph::TMesh& mesh(int index) const;
  ::HmiScenegraph::TMesh* add_mesh();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh >&
      mesh() const;

  // repeated .HmiScenegraph.TRenderLayer renderLayer = 13;
  int renderlayer_size() const;
  private:
  int _internal_renderlayer_size() const;
  public:
  void clear_renderlayer();
  ::HmiScenegraph::TRenderLayer* mutable_renderlayer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderLayer >*
      mutable_renderlayer();
  private:
  const ::HmiScenegraph::TRenderLayer& _internal_renderlayer(int index) const;
  ::HmiScenegraph::TRenderLayer* _internal_add_renderlayer();
  public:
  const ::HmiScenegraph::TRenderLayer& renderlayer(int index) const;
  ::HmiScenegraph::TRenderLayer* add_renderlayer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderLayer >&
      renderlayer() const;

  // repeated .HmiScenegraph.TNode.TRenderPassName renderPassNameEXT = 21;
  int renderpassnameext_size() const;
  private:
  int _internal_renderpassnameext_size() const;
  public:
  void clear_renderpassnameext();
  ::HmiScenegraph::TNode_TRenderPassName* mutable_renderpassnameext(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode_TRenderPassName >*
      mutable_renderpassnameext();
  private:
  const ::HmiScenegraph::TNode_TRenderPassName& _internal_renderpassnameext(int index) const;
  ::HmiScenegraph::TNode_TRenderPassName* _internal_add_renderpassnameext();
  public:
  const ::HmiScenegraph::TNode_TRenderPassName& renderpassnameext(int index) const;
  ::HmiScenegraph::TNode_TRenderPassName* add_renderpassnameext();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode_TRenderPassName >&
      renderpassnameext() const;

  // repeated .HmiScenegraph.TRenderPass renderPass = 24;
  int renderpass_size() const;
  private:
  int _internal_renderpass_size() const;
  public:
  void clear_renderpass();
  ::HmiScenegraph::TRenderPass* mutable_renderpass(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
      mutable_renderpass();
  private:
  const ::HmiScenegraph::TRenderPass& _internal_renderpass(int index) const;
  ::HmiScenegraph::TRenderPass* _internal_add_renderpass();
  public:
  const ::HmiScenegraph::TRenderPass& renderpass(int index) const;
  ::HmiScenegraph::TRenderPass* add_renderpass();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
      renderpass() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string lookAtTargetName = 14 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lookattargetname() const;
  private:
  bool _internal_has_lookattargetname() const;
  public:
  PROTOBUF_DEPRECATED void clear_lookattargetname();
  PROTOBUF_DEPRECATED const std::string& lookattargetname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_lookattargetname(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_lookattargetname();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_lookattargetname();
  PROTOBUF_DEPRECATED void set_allocated_lookattargetname(std::string* lookattargetname);
  private:
  const std::string& _internal_lookattargetname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lookattargetname(const std::string& value);
  std::string* _internal_mutable_lookattargetname();
  public:

  // optional string renderPassName = 19 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_renderpassname() const;
  private:
  bool _internal_has_renderpassname() const;
  public:
  PROTOBUF_DEPRECATED void clear_renderpassname();
  PROTOBUF_DEPRECATED const std::string& renderpassname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_renderpassname(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_renderpassname();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_renderpassname();
  PROTOBUF_DEPRECATED void set_allocated_renderpassname(std::string* renderpassname);
  private:
  const std::string& _internal_renderpassname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_renderpassname(const std::string& value);
  std::string* _internal_mutable_renderpassname();
  public:

  // required .TVector3f scale = 4;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::TVector3f& scale() const;
  PROTOBUF_NODISCARD ::TVector3f* release_scale();
  ::TVector3f* mutable_scale();
  void set_allocated_scale(::TVector3f* scale);
  private:
  const ::TVector3f& _internal_scale() const;
  ::TVector3f* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::TVector3f* scale);
  ::TVector3f* unsafe_arena_release_scale();

  // required .TVector3f rotation = 5;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::TVector3f& rotation() const;
  PROTOBUF_NODISCARD ::TVector3f* release_rotation();
  ::TVector3f* mutable_rotation();
  void set_allocated_rotation(::TVector3f* rotation);
  private:
  const ::TVector3f& _internal_rotation() const;
  ::TVector3f* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::TVector3f* rotation);
  ::TVector3f* unsafe_arena_release_rotation();

  // required .TVector3f translation = 6;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::TVector3f& translation() const;
  PROTOBUF_NODISCARD ::TVector3f* release_translation();
  ::TVector3f* mutable_translation();
  void set_allocated_translation(::TVector3f* translation);
  private:
  const ::TVector3f& _internal_translation() const;
  ::TVector3f* _internal_mutable_translation();
  public:
  void unsafe_arena_set_allocated_translation(
      ::TVector3f* translation);
  ::TVector3f* unsafe_arena_release_translation();

  // optional .TMatrix4x4f transformation = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_transformation() const;
  private:
  bool _internal_has_transformation() const;
  public:
  PROTOBUF_DEPRECATED void clear_transformation();
  PROTOBUF_DEPRECATED const ::TMatrix4x4f& transformation() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::TMatrix4x4f* release_transformation();
  PROTOBUF_DEPRECATED ::TMatrix4x4f* mutable_transformation();
  PROTOBUF_DEPRECATED void set_allocated_transformation(::TMatrix4x4f* transformation);
  private:
  const ::TMatrix4x4f& _internal_transformation() const;
  ::TMatrix4x4f* _internal_mutable_transformation();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_transformation(
      ::TMatrix4x4f* transformation);
  PROTOBUF_DEPRECATED ::TMatrix4x4f* unsafe_arena_release_transformation();

  // optional .HmiScenegraph.TCamera camera = 12;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::HmiScenegraph::TCamera& camera() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TCamera* release_camera();
  ::HmiScenegraph::TCamera* mutable_camera();
  void set_allocated_camera(::HmiScenegraph::TCamera* camera);
  private:
  const ::HmiScenegraph::TCamera& _internal_camera() const;
  ::HmiScenegraph::TCamera* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::HmiScenegraph::TCamera* camera);
  ::HmiScenegraph::TCamera* unsafe_arena_release_camera();

  // optional .TVector3f lookAtUpVector = 15 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lookatupvector() const;
  private:
  bool _internal_has_lookatupvector() const;
  public:
  PROTOBUF_DEPRECATED void clear_lookatupvector();
  PROTOBUF_DEPRECATED const ::TVector3f& lookatupvector() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::TVector3f* release_lookatupvector();
  PROTOBUF_DEPRECATED ::TVector3f* mutable_lookatupvector();
  PROTOBUF_DEPRECATED void set_allocated_lookatupvector(::TVector3f* lookatupvector);
  private:
  const ::TVector3f& _internal_lookatupvector() const;
  ::TVector3f* _internal_mutable_lookatupvector();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_lookatupvector(
      ::TVector3f* lookatupvector);
  PROTOBUF_DEPRECATED ::TVector3f* unsafe_arena_release_lookatupvector();

  // optional .TIdentifier renderOrderBin = 22;
  bool has_renderorderbin() const;
  private:
  bool _internal_has_renderorderbin() const;
  public:
  void clear_renderorderbin();
  const ::TIdentifier& renderorderbin() const;
  PROTOBUF_NODISCARD ::TIdentifier* release_renderorderbin();
  ::TIdentifier* mutable_renderorderbin();
  void set_allocated_renderorderbin(::TIdentifier* renderorderbin);
  private:
  const ::TIdentifier& _internal_renderorderbin() const;
  ::TIdentifier* _internal_mutable_renderorderbin();
  public:
  void unsafe_arena_set_allocated_renderorderbin(
      ::TIdentifier* renderorderbin);
  ::TIdentifier* unsafe_arena_release_renderorderbin();

  // optional .HmiScenegraph.TBoundingVolume boundingVolume = 23;
  bool has_boundingvolume() const;
  private:
  bool _internal_has_boundingvolume() const;
  public:
  void clear_boundingvolume();
  const ::HmiScenegraph::TBoundingVolume& boundingvolume() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TBoundingVolume* release_boundingvolume();
  ::HmiScenegraph::TBoundingVolume* mutable_boundingvolume();
  void set_allocated_boundingvolume(::HmiScenegraph::TBoundingVolume* boundingvolume);
  private:
  const ::HmiScenegraph::TBoundingVolume& _internal_boundingvolume() const;
  ::HmiScenegraph::TBoundingVolume* _internal_mutable_boundingvolume();
  public:
  void unsafe_arena_set_allocated_boundingvolume(
      ::HmiScenegraph::TBoundingVolume* boundingvolume);
  ::HmiScenegraph::TBoundingVolume* unsafe_arena_release_boundingvolume();

  // optional int32 renderOrder = 2;
  bool has_renderorder() const;
  private:
  bool _internal_has_renderorder() const;
  public:
  void clear_renderorder();
  int32_t renderorder() const;
  void set_renderorder(int32_t value);
  private:
  int32_t _internal_renderorder() const;
  void _internal_set_renderorder(int32_t value);
  public:

  // optional int32 childSortOrderRank = 3;
  bool has_childsortorderrank() const;
  private:
  bool _internal_has_childsortorderrank() const;
  public:
  void clear_childsortorderrank();
  int32_t childsortorderrank() const;
  void set_childsortorderrank(int32_t value);
  private:
  int32_t _internal_childsortorderrank() const;
  void _internal_set_childsortorderrank(int32_t value);
  public:

  // optional .HmiScenegraph.TEAxis lookAtUpAxis = 16 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lookatupaxis() const;
  private:
  bool _internal_has_lookatupaxis() const;
  public:
  PROTOBUF_DEPRECATED void clear_lookatupaxis();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TEAxis lookatupaxis() const;
  PROTOBUF_DEPRECATED void set_lookatupaxis(::HmiScenegraph::TEAxis value);
  private:
  ::HmiScenegraph::TEAxis _internal_lookatupaxis() const;
  void _internal_set_lookatupaxis(::HmiScenegraph::TEAxis value);
  public:

  // optional .HmiScenegraph.TEAxis lookAtForwardAxis = 17 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lookatforwardaxis() const;
  private:
  bool _internal_has_lookatforwardaxis() const;
  public:
  PROTOBUF_DEPRECATED void clear_lookatforwardaxis();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TEAxis lookatforwardaxis() const;
  PROTOBUF_DEPRECATED void set_lookatforwardaxis(::HmiScenegraph::TEAxis value);
  private:
  ::HmiScenegraph::TEAxis _internal_lookatforwardaxis() const;
  void _internal_set_lookatforwardaxis(::HmiScenegraph::TEAxis value);
  public:

  // optional .HmiScenegraph.TEAxis lookAtAlignToTargetAxis = 18 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lookataligntotargetaxis() const;
  private:
  bool _internal_has_lookataligntotargetaxis() const;
  public:
  PROTOBUF_DEPRECATED void clear_lookataligntotargetaxis();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TEAxis lookataligntotargetaxis() const;
  PROTOBUF_DEPRECATED void set_lookataligntotargetaxis(::HmiScenegraph::TEAxis value);
  private:
  ::HmiScenegraph::TEAxis _internal_lookataligntotargetaxis() const;
  void _internal_set_lookataligntotargetaxis(::HmiScenegraph::TEAxis value);
  public:

  // optional bool renderPassEnabled = 20 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_renderpassenabled() const;
  private:
  bool _internal_has_renderpassenabled() const;
  public:
  PROTOBUF_DEPRECATED void clear_renderpassenabled();
  PROTOBUF_DEPRECATED bool renderpassenabled() const;
  PROTOBUF_DEPRECATED void set_renderpassenabled(bool value);
  private:
  bool _internal_renderpassenabled() const;
  void _internal_set_renderpassenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode > child_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh > mesh_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderLayer > renderlayer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode_TRenderPassName > renderpassnameext_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass > renderpass_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lookattargetname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr renderpassname_;
    ::TVector3f* scale_;
    ::TVector3f* rotation_;
    ::TVector3f* translation_;
    ::TMatrix4x4f* transformation_;
    ::HmiScenegraph::TCamera* camera_;
    ::TVector3f* lookatupvector_;
    ::TIdentifier* renderorderbin_;
    ::HmiScenegraph::TBoundingVolume* boundingvolume_;
    int32_t renderorder_;
    int32_t childsortorderrank_;
    int lookatupaxis_;
    int lookatforwardaxis_;
    int lookataligntotargetaxis_;
    bool renderpassenabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderOrder final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderOrder) */ {
 public:
  inline TRenderOrder() : TRenderOrder(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TRenderOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderOrder(const TRenderOrder& from);
  TRenderOrder(TRenderOrder&& from) noexcept
    : TRenderOrder() {
    *this = ::std::move(from);
  }

  inline TRenderOrder& operator=(const TRenderOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderOrder& operator=(TRenderOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderOrder* internal_default_instance() {
    return reinterpret_cast<const TRenderOrder*>(
               &_TRenderOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TRenderOrder& a, TRenderOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TRenderOrder& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TRenderOrder& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderOrder";
  }
  protected:
  explicit TRenderOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderOrderBin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderOrderBin) */ {
 public:
  inline TRenderOrderBin() : TRenderOrderBin(nullptr) {}
  ~TRenderOrderBin() override;
  explicit PROTOBUF_CONSTEXPR TRenderOrderBin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderOrderBin(const TRenderOrderBin& from);
  TRenderOrderBin(TRenderOrderBin&& from) noexcept
    : TRenderOrderBin() {
    *this = ::std::move(from);
  }

  inline TRenderOrderBin& operator=(const TRenderOrderBin& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderOrderBin& operator=(TRenderOrderBin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderOrderBin& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderOrderBin* internal_default_instance() {
    return reinterpret_cast<const TRenderOrderBin*>(
               &_TRenderOrderBin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TRenderOrderBin& a, TRenderOrderBin& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderOrderBin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderOrderBin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderOrderBin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderOrderBin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderOrderBin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderOrderBin& from) {
    TRenderOrderBin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderOrderBin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderOrderBin";
  }
  protected:
  explicit TRenderOrderBin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRenderOrderRankFieldNumber = 2,
    kSortOrderFieldNumber = 3,
  };
  // optional .TIdentifier name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::TIdentifier& name() const;
  PROTOBUF_NODISCARD ::TIdentifier* release_name();
  ::TIdentifier* mutable_name();
  void set_allocated_name(::TIdentifier* name);
  private:
  const ::TIdentifier& _internal_name() const;
  ::TIdentifier* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::TIdentifier* name);
  ::TIdentifier* unsafe_arena_release_name();

  // optional int32 renderOrderRank = 2 [default = 0];
  bool has_renderorderrank() const;
  private:
  bool _internal_has_renderorderrank() const;
  public:
  void clear_renderorderrank();
  int32_t renderorderrank() const;
  void set_renderorderrank(int32_t value);
  private:
  int32_t _internal_renderorderrank() const;
  void _internal_set_renderorderrank(int32_t value);
  public:

  // optional .HmiScenegraph.TERenderBinSortOrder sortOrder = 3 [default = TERenderBinSortOrder_ChildSortOrder];
  bool has_sortorder() const;
  private:
  bool _internal_has_sortorder() const;
  public:
  void clear_sortorder();
  ::HmiScenegraph::TERenderBinSortOrder sortorder() const;
  void set_sortorder(::HmiScenegraph::TERenderBinSortOrder value);
  private:
  ::HmiScenegraph::TERenderBinSortOrder _internal_sortorder() const;
  void _internal_set_sortorder(::HmiScenegraph::TERenderBinSortOrder value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderOrderBin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TIdentifier* name_;
    int32_t renderorderrank_;
    int sortorder_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderTarget) */ {
 public:
  inline TRenderTarget() : TRenderTarget(nullptr) {}
  ~TRenderTarget() override;
  explicit PROTOBUF_CONSTEXPR TRenderTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderTarget(const TRenderTarget& from);
  TRenderTarget(TRenderTarget&& from) noexcept
    : TRenderTarget() {
    *this = ::std::move(from);
  }

  inline TRenderTarget& operator=(const TRenderTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderTarget& operator=(TRenderTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderTarget* internal_default_instance() {
    return reinterpret_cast<const TRenderTarget*>(
               &_TRenderTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TRenderTarget& a, TRenderTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderTarget& from) {
    TRenderTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderTarget";
  }
  protected:
  explicit TRenderTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorBufferFieldNumber = 4,
    kDepthBufferFieldNumber = 5,
    kStencilBufferFieldNumber = 6,
    kNameFieldNumber = 12,
    kDiscardFramebufferFieldNumber = 7,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kSamplesFieldNumber = 3,
    kSemanticWidthFieldNumber = 8,
    kSemanticHeightFieldNumber = 9,
    kSemanticDepthFieldNumber = 10,
    kResolutionMultiplierFieldNumber = 11,
    kScopeFieldNumber = 14,
  };
  // repeated string colorBuffer = 4;
  int colorbuffer_size() const;
  private:
  int _internal_colorbuffer_size() const;
  public:
  void clear_colorbuffer();
  const std::string& colorbuffer(int index) const;
  std::string* mutable_colorbuffer(int index);
  void set_colorbuffer(int index, const std::string& value);
  void set_colorbuffer(int index, std::string&& value);
  void set_colorbuffer(int index, const char* value);
  void set_colorbuffer(int index, const char* value, size_t size);
  std::string* add_colorbuffer();
  void add_colorbuffer(const std::string& value);
  void add_colorbuffer(std::string&& value);
  void add_colorbuffer(const char* value);
  void add_colorbuffer(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& colorbuffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_colorbuffer();
  private:
  const std::string& _internal_colorbuffer(int index) const;
  std::string* _internal_add_colorbuffer();
  public:

  // optional string depthBuffer = 5;
  bool has_depthbuffer() const;
  private:
  bool _internal_has_depthbuffer() const;
  public:
  void clear_depthbuffer();
  const std::string& depthbuffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depthbuffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depthbuffer();
  PROTOBUF_NODISCARD std::string* release_depthbuffer();
  void set_allocated_depthbuffer(std::string* depthbuffer);
  private:
  const std::string& _internal_depthbuffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_depthbuffer(const std::string& value);
  std::string* _internal_mutable_depthbuffer();
  public:

  // optional string stencilBuffer = 6;
  bool has_stencilbuffer() const;
  private:
  bool _internal_has_stencilbuffer() const;
  public:
  void clear_stencilbuffer();
  const std::string& stencilbuffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stencilbuffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stencilbuffer();
  PROTOBUF_NODISCARD std::string* release_stencilbuffer();
  void set_allocated_stencilbuffer(std::string* stencilbuffer);
  private:
  const std::string& _internal_stencilbuffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stencilbuffer(const std::string& value);
  std::string* _internal_mutable_stencilbuffer();
  public:

  // optional string name = 12;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .HmiScenegraph.TDiscardFramebuffer discardFramebuffer = 7;
  bool has_discardframebuffer() const;
  private:
  bool _internal_has_discardframebuffer() const;
  public:
  void clear_discardframebuffer();
  const ::HmiScenegraph::TDiscardFramebuffer& discardframebuffer() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TDiscardFramebuffer* release_discardframebuffer();
  ::HmiScenegraph::TDiscardFramebuffer* mutable_discardframebuffer();
  void set_allocated_discardframebuffer(::HmiScenegraph::TDiscardFramebuffer* discardframebuffer);
  private:
  const ::HmiScenegraph::TDiscardFramebuffer& _internal_discardframebuffer() const;
  ::HmiScenegraph::TDiscardFramebuffer* _internal_mutable_discardframebuffer();
  public:
  void unsafe_arena_set_allocated_discardframebuffer(
      ::HmiScenegraph::TDiscardFramebuffer* discardframebuffer);
  ::HmiScenegraph::TDiscardFramebuffer* unsafe_arena_release_discardframebuffer();

  // optional uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional int32 samples = 3 [default = 0];
  bool has_samples() const;
  private:
  bool _internal_has_samples() const;
  public:
  void clear_samples();
  int32_t samples() const;
  void set_samples(int32_t value);
  private:
  int32_t _internal_samples() const;
  void _internal_set_samples(int32_t value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticWidth = 8;
  bool has_semanticwidth() const;
  private:
  bool _internal_has_semanticwidth() const;
  public:
  void clear_semanticwidth();
  ::HmiScenegraph::TESemanticValue semanticwidth() const;
  void set_semanticwidth(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticwidth() const;
  void _internal_set_semanticwidth(::HmiScenegraph::TESemanticValue value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticHeight = 9;
  bool has_semanticheight() const;
  private:
  bool _internal_has_semanticheight() const;
  public:
  void clear_semanticheight();
  ::HmiScenegraph::TESemanticValue semanticheight() const;
  void set_semanticheight(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticheight() const;
  void _internal_set_semanticheight(::HmiScenegraph::TESemanticValue value);
  public:

  // optional .HmiScenegraph.TESemanticValue semanticDepth = 10;
  bool has_semanticdepth() const;
  private:
  bool _internal_has_semanticdepth() const;
  public:
  void clear_semanticdepth();
  ::HmiScenegraph::TESemanticValue semanticdepth() const;
  void set_semanticdepth(::HmiScenegraph::TESemanticValue value);
  private:
  ::HmiScenegraph::TESemanticValue _internal_semanticdepth() const;
  void _internal_set_semanticdepth(::HmiScenegraph::TESemanticValue value);
  public:

  // optional float resolutionMultiplier = 11;
  bool has_resolutionmultiplier() const;
  private:
  bool _internal_has_resolutionmultiplier() const;
  public:
  void clear_resolutionmultiplier();
  float resolutionmultiplier() const;
  void set_resolutionmultiplier(float value);
  private:
  float _internal_resolutionmultiplier() const;
  void _internal_set_resolutionmultiplier(float value);
  public:

  // optional .TEScope scope = 14;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> colorbuffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depthbuffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stencilbuffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::HmiScenegraph::TDiscardFramebuffer* discardframebuffer_;
    uint32_t width_;
    uint32_t height_;
    int32_t samples_;
    int semanticwidth_;
    int semanticheight_;
    int semanticdepth_;
    float resolutionmultiplier_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TClearMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TClearMode) */ {
 public:
  inline TClearMode() : TClearMode(nullptr) {}
  ~TClearMode() override;
  explicit PROTOBUF_CONSTEXPR TClearMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TClearMode(const TClearMode& from);
  TClearMode(TClearMode&& from) noexcept
    : TClearMode() {
    *this = ::std::move(from);
  }

  inline TClearMode& operator=(const TClearMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TClearMode& operator=(TClearMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TClearMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TClearMode* internal_default_instance() {
    return reinterpret_cast<const TClearMode*>(
               &_TClearMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TClearMode& a, TClearMode& b) {
    a.Swap(&b);
  }
  inline void Swap(TClearMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TClearMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TClearMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TClearMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TClearMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TClearMode& from) {
    TClearMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TClearMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TClearMode";
  }
  protected:
  explicit TClearMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClearColorFieldNumber = 1,
    kClearDepthFieldNumber = 2,
    kClearStencilFieldNumber = 3,
  };
  // optional fixed32 clearColor = 1;
  bool has_clearcolor() const;
  private:
  bool _internal_has_clearcolor() const;
  public:
  void clear_clearcolor();
  uint32_t clearcolor() const;
  void set_clearcolor(uint32_t value);
  private:
  uint32_t _internal_clearcolor() const;
  void _internal_set_clearcolor(uint32_t value);
  public:

  // optional float clearDepth = 2;
  bool has_cleardepth() const;
  private:
  bool _internal_has_cleardepth() const;
  public:
  void clear_cleardepth();
  float cleardepth() const;
  void set_cleardepth(float value);
  private:
  float _internal_cleardepth() const;
  void _internal_set_cleardepth(float value);
  public:

  // optional fixed32 clearStencil = 3;
  bool has_clearstencil() const;
  private:
  bool _internal_has_clearstencil() const;
  public:
  void clear_clearstencil();
  uint32_t clearstencil() const;
  void set_clearstencil(uint32_t value);
  private:
  uint32_t _internal_clearstencil() const;
  void _internal_set_clearstencil(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TClearMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t clearcolor_;
    float cleardepth_;
    uint32_t clearstencil_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TDiscardFramebuffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TDiscardFramebuffer) */ {
 public:
  inline TDiscardFramebuffer() : TDiscardFramebuffer(nullptr) {}
  ~TDiscardFramebuffer() override;
  explicit PROTOBUF_CONSTEXPR TDiscardFramebuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TDiscardFramebuffer(const TDiscardFramebuffer& from);
  TDiscardFramebuffer(TDiscardFramebuffer&& from) noexcept
    : TDiscardFramebuffer() {
    *this = ::std::move(from);
  }

  inline TDiscardFramebuffer& operator=(const TDiscardFramebuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TDiscardFramebuffer& operator=(TDiscardFramebuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TDiscardFramebuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TDiscardFramebuffer* internal_default_instance() {
    return reinterpret_cast<const TDiscardFramebuffer*>(
               &_TDiscardFramebuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TDiscardFramebuffer& a, TDiscardFramebuffer& b) {
    a.Swap(&b);
  }
  inline void Swap(TDiscardFramebuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TDiscardFramebuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TDiscardFramebuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TDiscardFramebuffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TDiscardFramebuffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TDiscardFramebuffer& from) {
    TDiscardFramebuffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TDiscardFramebuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TDiscardFramebuffer";
  }
  protected:
  explicit TDiscardFramebuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kDepthFieldNumber = 2,
    kStencilFieldNumber = 3,
  };
  // optional bool color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  bool color() const;
  void set_color(bool value);
  private:
  bool _internal_color() const;
  void _internal_set_color(bool value);
  public:

  // optional bool depth = 2;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  bool depth() const;
  void set_depth(bool value);
  private:
  bool _internal_depth() const;
  void _internal_set_depth(bool value);
  public:

  // optional bool stencil = 3;
  bool has_stencil() const;
  private:
  bool _internal_has_stencil() const;
  public:
  void clear_stencil();
  bool stencil() const;
  void set_stencil(bool value);
  private:
  bool _internal_stencil() const;
  void _internal_set_stencil(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TDiscardFramebuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool color_;
    bool depth_;
    bool stencil_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TRenderPass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TRenderPass) */ {
 public:
  inline TRenderPass() : TRenderPass(nullptr) {}
  ~TRenderPass() override;
  explicit PROTOBUF_CONSTEXPR TRenderPass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TRenderPass(const TRenderPass& from);
  TRenderPass(TRenderPass&& from) noexcept
    : TRenderPass() {
    *this = ::std::move(from);
  }

  inline TRenderPass& operator=(const TRenderPass& from) {
    CopyFrom(from);
    return *this;
  }
  inline TRenderPass& operator=(TRenderPass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TRenderPass& default_instance() {
    return *internal_default_instance();
  }
  static inline const TRenderPass* internal_default_instance() {
    return reinterpret_cast<const TRenderPass*>(
               &_TRenderPass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TRenderPass& a, TRenderPass& b) {
    a.Swap(&b);
  }
  inline void Swap(TRenderPass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TRenderPass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TRenderPass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TRenderPass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TRenderPass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TRenderPass& from) {
    TRenderPass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TRenderPass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TRenderPass";
  }
  protected:
  explicit TRenderPass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRenderOrderBinFieldNumber = 12,
    kNameFieldNumber = 1,
    kCameraNameFieldNumber = 6,
    kRenderTargetReferenceFieldNumber = 11,
    kRenderOrderFieldNumber = 3,
    kRenderTargetFieldNumber = 4,
    kClearModeFieldNumber = 5,
    kViewportFieldNumber = 7,
    kRankFieldNumber = 2,
    kViewFrustumCullingEnabledFieldNumber = 8,
    kScopeMaskFieldNumber = 9,
    kScopeFieldNumber = 10,
  };
  // repeated .HmiScenegraph.TRenderOrderBin renderOrderBin = 12;
  int renderorderbin_size() const;
  private:
  int _internal_renderorderbin_size() const;
  public:
  void clear_renderorderbin();
  ::HmiScenegraph::TRenderOrderBin* mutable_renderorderbin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderOrderBin >*
      mutable_renderorderbin();
  private:
  const ::HmiScenegraph::TRenderOrderBin& _internal_renderorderbin(int index) const;
  ::HmiScenegraph::TRenderOrderBin* _internal_add_renderorderbin();
  public:
  const ::HmiScenegraph::TRenderOrderBin& renderorderbin(int index) const;
  ::HmiScenegraph::TRenderOrderBin* add_renderorderbin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderOrderBin >&
      renderorderbin() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string cameraName = 6;
  bool has_cameraname() const;
  private:
  bool _internal_has_cameraname() const;
  public:
  void clear_cameraname();
  const std::string& cameraname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cameraname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cameraname();
  PROTOBUF_NODISCARD std::string* release_cameraname();
  void set_allocated_cameraname(std::string* cameraname);
  private:
  const std::string& _internal_cameraname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cameraname(const std::string& value);
  std::string* _internal_mutable_cameraname();
  public:

  // optional string renderTargetReference = 11;
  bool has_rendertargetreference() const;
  private:
  bool _internal_has_rendertargetreference() const;
  public:
  void clear_rendertargetreference();
  const std::string& rendertargetreference() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rendertargetreference(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rendertargetreference();
  PROTOBUF_NODISCARD std::string* release_rendertargetreference();
  void set_allocated_rendertargetreference(std::string* rendertargetreference);
  private:
  const std::string& _internal_rendertargetreference() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rendertargetreference(const std::string& value);
  std::string* _internal_mutable_rendertargetreference();
  public:

  // optional .HmiScenegraph.TRenderOrder renderOrder = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_renderorder() const;
  private:
  bool _internal_has_renderorder() const;
  public:
  PROTOBUF_DEPRECATED void clear_renderorder();
  PROTOBUF_DEPRECATED const ::HmiScenegraph::TRenderOrder& renderorder() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::HmiScenegraph::TRenderOrder* release_renderorder();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TRenderOrder* mutable_renderorder();
  PROTOBUF_DEPRECATED void set_allocated_renderorder(::HmiScenegraph::TRenderOrder* renderorder);
  private:
  const ::HmiScenegraph::TRenderOrder& _internal_renderorder() const;
  ::HmiScenegraph::TRenderOrder* _internal_mutable_renderorder();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_renderorder(
      ::HmiScenegraph::TRenderOrder* renderorder);
  PROTOBUF_DEPRECATED ::HmiScenegraph::TRenderOrder* unsafe_arena_release_renderorder();

  // optional .HmiScenegraph.TRenderTarget renderTarget = 4;
  bool has_rendertarget() const;
  private:
  bool _internal_has_rendertarget() const;
  public:
  void clear_rendertarget();
  const ::HmiScenegraph::TRenderTarget& rendertarget() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TRenderTarget* release_rendertarget();
  ::HmiScenegraph::TRenderTarget* mutable_rendertarget();
  void set_allocated_rendertarget(::HmiScenegraph::TRenderTarget* rendertarget);
  private:
  const ::HmiScenegraph::TRenderTarget& _internal_rendertarget() const;
  ::HmiScenegraph::TRenderTarget* _internal_mutable_rendertarget();
  public:
  void unsafe_arena_set_allocated_rendertarget(
      ::HmiScenegraph::TRenderTarget* rendertarget);
  ::HmiScenegraph::TRenderTarget* unsafe_arena_release_rendertarget();

  // optional .HmiScenegraph.TClearMode clearMode = 5;
  bool has_clearmode() const;
  private:
  bool _internal_has_clearmode() const;
  public:
  void clear_clearmode();
  const ::HmiScenegraph::TClearMode& clearmode() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TClearMode* release_clearmode();
  ::HmiScenegraph::TClearMode* mutable_clearmode();
  void set_allocated_clearmode(::HmiScenegraph::TClearMode* clearmode);
  private:
  const ::HmiScenegraph::TClearMode& _internal_clearmode() const;
  ::HmiScenegraph::TClearMode* _internal_mutable_clearmode();
  public:
  void unsafe_arena_set_allocated_clearmode(
      ::HmiScenegraph::TClearMode* clearmode);
  ::HmiScenegraph::TClearMode* unsafe_arena_release_clearmode();

  // optional .TVector4f viewport = 7;
  bool has_viewport() const;
  private:
  bool _internal_has_viewport() const;
  public:
  void clear_viewport();
  const ::TVector4f& viewport() const;
  PROTOBUF_NODISCARD ::TVector4f* release_viewport();
  ::TVector4f* mutable_viewport();
  void set_allocated_viewport(::TVector4f* viewport);
  private:
  const ::TVector4f& _internal_viewport() const;
  ::TVector4f* _internal_mutable_viewport();
  public:
  void unsafe_arena_set_allocated_viewport(
      ::TVector4f* viewport);
  ::TVector4f* unsafe_arena_release_viewport();

  // optional uint32 rank = 2;
  bool has_rank() const;
  private:
  bool _internal_has_rank() const;
  public:
  void clear_rank();
  uint32_t rank() const;
  void set_rank(uint32_t value);
  private:
  uint32_t _internal_rank() const;
  void _internal_set_rank(uint32_t value);
  public:

  // optional bool viewFrustumCullingEnabled = 8 [default = false];
  bool has_viewfrustumcullingenabled() const;
  private:
  bool _internal_has_viewfrustumcullingenabled() const;
  public:
  void clear_viewfrustumcullingenabled();
  bool viewfrustumcullingenabled() const;
  void set_viewfrustumcullingenabled(bool value);
  private:
  bool _internal_viewfrustumcullingenabled() const;
  void _internal_set_viewfrustumcullingenabled(bool value);
  public:

  // optional fixed32 scopeMask = 9 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_scopemask() const;
  private:
  bool _internal_has_scopemask() const;
  public:
  PROTOBUF_DEPRECATED void clear_scopemask();
  PROTOBUF_DEPRECATED uint32_t scopemask() const;
  PROTOBUF_DEPRECATED void set_scopemask(uint32_t value);
  private:
  uint32_t _internal_scopemask() const;
  void _internal_set_scopemask(uint32_t value);
  public:

  // optional .TEScope scope = 10;
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  ::TEScope scope() const;
  void set_scope(::TEScope value);
  private:
  ::TEScope _internal_scope() const;
  void _internal_set_scope(::TEScope value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TRenderPass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderOrderBin > renderorderbin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cameraname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rendertargetreference_;
    ::HmiScenegraph::TRenderOrder* renderorder_;
    ::HmiScenegraph::TRenderTarget* rendertarget_;
    ::HmiScenegraph::TClearMode* clearmode_;
    ::TVector4f* viewport_;
    uint32_t rank_;
    bool viewfrustumcullingenabled_;
    uint32_t scopemask_;
    int scope_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TBlitPass final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TBlitPass) */ {
 public:
  inline TBlitPass() : TBlitPass(nullptr) {}
  ~TBlitPass() override;
  explicit PROTOBUF_CONSTEXPR TBlitPass(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TBlitPass(const TBlitPass& from);
  TBlitPass(TBlitPass&& from) noexcept
    : TBlitPass() {
    *this = ::std::move(from);
  }

  inline TBlitPass& operator=(const TBlitPass& from) {
    CopyFrom(from);
    return *this;
  }
  inline TBlitPass& operator=(TBlitPass&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TBlitPass& default_instance() {
    return *internal_default_instance();
  }
  static inline const TBlitPass* internal_default_instance() {
    return reinterpret_cast<const TBlitPass*>(
               &_TBlitPass_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TBlitPass& a, TBlitPass& b) {
    a.Swap(&b);
  }
  inline void Swap(TBlitPass* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TBlitPass* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TBlitPass* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TBlitPass>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TBlitPass& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TBlitPass& from) {
    TBlitPass::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TBlitPass* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TBlitPass";
  }
  protected:
  explicit TBlitPass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceRenderBufferFieldNumber = 3,
    kDestinationRenderBufferFieldNumber = 4,
    kRankFieldNumber = 2,
    kRegionWidthFieldNumber = 5,
    kRegionHeightFieldNumber = 6,
    kRegionSourceXFieldNumber = 7,
    kRegionSourceYFieldNumber = 8,
    kRegionDestinationXFieldNumber = 9,
    kRegionDestinationYFieldNumber = 10,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string sourceRenderBuffer = 3;
  bool has_sourcerenderbuffer() const;
  private:
  bool _internal_has_sourcerenderbuffer() const;
  public:
  void clear_sourcerenderbuffer();
  const std::string& sourcerenderbuffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcerenderbuffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcerenderbuffer();
  PROTOBUF_NODISCARD std::string* release_sourcerenderbuffer();
  void set_allocated_sourcerenderbuffer(std::string* sourcerenderbuffer);
  private:
  const std::string& _internal_sourcerenderbuffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcerenderbuffer(const std::string& value);
  std::string* _internal_mutable_sourcerenderbuffer();
  public:

  // optional string destinationRenderBuffer = 4;
  bool has_destinationrenderbuffer() const;
  private:
  bool _internal_has_destinationrenderbuffer() const;
  public:
  void clear_destinationrenderbuffer();
  const std::string& destinationrenderbuffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destinationrenderbuffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destinationrenderbuffer();
  PROTOBUF_NODISCARD std::string* release_destinationrenderbuffer();
  void set_allocated_destinationrenderbuffer(std::string* destinationrenderbuffer);
  private:
  const std::string& _internal_destinationrenderbuffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destinationrenderbuffer(const std::string& value);
  std::string* _internal_mutable_destinationrenderbuffer();
  public:

  // optional uint32 rank = 2;
  bool has_rank() const;
  private:
  bool _internal_has_rank() const;
  public:
  void clear_rank();
  uint32_t rank() const;
  void set_rank(uint32_t value);
  private:
  uint32_t _internal_rank() const;
  void _internal_set_rank(uint32_t value);
  public:

  // optional uint32 regionWidth = 5;
  bool has_regionwidth() const;
  private:
  bool _internal_has_regionwidth() const;
  public:
  void clear_regionwidth();
  uint32_t regionwidth() const;
  void set_regionwidth(uint32_t value);
  private:
  uint32_t _internal_regionwidth() const;
  void _internal_set_regionwidth(uint32_t value);
  public:

  // optional uint32 regionHeight = 6;
  bool has_regionheight() const;
  private:
  bool _internal_has_regionheight() const;
  public:
  void clear_regionheight();
  uint32_t regionheight() const;
  void set_regionheight(uint32_t value);
  private:
  uint32_t _internal_regionheight() const;
  void _internal_set_regionheight(uint32_t value);
  public:

  // optional uint32 regionSourceX = 7 [default = 0];
  bool has_regionsourcex() const;
  private:
  bool _internal_has_regionsourcex() const;
  public:
  void clear_regionsourcex();
  uint32_t regionsourcex() const;
  void set_regionsourcex(uint32_t value);
  private:
  uint32_t _internal_regionsourcex() const;
  void _internal_set_regionsourcex(uint32_t value);
  public:

  // optional uint32 regionSourceY = 8 [default = 0];
  bool has_regionsourcey() const;
  private:
  bool _internal_has_regionsourcey() const;
  public:
  void clear_regionsourcey();
  uint32_t regionsourcey() const;
  void set_regionsourcey(uint32_t value);
  private:
  uint32_t _internal_regionsourcey() const;
  void _internal_set_regionsourcey(uint32_t value);
  public:

  // optional uint32 regionDestinationX = 9 [default = 0];
  bool has_regiondestinationx() const;
  private:
  bool _internal_has_regiondestinationx() const;
  public:
  void clear_regiondestinationx();
  uint32_t regiondestinationx() const;
  void set_regiondestinationx(uint32_t value);
  private:
  uint32_t _internal_regiondestinationx() const;
  void _internal_set_regiondestinationx(uint32_t value);
  public:

  // optional uint32 regionDestinationY = 10 [default = 0];
  bool has_regiondestinationy() const;
  private:
  bool _internal_has_regiondestinationy() const;
  public:
  void clear_regiondestinationy();
  uint32_t regiondestinationy() const;
  void set_regiondestinationy(uint32_t value);
  private:
  uint32_t _internal_regiondestinationy() const;
  void _internal_set_regiondestinationy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TBlitPass)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcerenderbuffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destinationrenderbuffer_;
    uint32_t rank_;
    uint32_t regionwidth_;
    uint32_t regionheight_;
    uint32_t regionsourcex_;
    uint32_t regionsourcey_;
    uint32_t regiondestinationx_;
    uint32_t regiondestinationy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TGeometry_TAttributeParamteter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TGeometry.TAttributeParamteter) */ {
 public:
  inline TGeometry_TAttributeParamteter() : TGeometry_TAttributeParamteter(nullptr) {}
  ~TGeometry_TAttributeParamteter() override;
  explicit PROTOBUF_CONSTEXPR TGeometry_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TGeometry_TAttributeParamteter(const TGeometry_TAttributeParamteter& from);
  TGeometry_TAttributeParamteter(TGeometry_TAttributeParamteter&& from) noexcept
    : TGeometry_TAttributeParamteter() {
    *this = ::std::move(from);
  }

  inline TGeometry_TAttributeParamteter& operator=(const TGeometry_TAttributeParamteter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TGeometry_TAttributeParamteter& operator=(TGeometry_TAttributeParamteter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TGeometry_TAttributeParamteter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TGeometry_TAttributeParamteter* internal_default_instance() {
    return reinterpret_cast<const TGeometry_TAttributeParamteter*>(
               &_TGeometry_TAttributeParamteter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TGeometry_TAttributeParamteter& a, TGeometry_TAttributeParamteter& b) {
    a.Swap(&b);
  }
  inline void Swap(TGeometry_TAttributeParamteter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TGeometry_TAttributeParamteter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TGeometry_TAttributeParamteter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TGeometry_TAttributeParamteter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TGeometry_TAttributeParamteter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TGeometry_TAttributeParamteter& from) {
    TGeometry_TAttributeParamteter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGeometry_TAttributeParamteter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TGeometry.TAttributeParamteter";
  }
  protected:
  explicit TGeometry_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCacheIdFieldNumber = 6,
    kPrecisionFieldNumber = 2,
    kUsageIndexFieldNumber = 5,
    kSizeFieldNumber = 3,
    kSemanticFieldNumber = 4,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .HmiScenegraph.TResourceCacheId cacheId = 6;
  bool has_cacheid() const;
  private:
  bool _internal_has_cacheid() const;
  public:
  void clear_cacheid();
  const ::HmiScenegraph::TResourceCacheId& cacheid() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TResourceCacheId* release_cacheid();
  ::HmiScenegraph::TResourceCacheId* mutable_cacheid();
  void set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid);
  private:
  const ::HmiScenegraph::TResourceCacheId& _internal_cacheid() const;
  ::HmiScenegraph::TResourceCacheId* _internal_mutable_cacheid();
  public:
  void unsafe_arena_set_allocated_cacheid(
      ::HmiScenegraph::TResourceCacheId* cacheid);
  ::HmiScenegraph::TResourceCacheId* unsafe_arena_release_cacheid();

  // optional .HmiScenegraph.TEAttributePrecision precision = 2;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  ::HmiScenegraph::TEAttributePrecision precision() const;
  void set_precision(::HmiScenegraph::TEAttributePrecision value);
  private:
  ::HmiScenegraph::TEAttributePrecision _internal_precision() const;
  void _internal_set_precision(::HmiScenegraph::TEAttributePrecision value);
  public:

  // optional uint32 usageIndex = 5;
  bool has_usageindex() const;
  private:
  bool _internal_has_usageindex() const;
  public:
  void clear_usageindex();
  uint32_t usageindex() const;
  void set_usageindex(uint32_t value);
  private:
  uint32_t _internal_usageindex() const;
  void _internal_set_usageindex(uint32_t value);
  public:

  // optional .HmiScenegraph.TEAttributeSize size = 3;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::HmiScenegraph::TEAttributeSize size() const;
  void set_size(::HmiScenegraph::TEAttributeSize value);
  private:
  ::HmiScenegraph::TEAttributeSize _internal_size() const;
  void _internal_set_size(::HmiScenegraph::TEAttributeSize value);
  public:

  // optional .HmiScenegraph.TEAttributeSemantic semantic = 4;
  bool has_semantic() const;
  private:
  bool _internal_has_semantic() const;
  public:
  void clear_semantic();
  ::HmiScenegraph::TEAttributeSemantic semantic() const;
  void set_semantic(::HmiScenegraph::TEAttributeSemantic value);
  private:
  ::HmiScenegraph::TEAttributeSemantic _internal_semantic() const;
  void _internal_set_semantic(::HmiScenegraph::TEAttributeSemantic value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TGeometry.TAttributeParamteter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::HmiScenegraph::TResourceCacheId* cacheid_;
    int precision_;
    uint32_t usageindex_;
    int size_;
    int semantic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TGeometry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TGeometry) */ {
 public:
  inline TGeometry() : TGeometry(nullptr) {}
  ~TGeometry() override;
  explicit PROTOBUF_CONSTEXPR TGeometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TGeometry(const TGeometry& from);
  TGeometry(TGeometry&& from) noexcept
    : TGeometry() {
    *this = ::std::move(from);
  }

  inline TGeometry& operator=(const TGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TGeometry& operator=(TGeometry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TGeometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TGeometry* internal_default_instance() {
    return reinterpret_cast<const TGeometry*>(
               &_TGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TGeometry& a, TGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(TGeometry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TGeometry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TGeometry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TGeometry& from) {
    TGeometry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TGeometry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TGeometry";
  }
  protected:
  explicit TGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TGeometry_TAttributeParamteter TAttributeParamteter;

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeParameterFieldNumber = 3,
    kNameFieldNumber = 1,
    kResourceFieldNumber = 2,
    kIndexDataCacheIdFieldNumber = 8,
    kVertexCountFieldNumber = 4,
    kPrimitiveCountFieldNumber = 5,
    kPrimitiveTypeFieldNumber = 6,
  };
  // repeated .HmiScenegraph.TGeometry.TAttributeParamteter attributeParameter = 3;
  int attributeparameter_size() const;
  private:
  int _internal_attributeparameter_size() const;
  public:
  void clear_attributeparameter();
  ::HmiScenegraph::TGeometry_TAttributeParamteter* mutable_attributeparameter(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry_TAttributeParamteter >*
      mutable_attributeparameter();
  private:
  const ::HmiScenegraph::TGeometry_TAttributeParamteter& _internal_attributeparameter(int index) const;
  ::HmiScenegraph::TGeometry_TAttributeParamteter* _internal_add_attributeparameter();
  public:
  const ::HmiScenegraph::TGeometry_TAttributeParamteter& attributeparameter(int index) const;
  ::HmiScenegraph::TGeometry_TAttributeParamteter* add_attributeparameter();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry_TAttributeParamteter >&
      attributeparameter() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string resource = 2;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const std::string& resource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource();
  PROTOBUF_NODISCARD std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // optional .HmiScenegraph.TResourceCacheId indexDataCacheId = 8;
  bool has_indexdatacacheid() const;
  private:
  bool _internal_has_indexdatacacheid() const;
  public:
  void clear_indexdatacacheid();
  const ::HmiScenegraph::TResourceCacheId& indexdatacacheid() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TResourceCacheId* release_indexdatacacheid();
  ::HmiScenegraph::TResourceCacheId* mutable_indexdatacacheid();
  void set_allocated_indexdatacacheid(::HmiScenegraph::TResourceCacheId* indexdatacacheid);
  private:
  const ::HmiScenegraph::TResourceCacheId& _internal_indexdatacacheid() const;
  ::HmiScenegraph::TResourceCacheId* _internal_mutable_indexdatacacheid();
  public:
  void unsafe_arena_set_allocated_indexdatacacheid(
      ::HmiScenegraph::TResourceCacheId* indexdatacacheid);
  ::HmiScenegraph::TResourceCacheId* unsafe_arena_release_indexdatacacheid();

  // optional uint32 vertexCount = 4;
  bool has_vertexcount() const;
  private:
  bool _internal_has_vertexcount() const;
  public:
  void clear_vertexcount();
  uint32_t vertexcount() const;
  void set_vertexcount(uint32_t value);
  private:
  uint32_t _internal_vertexcount() const;
  void _internal_set_vertexcount(uint32_t value);
  public:

  // optional uint32 primitiveCount = 5;
  bool has_primitivecount() const;
  private:
  bool _internal_has_primitivecount() const;
  public:
  void clear_primitivecount();
  uint32_t primitivecount() const;
  void set_primitivecount(uint32_t value);
  private:
  uint32_t _internal_primitivecount() const;
  void _internal_set_primitivecount(uint32_t value);
  public:

  // optional .HmiScenegraph.TEPrimitiveType primitiveType = 6 [default = TEPrimitiveType_Triangles];
  bool has_primitivetype() const;
  private:
  bool _internal_has_primitivetype() const;
  public:
  void clear_primitivetype();
  ::HmiScenegraph::TEPrimitiveType primitivetype() const;
  void set_primitivetype(::HmiScenegraph::TEPrimitiveType value);
  private:
  ::HmiScenegraph::TEPrimitiveType _internal_primitivetype() const;
  void _internal_set_primitivetype(::HmiScenegraph::TEPrimitiveType value);
  public:

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry_TAttributeParamteter > attributeparameter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
    ::HmiScenegraph::TResourceCacheId* indexdatacacheid_;
    uint32_t vertexcount_;
    uint32_t primitivecount_;
    int primitivetype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TMaterialLib final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TMaterialLib) */ {
 public:
  inline TMaterialLib() : TMaterialLib(nullptr) {}
  ~TMaterialLib() override;
  explicit PROTOBUF_CONSTEXPR TMaterialLib(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TMaterialLib(const TMaterialLib& from);
  TMaterialLib(TMaterialLib&& from) noexcept
    : TMaterialLib() {
    *this = ::std::move(from);
  }

  inline TMaterialLib& operator=(const TMaterialLib& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMaterialLib& operator=(TMaterialLib&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TMaterialLib& default_instance() {
    return *internal_default_instance();
  }
  static inline const TMaterialLib* internal_default_instance() {
    return reinterpret_cast<const TMaterialLib*>(
               &_TMaterialLib_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TMaterialLib& a, TMaterialLib& b) {
    a.Swap(&b);
  }
  inline void Swap(TMaterialLib* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMaterialLib* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TMaterialLib* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TMaterialLib>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TMaterialLib& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TMaterialLib& from) {
    TMaterialLib::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMaterialLib* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TMaterialLib";
  }
  protected:
  explicit TMaterialLib(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaterialFieldNumber = 1,
    kShaderFieldNumber = 2,
    kBitmapFieldNumber = 3,
    kGeometryFieldNumber = 4,
    kRenderTargetFieldNumber = 5,
    kRenderPassFieldNumber = 6,
    kResourceCacheFieldNumber = 7,
    kBlitPassFieldNumber = 8,
  };
  // repeated .HmiScenegraph.TMaterial material = 1;
  int material_size() const;
  private:
  int _internal_material_size() const;
  public:
  void clear_material();
  ::HmiScenegraph::TMaterial* mutable_material(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMaterial >*
      mutable_material();
  private:
  const ::HmiScenegraph::TMaterial& _internal_material(int index) const;
  ::HmiScenegraph::TMaterial* _internal_add_material();
  public:
  const ::HmiScenegraph::TMaterial& material(int index) const;
  ::HmiScenegraph::TMaterial* add_material();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMaterial >&
      material() const;

  // repeated .HmiScenegraph.TShader shader = 2;
  int shader_size() const;
  private:
  int _internal_shader_size() const;
  public:
  void clear_shader();
  ::HmiScenegraph::TShader* mutable_shader(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TShader >*
      mutable_shader();
  private:
  const ::HmiScenegraph::TShader& _internal_shader(int index) const;
  ::HmiScenegraph::TShader* _internal_add_shader();
  public:
  const ::HmiScenegraph::TShader& shader(int index) const;
  ::HmiScenegraph::TShader* add_shader();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TShader >&
      shader() const;

  // repeated .HmiScenegraph.TBitmap bitmap = 3;
  int bitmap_size() const;
  private:
  int _internal_bitmap_size() const;
  public:
  void clear_bitmap();
  ::HmiScenegraph::TBitmap* mutable_bitmap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBitmap >*
      mutable_bitmap();
  private:
  const ::HmiScenegraph::TBitmap& _internal_bitmap(int index) const;
  ::HmiScenegraph::TBitmap* _internal_add_bitmap();
  public:
  const ::HmiScenegraph::TBitmap& bitmap(int index) const;
  ::HmiScenegraph::TBitmap* add_bitmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBitmap >&
      bitmap() const;

  // repeated .HmiScenegraph.TGeometry geometry = 4;
  int geometry_size() const;
  private:
  int _internal_geometry_size() const;
  public:
  void clear_geometry();
  ::HmiScenegraph::TGeometry* mutable_geometry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry >*
      mutable_geometry();
  private:
  const ::HmiScenegraph::TGeometry& _internal_geometry(int index) const;
  ::HmiScenegraph::TGeometry* _internal_add_geometry();
  public:
  const ::HmiScenegraph::TGeometry& geometry(int index) const;
  ::HmiScenegraph::TGeometry* add_geometry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry >&
      geometry() const;

  // repeated .HmiScenegraph.TRenderTarget renderTarget = 5;
  int rendertarget_size() const;
  private:
  int _internal_rendertarget_size() const;
  public:
  void clear_rendertarget();
  ::HmiScenegraph::TRenderTarget* mutable_rendertarget(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderTarget >*
      mutable_rendertarget();
  private:
  const ::HmiScenegraph::TRenderTarget& _internal_rendertarget(int index) const;
  ::HmiScenegraph::TRenderTarget* _internal_add_rendertarget();
  public:
  const ::HmiScenegraph::TRenderTarget& rendertarget(int index) const;
  ::HmiScenegraph::TRenderTarget* add_rendertarget();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderTarget >&
      rendertarget() const;

  // repeated .HmiScenegraph.TRenderPass renderPass = 6;
  int renderpass_size() const;
  private:
  int _internal_renderpass_size() const;
  public:
  void clear_renderpass();
  ::HmiScenegraph::TRenderPass* mutable_renderpass(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
      mutable_renderpass();
  private:
  const ::HmiScenegraph::TRenderPass& _internal_renderpass(int index) const;
  ::HmiScenegraph::TRenderPass* _internal_add_renderpass();
  public:
  const ::HmiScenegraph::TRenderPass& renderpass(int index) const;
  ::HmiScenegraph::TRenderPass* add_renderpass();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
      renderpass() const;

  // repeated string resourceCache = 7;
  int resourcecache_size() const;
  private:
  int _internal_resourcecache_size() const;
  public:
  void clear_resourcecache();
  const std::string& resourcecache(int index) const;
  std::string* mutable_resourcecache(int index);
  void set_resourcecache(int index, const std::string& value);
  void set_resourcecache(int index, std::string&& value);
  void set_resourcecache(int index, const char* value);
  void set_resourcecache(int index, const char* value, size_t size);
  std::string* add_resourcecache();
  void add_resourcecache(const std::string& value);
  void add_resourcecache(std::string&& value);
  void add_resourcecache(const char* value);
  void add_resourcecache(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resourcecache() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resourcecache();
  private:
  const std::string& _internal_resourcecache(int index) const;
  std::string* _internal_add_resourcecache();
  public:

  // repeated .HmiScenegraph.TBlitPass blitPass = 8;
  int blitpass_size() const;
  private:
  int _internal_blitpass_size() const;
  public:
  void clear_blitpass();
  ::HmiScenegraph::TBlitPass* mutable_blitpass(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBlitPass >*
      mutable_blitpass();
  private:
  const ::HmiScenegraph::TBlitPass& _internal_blitpass(int index) const;
  ::HmiScenegraph::TBlitPass* _internal_add_blitpass();
  public:
  const ::HmiScenegraph::TBlitPass& blitpass(int index) const;
  ::HmiScenegraph::TBlitPass* add_blitpass();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBlitPass >&
      blitpass() const;

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TMaterialLib)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMaterial > material_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TShader > shader_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBitmap > bitmap_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry > geometry_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderTarget > rendertarget_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass > renderpass_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resourcecache_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBlitPass > blitpass_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// -------------------------------------------------------------------

class TScene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiScenegraph.TScene) */ {
 public:
  inline TScene() : TScene(nullptr) {}
  ~TScene() override;
  explicit PROTOBUF_CONSTEXPR TScene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TScene(const TScene& from);
  TScene(TScene&& from) noexcept
    : TScene() {
    *this = ::std::move(from);
  }

  inline TScene& operator=(const TScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline TScene& operator=(TScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const TScene* internal_default_instance() {
    return reinterpret_cast<const TScene*>(
               &_TScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TScene& a, TScene& b) {
    a.Swap(&b);
  }
  inline void Swap(TScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TScene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TScene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TScene& from) {
    TScene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TScene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiScenegraph.TScene";
  }
  protected:
  explicit TScene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRenderPassFieldNumber = 4,
    kRootFieldNumber = 1,
    kMaterialLibraryFieldNumber = 3,
  };
  // repeated .HmiScenegraph.TRenderPass renderPass = 4 [deprecated = true];
  PROTOBUF_DEPRECATED int renderpass_size() const;
  private:
  int _internal_renderpass_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_renderpass();
  PROTOBUF_DEPRECATED ::HmiScenegraph::TRenderPass* mutable_renderpass(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
      mutable_renderpass();
  private:
  const ::HmiScenegraph::TRenderPass& _internal_renderpass(int index) const;
  ::HmiScenegraph::TRenderPass* _internal_add_renderpass();
  public:
  PROTOBUF_DEPRECATED const ::HmiScenegraph::TRenderPass& renderpass(int index) const;
  PROTOBUF_DEPRECATED ::HmiScenegraph::TRenderPass* add_renderpass();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
      renderpass() const;

  // required .HmiScenegraph.TNode root = 1;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::HmiScenegraph::TNode& root() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TNode* release_root();
  ::HmiScenegraph::TNode* mutable_root();
  void set_allocated_root(::HmiScenegraph::TNode* root);
  private:
  const ::HmiScenegraph::TNode& _internal_root() const;
  ::HmiScenegraph::TNode* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::HmiScenegraph::TNode* root);
  ::HmiScenegraph::TNode* unsafe_arena_release_root();

  // optional .HmiScenegraph.TMaterialLib materialLibrary = 3;
  bool has_materiallibrary() const;
  private:
  bool _internal_has_materiallibrary() const;
  public:
  void clear_materiallibrary();
  const ::HmiScenegraph::TMaterialLib& materiallibrary() const;
  PROTOBUF_NODISCARD ::HmiScenegraph::TMaterialLib* release_materiallibrary();
  ::HmiScenegraph::TMaterialLib* mutable_materiallibrary();
  void set_allocated_materiallibrary(::HmiScenegraph::TMaterialLib* materiallibrary);
  private:
  const ::HmiScenegraph::TMaterialLib& _internal_materiallibrary() const;
  ::HmiScenegraph::TMaterialLib* _internal_mutable_materiallibrary();
  public:
  void unsafe_arena_set_allocated_materiallibrary(
      ::HmiScenegraph::TMaterialLib* materiallibrary);
  ::HmiScenegraph::TMaterialLib* unsafe_arena_release_materiallibrary();

  // @@protoc_insertion_point(class_scope:HmiScenegraph.TScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass > renderpass_;
    ::HmiScenegraph::TNode* root_;
    ::HmiScenegraph::TMaterialLib* materiallibrary_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Scenegraph_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TResourceCacheId

// optional uint64 low = 1;
inline bool TResourceCacheId::_internal_has_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TResourceCacheId::has_low() const {
  return _internal_has_low();
}
inline void TResourceCacheId::clear_low() {
  _impl_.low_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t TResourceCacheId::_internal_low() const {
  return _impl_.low_;
}
inline uint64_t TResourceCacheId::low() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TResourceCacheId.low)
  return _internal_low();
}
inline void TResourceCacheId::_internal_set_low(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_ = value;
}
inline void TResourceCacheId::set_low(uint64_t value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TResourceCacheId.low)
}

// optional uint64 high = 2;
inline bool TResourceCacheId::_internal_has_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TResourceCacheId::has_high() const {
  return _internal_has_high();
}
inline void TResourceCacheId::clear_high() {
  _impl_.high_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t TResourceCacheId::_internal_high() const {
  return _impl_.high_;
}
inline uint64_t TResourceCacheId::high() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TResourceCacheId.high)
  return _internal_high();
}
inline void TResourceCacheId::_internal_set_high(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.high_ = value;
}
inline void TResourceCacheId::set_high(uint64_t value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TResourceCacheId.high)
}

// -------------------------------------------------------------------

// TUniform

// required string name = 1;
inline bool TUniform::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TUniform::has_name() const {
  return _internal_has_name();
}
inline void TUniform::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TUniform::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TUniform.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TUniform::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TUniform.name)
}
inline std::string* TUniform::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TUniform.name)
  return _s;
}
inline const std::string& TUniform::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TUniform::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TUniform::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TUniform::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TUniform.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TUniform::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TUniform.name)
}

// required .TNumericValue value = 2;
inline bool TUniform::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool TUniform::has_value() const {
  return _internal_has_value();
}
inline const ::TNumericValue& TUniform::_internal_value() const {
  const ::TNumericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TNumericValue&>(
      ::_TNumericValue_default_instance_);
}
inline const ::TNumericValue& TUniform::value() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TUniform.value)
  return _internal_value();
}
inline void TUniform::unsafe_arena_set_allocated_value(
    ::TNumericValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TUniform.value)
}
inline ::TNumericValue* TUniform::release_value() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TNumericValue* TUniform::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TUniform.value)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TNumericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::TNumericValue* TUniform::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TNumericValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::TNumericValue* TUniform::mutable_value() {
  ::TNumericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TUniform.value)
  return _msg;
}
inline void TUniform::set_allocated_value(::TNumericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TUniform.value)
}

// required .TENumericType type = 3;
inline bool TUniform::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TUniform::has_type() const {
  return _internal_has_type();
}
inline void TUniform::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TENumericType TUniform::_internal_type() const {
  return static_cast< ::TENumericType >(_impl_.type_);
}
inline ::TENumericType TUniform::type() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TUniform.type)
  return _internal_type();
}
inline void TUniform::_internal_set_type(::TENumericType value) {
  assert(::TENumericType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void TUniform::set_type(::TENumericType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TUniform.type)
}

// -------------------------------------------------------------------

// TCamera

// optional .HmiScenegraph.TECameraProjectionType projectionType = 14;
inline bool TCamera::_internal_has_projectiontype() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TCamera::has_projectiontype() const {
  return _internal_has_projectiontype();
}
inline void TCamera::clear_projectiontype() {
  _impl_.projectiontype_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::HmiScenegraph::TECameraProjectionType TCamera::_internal_projectiontype() const {
  return static_cast< ::HmiScenegraph::TECameraProjectionType >(_impl_.projectiontype_);
}
inline ::HmiScenegraph::TECameraProjectionType TCamera::projectiontype() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.projectionType)
  return _internal_projectiontype();
}
inline void TCamera::_internal_set_projectiontype(::HmiScenegraph::TECameraProjectionType value) {
  assert(::HmiScenegraph::TECameraProjectionType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.projectiontype_ = value;
}
inline void TCamera::set_projectiontype(::HmiScenegraph::TECameraProjectionType value) {
  _internal_set_projectiontype(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.projectionType)
}

// optional .TMatrix4x4f projectionMatrix = 3;
inline bool TCamera::_internal_has_projectionmatrix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.projectionmatrix_ != nullptr);
  return value;
}
inline bool TCamera::has_projectionmatrix() const {
  return _internal_has_projectionmatrix();
}
inline const ::TMatrix4x4f& TCamera::_internal_projectionmatrix() const {
  const ::TMatrix4x4f* p = _impl_.projectionmatrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMatrix4x4f&>(
      ::_TMatrix4x4f_default_instance_);
}
inline const ::TMatrix4x4f& TCamera::projectionmatrix() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.projectionMatrix)
  return _internal_projectionmatrix();
}
inline void TCamera::unsafe_arena_set_allocated_projectionmatrix(
    ::TMatrix4x4f* projectionmatrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectionmatrix_);
  }
  _impl_.projectionmatrix_ = projectionmatrix;
  if (projectionmatrix) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TCamera.projectionMatrix)
}
inline ::TMatrix4x4f* TCamera::release_projectionmatrix() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMatrix4x4f* temp = _impl_.projectionmatrix_;
  _impl_.projectionmatrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMatrix4x4f* TCamera::unsafe_arena_release_projectionmatrix() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TCamera.projectionMatrix)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TMatrix4x4f* temp = _impl_.projectionmatrix_;
  _impl_.projectionmatrix_ = nullptr;
  return temp;
}
inline ::TMatrix4x4f* TCamera::_internal_mutable_projectionmatrix() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.projectionmatrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMatrix4x4f>(GetArenaForAllocation());
    _impl_.projectionmatrix_ = p;
  }
  return _impl_.projectionmatrix_;
}
inline ::TMatrix4x4f* TCamera::mutable_projectionmatrix() {
  ::TMatrix4x4f* _msg = _internal_mutable_projectionmatrix();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TCamera.projectionMatrix)
  return _msg;
}
inline void TCamera::set_allocated_projectionmatrix(::TMatrix4x4f* projectionmatrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.projectionmatrix_);
  }
  if (projectionmatrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(projectionmatrix));
    if (message_arena != submessage_arena) {
      projectionmatrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projectionmatrix, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.projectionmatrix_ = projectionmatrix;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TCamera.projectionMatrix)
}

// optional .TVector3f rotation = 4;
inline bool TCamera::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline bool TCamera::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::TVector3f& TCamera::_internal_rotation() const {
  const ::TVector3f* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TCamera::rotation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.rotation)
  return _internal_rotation();
}
inline void TCamera::unsafe_arena_set_allocated_rotation(
    ::TVector3f* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TCamera.rotation)
}
inline ::TVector3f* TCamera::release_rotation() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TCamera::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TCamera.rotation)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::TVector3f* TCamera::_internal_mutable_rotation() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::TVector3f* TCamera::mutable_rotation() {
  ::TVector3f* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TCamera.rotation)
  return _msg;
}
inline void TCamera::set_allocated_rotation(::TVector3f* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TCamera.rotation)
}

// optional .TVector3f translation = 5;
inline bool TCamera::_internal_has_translation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_ != nullptr);
  return value;
}
inline bool TCamera::has_translation() const {
  return _internal_has_translation();
}
inline const ::TVector3f& TCamera::_internal_translation() const {
  const ::TVector3f* p = _impl_.translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TCamera::translation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.translation)
  return _internal_translation();
}
inline void TCamera::unsafe_arena_set_allocated_translation(
    ::TVector3f* translation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.translation_);
  }
  _impl_.translation_ = translation;
  if (translation) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TCamera.translation)
}
inline ::TVector3f* TCamera::release_translation() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TVector3f* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TCamera::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TCamera.translation)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TVector3f* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
  return temp;
}
inline ::TVector3f* TCamera::_internal_mutable_translation() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.translation_ = p;
  }
  return _impl_.translation_;
}
inline ::TVector3f* TCamera::mutable_translation() {
  ::TVector3f* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TCamera.translation)
  return _msg;
}
inline void TCamera::set_allocated_translation(::TVector3f* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.translation_);
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation));
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TCamera.translation)
}

// optional float horizontalFOV = 6;
inline bool TCamera::_internal_has_horizontalfov() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TCamera::has_horizontalfov() const {
  return _internal_has_horizontalfov();
}
inline void TCamera::clear_horizontalfov() {
  _impl_.horizontalfov_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float TCamera::_internal_horizontalfov() const {
  return _impl_.horizontalfov_;
}
inline float TCamera::horizontalfov() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.horizontalFOV)
  return _internal_horizontalfov();
}
inline void TCamera::_internal_set_horizontalfov(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.horizontalfov_ = value;
}
inline void TCamera::set_horizontalfov(float value) {
  _internal_set_horizontalfov(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.horizontalFOV)
}

// optional float aspectRatio = 7;
inline bool TCamera::_internal_has_aspectratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TCamera::has_aspectratio() const {
  return _internal_has_aspectratio();
}
inline void TCamera::clear_aspectratio() {
  _impl_.aspectratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float TCamera::_internal_aspectratio() const {
  return _impl_.aspectratio_;
}
inline float TCamera::aspectratio() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.aspectRatio)
  return _internal_aspectratio();
}
inline void TCamera::_internal_set_aspectratio(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.aspectratio_ = value;
}
inline void TCamera::set_aspectratio(float value) {
  _internal_set_aspectratio(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.aspectRatio)
}

// optional float horizontalFocalLength = 15;
inline bool TCamera::_internal_has_horizontalfocallength() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TCamera::has_horizontalfocallength() const {
  return _internal_has_horizontalfocallength();
}
inline void TCamera::clear_horizontalfocallength() {
  _impl_.horizontalfocallength_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float TCamera::_internal_horizontalfocallength() const {
  return _impl_.horizontalfocallength_;
}
inline float TCamera::horizontalfocallength() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.horizontalFocalLength)
  return _internal_horizontalfocallength();
}
inline void TCamera::_internal_set_horizontalfocallength(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.horizontalfocallength_ = value;
}
inline void TCamera::set_horizontalfocallength(float value) {
  _internal_set_horizontalfocallength(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.horizontalFocalLength)
}

// optional .TVector4f viewport = 16;
inline bool TCamera::_internal_has_viewport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.viewport_ != nullptr);
  return value;
}
inline bool TCamera::has_viewport() const {
  return _internal_has_viewport();
}
inline const ::TVector4f& TCamera::_internal_viewport() const {
  const ::TVector4f* p = _impl_.viewport_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector4f&>(
      ::_TVector4f_default_instance_);
}
inline const ::TVector4f& TCamera::viewport() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.viewport)
  return _internal_viewport();
}
inline void TCamera::unsafe_arena_set_allocated_viewport(
    ::TVector4f* viewport) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewport_);
  }
  _impl_.viewport_ = viewport;
  if (viewport) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TCamera.viewport)
}
inline ::TVector4f* TCamera::release_viewport() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector4f* temp = _impl_.viewport_;
  _impl_.viewport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector4f* TCamera::unsafe_arena_release_viewport() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TCamera.viewport)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector4f* temp = _impl_.viewport_;
  _impl_.viewport_ = nullptr;
  return temp;
}
inline ::TVector4f* TCamera::_internal_mutable_viewport() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.viewport_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector4f>(GetArenaForAllocation());
    _impl_.viewport_ = p;
  }
  return _impl_.viewport_;
}
inline ::TVector4f* TCamera::mutable_viewport() {
  ::TVector4f* _msg = _internal_mutable_viewport();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TCamera.viewport)
  return _msg;
}
inline void TCamera::set_allocated_viewport(::TVector4f* viewport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewport_);
  }
  if (viewport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viewport));
    if (message_arena != submessage_arena) {
      viewport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viewport, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.viewport_ = viewport;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TCamera.viewport)
}

// optional float nearPlane = 8;
inline bool TCamera::_internal_has_nearplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TCamera::has_nearplane() const {
  return _internal_has_nearplane();
}
inline void TCamera::clear_nearplane() {
  _impl_.nearplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float TCamera::_internal_nearplane() const {
  return _impl_.nearplane_;
}
inline float TCamera::nearplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.nearPlane)
  return _internal_nearplane();
}
inline void TCamera::_internal_set_nearplane(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.nearplane_ = value;
}
inline void TCamera::set_nearplane(float value) {
  _internal_set_nearplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.nearPlane)
}

// optional float farPlane = 9;
inline bool TCamera::_internal_has_farplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TCamera::has_farplane() const {
  return _internal_has_farplane();
}
inline void TCamera::clear_farplane() {
  _impl_.farplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float TCamera::_internal_farplane() const {
  return _impl_.farplane_;
}
inline float TCamera::farplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.farPlane)
  return _internal_farplane();
}
inline void TCamera::_internal_set_farplane(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.farplane_ = value;
}
inline void TCamera::set_farplane(float value) {
  _internal_set_farplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.farPlane)
}

// optional float rightPlane = 10;
inline bool TCamera::_internal_has_rightplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TCamera::has_rightplane() const {
  return _internal_has_rightplane();
}
inline void TCamera::clear_rightplane() {
  _impl_.rightplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float TCamera::_internal_rightplane() const {
  return _impl_.rightplane_;
}
inline float TCamera::rightplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.rightPlane)
  return _internal_rightplane();
}
inline void TCamera::_internal_set_rightplane(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.rightplane_ = value;
}
inline void TCamera::set_rightplane(float value) {
  _internal_set_rightplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.rightPlane)
}

// optional float leftPlane = 11;
inline bool TCamera::_internal_has_leftplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TCamera::has_leftplane() const {
  return _internal_has_leftplane();
}
inline void TCamera::clear_leftplane() {
  _impl_.leftplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float TCamera::_internal_leftplane() const {
  return _impl_.leftplane_;
}
inline float TCamera::leftplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.leftPlane)
  return _internal_leftplane();
}
inline void TCamera::_internal_set_leftplane(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.leftplane_ = value;
}
inline void TCamera::set_leftplane(float value) {
  _internal_set_leftplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.leftPlane)
}

// optional float topPlane = 12;
inline bool TCamera::_internal_has_topplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TCamera::has_topplane() const {
  return _internal_has_topplane();
}
inline void TCamera::clear_topplane() {
  _impl_.topplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float TCamera::_internal_topplane() const {
  return _impl_.topplane_;
}
inline float TCamera::topplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.topPlane)
  return _internal_topplane();
}
inline void TCamera::_internal_set_topplane(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.topplane_ = value;
}
inline void TCamera::set_topplane(float value) {
  _internal_set_topplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.topPlane)
}

// optional float bottomPlane = 13;
inline bool TCamera::_internal_has_bottomplane() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TCamera::has_bottomplane() const {
  return _internal_has_bottomplane();
}
inline void TCamera::clear_bottomplane() {
  _impl_.bottomplane_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float TCamera::_internal_bottomplane() const {
  return _impl_.bottomplane_;
}
inline float TCamera::bottomplane() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.bottomPlane)
  return _internal_bottomplane();
}
inline void TCamera::_internal_set_bottomplane(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.bottomplane_ = value;
}
inline void TCamera::set_bottomplane(float value) {
  _internal_set_bottomplane(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.bottomPlane)
}

// optional .TEScope scope = 17 [default = TEScope_Scene];
inline bool TCamera::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TCamera::has_scope() const {
  return _internal_has_scope();
}
inline void TCamera::clear_scope() {
  _impl_.scope_ = 3;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::TEScope TCamera::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TCamera::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TCamera.scope)
  return _internal_scope();
}
inline void TCamera::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.scope_ = value;
}
inline void TCamera::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TCamera.scope)
}

// -------------------------------------------------------------------

// TBlendMode

// required .TEBlendOperation blendOperationColor = 1;
inline bool TBlendMode::_internal_has_blendoperationcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TBlendMode::has_blendoperationcolor() const {
  return _internal_has_blendoperationcolor();
}
inline void TBlendMode::clear_blendoperationcolor() {
  _impl_.blendoperationcolor_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TEBlendOperation TBlendMode::_internal_blendoperationcolor() const {
  return static_cast< ::TEBlendOperation >(_impl_.blendoperationcolor_);
}
inline ::TEBlendOperation TBlendMode::blendoperationcolor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.blendOperationColor)
  return _internal_blendoperationcolor();
}
inline void TBlendMode::_internal_set_blendoperationcolor(::TEBlendOperation value) {
  assert(::TEBlendOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.blendoperationcolor_ = value;
}
inline void TBlendMode::set_blendoperationcolor(::TEBlendOperation value) {
  _internal_set_blendoperationcolor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.blendOperationColor)
}

// required .TEBlendOperation blendOperationAlpha = 2;
inline bool TBlendMode::_internal_has_blendoperationalpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TBlendMode::has_blendoperationalpha() const {
  return _internal_has_blendoperationalpha();
}
inline void TBlendMode::clear_blendoperationalpha() {
  _impl_.blendoperationalpha_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TEBlendOperation TBlendMode::_internal_blendoperationalpha() const {
  return static_cast< ::TEBlendOperation >(_impl_.blendoperationalpha_);
}
inline ::TEBlendOperation TBlendMode::blendoperationalpha() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.blendOperationAlpha)
  return _internal_blendoperationalpha();
}
inline void TBlendMode::_internal_set_blendoperationalpha(::TEBlendOperation value) {
  assert(::TEBlendOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.blendoperationalpha_ = value;
}
inline void TBlendMode::set_blendoperationalpha(::TEBlendOperation value) {
  _internal_set_blendoperationalpha(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.blendOperationAlpha)
}

// optional .TEBlendFactor sourceColorFactor = 3;
inline bool TBlendMode::_internal_has_sourcecolorfactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TBlendMode::has_sourcecolorfactor() const {
  return _internal_has_sourcecolorfactor();
}
inline void TBlendMode::clear_sourcecolorfactor() {
  _impl_.sourcecolorfactor_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TEBlendFactor TBlendMode::_internal_sourcecolorfactor() const {
  return static_cast< ::TEBlendFactor >(_impl_.sourcecolorfactor_);
}
inline ::TEBlendFactor TBlendMode::sourcecolorfactor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.sourceColorFactor)
  return _internal_sourcecolorfactor();
}
inline void TBlendMode::_internal_set_sourcecolorfactor(::TEBlendFactor value) {
  assert(::TEBlendFactor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sourcecolorfactor_ = value;
}
inline void TBlendMode::set_sourcecolorfactor(::TEBlendFactor value) {
  _internal_set_sourcecolorfactor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.sourceColorFactor)
}

// optional .TEBlendFactor sourceAlphaFactor = 4;
inline bool TBlendMode::_internal_has_sourcealphafactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TBlendMode::has_sourcealphafactor() const {
  return _internal_has_sourcealphafactor();
}
inline void TBlendMode::clear_sourcealphafactor() {
  _impl_.sourcealphafactor_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TEBlendFactor TBlendMode::_internal_sourcealphafactor() const {
  return static_cast< ::TEBlendFactor >(_impl_.sourcealphafactor_);
}
inline ::TEBlendFactor TBlendMode::sourcealphafactor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.sourceAlphaFactor)
  return _internal_sourcealphafactor();
}
inline void TBlendMode::_internal_set_sourcealphafactor(::TEBlendFactor value) {
  assert(::TEBlendFactor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sourcealphafactor_ = value;
}
inline void TBlendMode::set_sourcealphafactor(::TEBlendFactor value) {
  _internal_set_sourcealphafactor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.sourceAlphaFactor)
}

// optional .TEBlendFactor destinationColorFactor = 5;
inline bool TBlendMode::_internal_has_destinationcolorfactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TBlendMode::has_destinationcolorfactor() const {
  return _internal_has_destinationcolorfactor();
}
inline void TBlendMode::clear_destinationcolorfactor() {
  _impl_.destinationcolorfactor_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TEBlendFactor TBlendMode::_internal_destinationcolorfactor() const {
  return static_cast< ::TEBlendFactor >(_impl_.destinationcolorfactor_);
}
inline ::TEBlendFactor TBlendMode::destinationcolorfactor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.destinationColorFactor)
  return _internal_destinationcolorfactor();
}
inline void TBlendMode::_internal_set_destinationcolorfactor(::TEBlendFactor value) {
  assert(::TEBlendFactor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.destinationcolorfactor_ = value;
}
inline void TBlendMode::set_destinationcolorfactor(::TEBlendFactor value) {
  _internal_set_destinationcolorfactor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.destinationColorFactor)
}

// optional .TEBlendFactor destinationAlphaFactor = 6;
inline bool TBlendMode::_internal_has_destinationalphafactor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TBlendMode::has_destinationalphafactor() const {
  return _internal_has_destinationalphafactor();
}
inline void TBlendMode::clear_destinationalphafactor() {
  _impl_.destinationalphafactor_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::TEBlendFactor TBlendMode::_internal_destinationalphafactor() const {
  return static_cast< ::TEBlendFactor >(_impl_.destinationalphafactor_);
}
inline ::TEBlendFactor TBlendMode::destinationalphafactor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlendMode.destinationAlphaFactor)
  return _internal_destinationalphafactor();
}
inline void TBlendMode::_internal_set_destinationalphafactor(::TEBlendFactor value) {
  assert(::TEBlendFactor_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.destinationalphafactor_ = value;
}
inline void TBlendMode::set_destinationalphafactor(::TEBlendFactor value) {
  _internal_set_destinationalphafactor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlendMode.destinationAlphaFactor)
}

// -------------------------------------------------------------------

// TStencilMode

// required .TEStencilOperation operation = 1;
inline bool TStencilMode::_internal_has_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TStencilMode::has_operation() const {
  return _internal_has_operation();
}
inline void TStencilMode::clear_operation() {
  _impl_.operation_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TEStencilOperation TStencilMode::_internal_operation() const {
  return static_cast< ::TEStencilOperation >(_impl_.operation_);
}
inline ::TEStencilOperation TStencilMode::operation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.operation)
  return _internal_operation();
}
inline void TStencilMode::_internal_set_operation(::TEStencilOperation value) {
  assert(::TEStencilOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.operation_ = value;
}
inline void TStencilMode::set_operation(::TEStencilOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.operation)
}

// required int32 referenceValue = 2;
inline bool TStencilMode::_internal_has_referencevalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TStencilMode::has_referencevalue() const {
  return _internal_has_referencevalue();
}
inline void TStencilMode::clear_referencevalue() {
  _impl_.referencevalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TStencilMode::_internal_referencevalue() const {
  return _impl_.referencevalue_;
}
inline int32_t TStencilMode::referencevalue() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.referenceValue)
  return _internal_referencevalue();
}
inline void TStencilMode::_internal_set_referencevalue(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.referencevalue_ = value;
}
inline void TStencilMode::set_referencevalue(int32_t value) {
  _internal_set_referencevalue(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.referenceValue)
}

// required fixed32 mask = 3;
inline bool TStencilMode::_internal_has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TStencilMode::has_mask() const {
  return _internal_has_mask();
}
inline void TStencilMode::clear_mask() {
  _impl_.mask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TStencilMode::_internal_mask() const {
  return _impl_.mask_;
}
inline uint32_t TStencilMode::mask() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.mask)
  return _internal_mask();
}
inline void TStencilMode::_internal_set_mask(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mask_ = value;
}
inline void TStencilMode::set_mask(uint32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.mask)
}

// required .TEStencilOperation stencilFail = 4;
inline bool TStencilMode::_internal_has_stencilfail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TStencilMode::has_stencilfail() const {
  return _internal_has_stencilfail();
}
inline void TStencilMode::clear_stencilfail() {
  _impl_.stencilfail_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TEStencilOperation TStencilMode::_internal_stencilfail() const {
  return static_cast< ::TEStencilOperation >(_impl_.stencilfail_);
}
inline ::TEStencilOperation TStencilMode::stencilfail() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.stencilFail)
  return _internal_stencilfail();
}
inline void TStencilMode::_internal_set_stencilfail(::TEStencilOperation value) {
  assert(::TEStencilOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stencilfail_ = value;
}
inline void TStencilMode::set_stencilfail(::TEStencilOperation value) {
  _internal_set_stencilfail(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.stencilFail)
}

// required .TEStencilOperation depthFail = 5;
inline bool TStencilMode::_internal_has_depthfail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TStencilMode::has_depthfail() const {
  return _internal_has_depthfail();
}
inline void TStencilMode::clear_depthfail() {
  _impl_.depthfail_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TEStencilOperation TStencilMode::_internal_depthfail() const {
  return static_cast< ::TEStencilOperation >(_impl_.depthfail_);
}
inline ::TEStencilOperation TStencilMode::depthfail() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.depthFail)
  return _internal_depthfail();
}
inline void TStencilMode::_internal_set_depthfail(::TEStencilOperation value) {
  assert(::TEStencilOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.depthfail_ = value;
}
inline void TStencilMode::set_depthfail(::TEStencilOperation value) {
  _internal_set_depthfail(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.depthFail)
}

// required .TEStencilOperation pass = 6;
inline bool TStencilMode::_internal_has_pass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TStencilMode::has_pass() const {
  return _internal_has_pass();
}
inline void TStencilMode::clear_pass() {
  _impl_.pass_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::TEStencilOperation TStencilMode::_internal_pass() const {
  return static_cast< ::TEStencilOperation >(_impl_.pass_);
}
inline ::TEStencilOperation TStencilMode::pass() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TStencilMode.pass)
  return _internal_pass();
}
inline void TStencilMode::_internal_set_pass(::TEStencilOperation value) {
  assert(::TEStencilOperation_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.pass_ = value;
}
inline void TStencilMode::set_pass(::TEStencilOperation value) {
  _internal_set_pass(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TStencilMode.pass)
}

// -------------------------------------------------------------------

// TScissorTest

// required int32 x = 1;
inline bool TScissorTest::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TScissorTest::has_x() const {
  return _internal_has_x();
}
inline void TScissorTest::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TScissorTest::_internal_x() const {
  return _impl_.x_;
}
inline int32_t TScissorTest::x() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScissorTest.x)
  return _internal_x();
}
inline void TScissorTest::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void TScissorTest::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TScissorTest.x)
}

// required int32 y = 2;
inline bool TScissorTest::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TScissorTest::has_y() const {
  return _internal_has_y();
}
inline void TScissorTest::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TScissorTest::_internal_y() const {
  return _impl_.y_;
}
inline int32_t TScissorTest::y() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScissorTest.y)
  return _internal_y();
}
inline void TScissorTest::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void TScissorTest::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TScissorTest.y)
}

// required int32 height = 3;
inline bool TScissorTest::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TScissorTest::has_height() const {
  return _internal_has_height();
}
inline void TScissorTest::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TScissorTest::_internal_height() const {
  return _impl_.height_;
}
inline int32_t TScissorTest::height() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScissorTest.height)
  return _internal_height();
}
inline void TScissorTest::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}
inline void TScissorTest::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TScissorTest.height)
}

// required int32 width = 4;
inline bool TScissorTest::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TScissorTest::has_width() const {
  return _internal_has_width();
}
inline void TScissorTest::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TScissorTest::_internal_width() const {
  return _impl_.width_;
}
inline int32_t TScissorTest::width() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScissorTest.width)
  return _internal_width();
}
inline void TScissorTest::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_ = value;
}
inline void TScissorTest::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TScissorTest.width)
}

// -------------------------------------------------------------------

// TRenderMode_TColorWrite

// optional bool red = 1 [default = true];
inline bool TRenderMode_TColorWrite::_internal_has_red() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TRenderMode_TColorWrite::has_red() const {
  return _internal_has_red();
}
inline void TRenderMode_TColorWrite::clear_red() {
  _impl_.red_ = true;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TRenderMode_TColorWrite::_internal_red() const {
  return _impl_.red_;
}
inline bool TRenderMode_TColorWrite::red() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.TColorWrite.red)
  return _internal_red();
}
inline void TRenderMode_TColorWrite::_internal_set_red(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.red_ = value;
}
inline void TRenderMode_TColorWrite::set_red(bool value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.TColorWrite.red)
}

// optional bool green = 2 [default = true];
inline bool TRenderMode_TColorWrite::_internal_has_green() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRenderMode_TColorWrite::has_green() const {
  return _internal_has_green();
}
inline void TRenderMode_TColorWrite::clear_green() {
  _impl_.green_ = true;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TRenderMode_TColorWrite::_internal_green() const {
  return _impl_.green_;
}
inline bool TRenderMode_TColorWrite::green() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.TColorWrite.green)
  return _internal_green();
}
inline void TRenderMode_TColorWrite::_internal_set_green(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.green_ = value;
}
inline void TRenderMode_TColorWrite::set_green(bool value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.TColorWrite.green)
}

// optional bool blue = 3 [default = true];
inline bool TRenderMode_TColorWrite::_internal_has_blue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TRenderMode_TColorWrite::has_blue() const {
  return _internal_has_blue();
}
inline void TRenderMode_TColorWrite::clear_blue() {
  _impl_.blue_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TRenderMode_TColorWrite::_internal_blue() const {
  return _impl_.blue_;
}
inline bool TRenderMode_TColorWrite::blue() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.TColorWrite.blue)
  return _internal_blue();
}
inline void TRenderMode_TColorWrite::_internal_set_blue(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.blue_ = value;
}
inline void TRenderMode_TColorWrite::set_blue(bool value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.TColorWrite.blue)
}

// optional bool alpha = 4 [default = true];
inline bool TRenderMode_TColorWrite::_internal_has_alpha() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TRenderMode_TColorWrite::has_alpha() const {
  return _internal_has_alpha();
}
inline void TRenderMode_TColorWrite::clear_alpha() {
  _impl_.alpha_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool TRenderMode_TColorWrite::_internal_alpha() const {
  return _impl_.alpha_;
}
inline bool TRenderMode_TColorWrite::alpha() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.TColorWrite.alpha)
  return _internal_alpha();
}
inline void TRenderMode_TColorWrite::_internal_set_alpha(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.alpha_ = value;
}
inline void TRenderMode_TColorWrite::set_alpha(bool value) {
  _internal_set_alpha(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.TColorWrite.alpha)
}

// -------------------------------------------------------------------

// TRenderMode

// required .TEWinding winding = 1;
inline bool TRenderMode::_internal_has_winding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TRenderMode::has_winding() const {
  return _internal_has_winding();
}
inline void TRenderMode::clear_winding() {
  _impl_.winding_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::TEWinding TRenderMode::_internal_winding() const {
  return static_cast< ::TEWinding >(_impl_.winding_);
}
inline ::TEWinding TRenderMode::winding() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.winding)
  return _internal_winding();
}
inline void TRenderMode::_internal_set_winding(::TEWinding value) {
  assert(::TEWinding_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.winding_ = value;
}
inline void TRenderMode::set_winding(::TEWinding value) {
  _internal_set_winding(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.winding)
}

// required .TEFace culling = 2;
inline bool TRenderMode::_internal_has_culling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TRenderMode::has_culling() const {
  return _internal_has_culling();
}
inline void TRenderMode::clear_culling() {
  _impl_.culling_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::TEFace TRenderMode::_internal_culling() const {
  return static_cast< ::TEFace >(_impl_.culling_);
}
inline ::TEFace TRenderMode::culling() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.culling)
  return _internal_culling();
}
inline void TRenderMode::_internal_set_culling(::TEFace value) {
  assert(::TEFace_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.culling_ = value;
}
inline void TRenderMode::set_culling(::TEFace value) {
  _internal_set_culling(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.culling)
}

// required .HmiScenegraph.TBlendMode blending = 3;
inline bool TRenderMode::_internal_has_blending() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.blending_ != nullptr);
  return value;
}
inline bool TRenderMode::has_blending() const {
  return _internal_has_blending();
}
inline void TRenderMode::clear_blending() {
  if (_impl_.blending_ != nullptr) _impl_.blending_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HmiScenegraph::TBlendMode& TRenderMode::_internal_blending() const {
  const ::HmiScenegraph::TBlendMode* p = _impl_.blending_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBlendMode&>(
      ::HmiScenegraph::_TBlendMode_default_instance_);
}
inline const ::HmiScenegraph::TBlendMode& TRenderMode::blending() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.blending)
  return _internal_blending();
}
inline void TRenderMode::unsafe_arena_set_allocated_blending(
    ::HmiScenegraph::TBlendMode* blending) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.blending_);
  }
  _impl_.blending_ = blending;
  if (blending) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderMode.blending)
}
inline ::HmiScenegraph::TBlendMode* TRenderMode::release_blending() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBlendMode* temp = _impl_.blending_;
  _impl_.blending_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBlendMode* TRenderMode::unsafe_arena_release_blending() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderMode.blending)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBlendMode* temp = _impl_.blending_;
  _impl_.blending_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBlendMode* TRenderMode::_internal_mutable_blending() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.blending_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBlendMode>(GetArenaForAllocation());
    _impl_.blending_ = p;
  }
  return _impl_.blending_;
}
inline ::HmiScenegraph::TBlendMode* TRenderMode::mutable_blending() {
  ::HmiScenegraph::TBlendMode* _msg = _internal_mutable_blending();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderMode.blending)
  return _msg;
}
inline void TRenderMode::set_allocated_blending(::HmiScenegraph::TBlendMode* blending) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.blending_;
  }
  if (blending) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blending);
    if (message_arena != submessage_arena) {
      blending = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blending, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.blending_ = blending;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderMode.blending)
}

// optional fixed32 blendColor = 4;
inline bool TRenderMode::_internal_has_blendcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TRenderMode::has_blendcolor() const {
  return _internal_has_blendcolor();
}
inline void TRenderMode::clear_blendcolor() {
  _impl_.blendcolor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TRenderMode::_internal_blendcolor() const {
  return _impl_.blendcolor_;
}
inline uint32_t TRenderMode::blendcolor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.blendColor)
  return _internal_blendcolor();
}
inline void TRenderMode::_internal_set_blendcolor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.blendcolor_ = value;
}
inline void TRenderMode::set_blendcolor(uint32_t value) {
  _internal_set_blendcolor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.blendColor)
}

// required .TECompareFunction depthCompare = 5;
inline bool TRenderMode::_internal_has_depthcompare() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TRenderMode::has_depthcompare() const {
  return _internal_has_depthcompare();
}
inline void TRenderMode::clear_depthcompare() {
  _impl_.depthcompare_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::TECompareFunction TRenderMode::_internal_depthcompare() const {
  return static_cast< ::TECompareFunction >(_impl_.depthcompare_);
}
inline ::TECompareFunction TRenderMode::depthcompare() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.depthCompare)
  return _internal_depthcompare();
}
inline void TRenderMode::_internal_set_depthcompare(::TECompareFunction value) {
  assert(::TECompareFunction_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.depthcompare_ = value;
}
inline void TRenderMode::set_depthcompare(::TECompareFunction value) {
  _internal_set_depthcompare(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.depthCompare)
}

// optional bool depthWrite = 6;
inline bool TRenderMode::_internal_has_depthwrite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TRenderMode::has_depthwrite() const {
  return _internal_has_depthwrite();
}
inline void TRenderMode::clear_depthwrite() {
  _impl_.depthwrite_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TRenderMode::_internal_depthwrite() const {
  return _impl_.depthwrite_;
}
inline bool TRenderMode::depthwrite() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.depthWrite)
  return _internal_depthwrite();
}
inline void TRenderMode::_internal_set_depthwrite(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.depthwrite_ = value;
}
inline void TRenderMode::set_depthwrite(bool value) {
  _internal_set_depthwrite(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderMode.depthWrite)
}

// optional .HmiScenegraph.TRenderMode.TColorWrite colorWrite = 10;
inline bool TRenderMode::_internal_has_colorwrite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.colorwrite_ != nullptr);
  return value;
}
inline bool TRenderMode::has_colorwrite() const {
  return _internal_has_colorwrite();
}
inline void TRenderMode::clear_colorwrite() {
  if (_impl_.colorwrite_ != nullptr) _impl_.colorwrite_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::HmiScenegraph::TRenderMode_TColorWrite& TRenderMode::_internal_colorwrite() const {
  const ::HmiScenegraph::TRenderMode_TColorWrite* p = _impl_.colorwrite_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TRenderMode_TColorWrite&>(
      ::HmiScenegraph::_TRenderMode_TColorWrite_default_instance_);
}
inline const ::HmiScenegraph::TRenderMode_TColorWrite& TRenderMode::colorwrite() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.colorWrite)
  return _internal_colorwrite();
}
inline void TRenderMode::unsafe_arena_set_allocated_colorwrite(
    ::HmiScenegraph::TRenderMode_TColorWrite* colorwrite) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.colorwrite_);
  }
  _impl_.colorwrite_ = colorwrite;
  if (colorwrite) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderMode.colorWrite)
}
inline ::HmiScenegraph::TRenderMode_TColorWrite* TRenderMode::release_colorwrite() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TRenderMode_TColorWrite* temp = _impl_.colorwrite_;
  _impl_.colorwrite_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TRenderMode_TColorWrite* TRenderMode::unsafe_arena_release_colorwrite() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderMode.colorWrite)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TRenderMode_TColorWrite* temp = _impl_.colorwrite_;
  _impl_.colorwrite_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TRenderMode_TColorWrite* TRenderMode::_internal_mutable_colorwrite() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.colorwrite_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TRenderMode_TColorWrite>(GetArenaForAllocation());
    _impl_.colorwrite_ = p;
  }
  return _impl_.colorwrite_;
}
inline ::HmiScenegraph::TRenderMode_TColorWrite* TRenderMode::mutable_colorwrite() {
  ::HmiScenegraph::TRenderMode_TColorWrite* _msg = _internal_mutable_colorwrite();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderMode.colorWrite)
  return _msg;
}
inline void TRenderMode::set_allocated_colorwrite(::HmiScenegraph::TRenderMode_TColorWrite* colorwrite) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.colorwrite_;
  }
  if (colorwrite) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(colorwrite);
    if (message_arena != submessage_arena) {
      colorwrite = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorwrite, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.colorwrite_ = colorwrite;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderMode.colorWrite)
}

// optional .HmiScenegraph.TStencilMode stencilFrontFace = 7;
inline bool TRenderMode::_internal_has_stencilfrontface() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stencilfrontface_ != nullptr);
  return value;
}
inline bool TRenderMode::has_stencilfrontface() const {
  return _internal_has_stencilfrontface();
}
inline void TRenderMode::clear_stencilfrontface() {
  if (_impl_.stencilfrontface_ != nullptr) _impl_.stencilfrontface_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HmiScenegraph::TStencilMode& TRenderMode::_internal_stencilfrontface() const {
  const ::HmiScenegraph::TStencilMode* p = _impl_.stencilfrontface_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TStencilMode&>(
      ::HmiScenegraph::_TStencilMode_default_instance_);
}
inline const ::HmiScenegraph::TStencilMode& TRenderMode::stencilfrontface() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.stencilFrontFace)
  return _internal_stencilfrontface();
}
inline void TRenderMode::unsafe_arena_set_allocated_stencilfrontface(
    ::HmiScenegraph::TStencilMode* stencilfrontface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stencilfrontface_);
  }
  _impl_.stencilfrontface_ = stencilfrontface;
  if (stencilfrontface) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderMode.stencilFrontFace)
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::release_stencilfrontface() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TStencilMode* temp = _impl_.stencilfrontface_;
  _impl_.stencilfrontface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::unsafe_arena_release_stencilfrontface() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderMode.stencilFrontFace)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TStencilMode* temp = _impl_.stencilfrontface_;
  _impl_.stencilfrontface_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::_internal_mutable_stencilfrontface() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stencilfrontface_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TStencilMode>(GetArenaForAllocation());
    _impl_.stencilfrontface_ = p;
  }
  return _impl_.stencilfrontface_;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::mutable_stencilfrontface() {
  ::HmiScenegraph::TStencilMode* _msg = _internal_mutable_stencilfrontface();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderMode.stencilFrontFace)
  return _msg;
}
inline void TRenderMode::set_allocated_stencilfrontface(::HmiScenegraph::TStencilMode* stencilfrontface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stencilfrontface_;
  }
  if (stencilfrontface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stencilfrontface);
    if (message_arena != submessage_arena) {
      stencilfrontface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stencilfrontface, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stencilfrontface_ = stencilfrontface;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderMode.stencilFrontFace)
}

// optional .HmiScenegraph.TStencilMode stencilBackFace = 8;
inline bool TRenderMode::_internal_has_stencilbackface() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stencilbackface_ != nullptr);
  return value;
}
inline bool TRenderMode::has_stencilbackface() const {
  return _internal_has_stencilbackface();
}
inline void TRenderMode::clear_stencilbackface() {
  if (_impl_.stencilbackface_ != nullptr) _impl_.stencilbackface_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TStencilMode& TRenderMode::_internal_stencilbackface() const {
  const ::HmiScenegraph::TStencilMode* p = _impl_.stencilbackface_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TStencilMode&>(
      ::HmiScenegraph::_TStencilMode_default_instance_);
}
inline const ::HmiScenegraph::TStencilMode& TRenderMode::stencilbackface() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.stencilBackFace)
  return _internal_stencilbackface();
}
inline void TRenderMode::unsafe_arena_set_allocated_stencilbackface(
    ::HmiScenegraph::TStencilMode* stencilbackface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stencilbackface_);
  }
  _impl_.stencilbackface_ = stencilbackface;
  if (stencilbackface) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderMode.stencilBackFace)
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::release_stencilbackface() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TStencilMode* temp = _impl_.stencilbackface_;
  _impl_.stencilbackface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::unsafe_arena_release_stencilbackface() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderMode.stencilBackFace)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TStencilMode* temp = _impl_.stencilbackface_;
  _impl_.stencilbackface_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::_internal_mutable_stencilbackface() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stencilbackface_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TStencilMode>(GetArenaForAllocation());
    _impl_.stencilbackface_ = p;
  }
  return _impl_.stencilbackface_;
}
inline ::HmiScenegraph::TStencilMode* TRenderMode::mutable_stencilbackface() {
  ::HmiScenegraph::TStencilMode* _msg = _internal_mutable_stencilbackface();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderMode.stencilBackFace)
  return _msg;
}
inline void TRenderMode::set_allocated_stencilbackface(::HmiScenegraph::TStencilMode* stencilbackface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stencilbackface_;
  }
  if (stencilbackface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stencilbackface);
    if (message_arena != submessage_arena) {
      stencilbackface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stencilbackface, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stencilbackface_ = stencilbackface;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderMode.stencilBackFace)
}

// optional .HmiScenegraph.TScissorTest scissorTest = 9;
inline bool TRenderMode::_internal_has_scissortest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scissortest_ != nullptr);
  return value;
}
inline bool TRenderMode::has_scissortest() const {
  return _internal_has_scissortest();
}
inline void TRenderMode::clear_scissortest() {
  if (_impl_.scissortest_ != nullptr) _impl_.scissortest_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TScissorTest& TRenderMode::_internal_scissortest() const {
  const ::HmiScenegraph::TScissorTest* p = _impl_.scissortest_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TScissorTest&>(
      ::HmiScenegraph::_TScissorTest_default_instance_);
}
inline const ::HmiScenegraph::TScissorTest& TRenderMode::scissortest() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderMode.scissorTest)
  return _internal_scissortest();
}
inline void TRenderMode::unsafe_arena_set_allocated_scissortest(
    ::HmiScenegraph::TScissorTest* scissortest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scissortest_);
  }
  _impl_.scissortest_ = scissortest;
  if (scissortest) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderMode.scissorTest)
}
inline ::HmiScenegraph::TScissorTest* TRenderMode::release_scissortest() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TScissorTest* temp = _impl_.scissortest_;
  _impl_.scissortest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TScissorTest* TRenderMode::unsafe_arena_release_scissortest() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderMode.scissorTest)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TScissorTest* temp = _impl_.scissortest_;
  _impl_.scissortest_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TScissorTest* TRenderMode::_internal_mutable_scissortest() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.scissortest_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TScissorTest>(GetArenaForAllocation());
    _impl_.scissortest_ = p;
  }
  return _impl_.scissortest_;
}
inline ::HmiScenegraph::TScissorTest* TRenderMode::mutable_scissortest() {
  ::HmiScenegraph::TScissorTest* _msg = _internal_mutable_scissortest();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderMode.scissorTest)
  return _msg;
}
inline void TRenderMode::set_allocated_scissortest(::HmiScenegraph::TScissorTest* scissortest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scissortest_;
  }
  if (scissortest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scissortest);
    if (message_arena != submessage_arena) {
      scissortest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scissortest, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.scissortest_ = scissortest;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderMode.scissorTest)
}

// -------------------------------------------------------------------

// TAttributeMapping

// required .HmiScenegraph.TEAttributeUsage usage = 1;
inline bool TAttributeMapping::_internal_has_usage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TAttributeMapping::has_usage() const {
  return _internal_has_usage();
}
inline void TAttributeMapping::clear_usage() {
  _impl_.usage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HmiScenegraph::TEAttributeUsage TAttributeMapping::_internal_usage() const {
  return static_cast< ::HmiScenegraph::TEAttributeUsage >(_impl_.usage_);
}
inline ::HmiScenegraph::TEAttributeUsage TAttributeMapping::usage() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TAttributeMapping.usage)
  return _internal_usage();
}
inline void TAttributeMapping::_internal_set_usage(::HmiScenegraph::TEAttributeUsage value) {
  assert(::HmiScenegraph::TEAttributeUsage_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usage_ = value;
}
inline void TAttributeMapping::set_usage(::HmiScenegraph::TEAttributeUsage value) {
  _internal_set_usage(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TAttributeMapping.usage)
}

// optional uint32 index = 2;
inline bool TAttributeMapping::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TAttributeMapping::has_index() const {
  return _internal_has_index();
}
inline void TAttributeMapping::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TAttributeMapping::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t TAttributeMapping::index() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TAttributeMapping.index)
  return _internal_index();
}
inline void TAttributeMapping::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}
inline void TAttributeMapping::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TAttributeMapping.index)
}

// required string attributeName = 3;
inline bool TAttributeMapping::_internal_has_attributename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TAttributeMapping::has_attributename() const {
  return _internal_has_attributename();
}
inline void TAttributeMapping::clear_attributename() {
  _impl_.attributename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TAttributeMapping::attributename() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TAttributeMapping.attributeName)
  return _internal_attributename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TAttributeMapping::set_attributename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attributename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TAttributeMapping.attributeName)
}
inline std::string* TAttributeMapping::mutable_attributename() {
  std::string* _s = _internal_mutable_attributename();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TAttributeMapping.attributeName)
  return _s;
}
inline const std::string& TAttributeMapping::_internal_attributename() const {
  return _impl_.attributename_.Get();
}
inline void TAttributeMapping::_internal_set_attributename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attributename_.Set(value, GetArenaForAllocation());
}
inline std::string* TAttributeMapping::_internal_mutable_attributename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attributename_.Mutable(GetArenaForAllocation());
}
inline std::string* TAttributeMapping::release_attributename() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TAttributeMapping.attributeName)
  if (!_internal_has_attributename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attributename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributename_.IsDefault()) {
    _impl_.attributename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TAttributeMapping::set_allocated_attributename(std::string* attributename) {
  if (attributename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attributename_.SetAllocated(attributename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributename_.IsDefault()) {
    _impl_.attributename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TAttributeMapping.attributeName)
}

// -------------------------------------------------------------------

// TShader

// required string name = 1;
inline bool TShader::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TShader::has_name() const {
  return _internal_has_name();
}
inline void TShader::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TShader::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TShader::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.name)
}
inline std::string* TShader::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.name)
  return _s;
}
inline const std::string& TShader::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TShader::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TShader::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TShader::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TShader.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TShader::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TShader.name)
}

// optional .HmiScenegraph.TResourceCacheId cacheId = 7;
inline bool TShader::_internal_has_cacheid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cacheid_ != nullptr);
  return value;
}
inline bool TShader::has_cacheid() const {
  return _internal_has_cacheid();
}
inline void TShader::clear_cacheid() {
  if (_impl_.cacheid_ != nullptr) _impl_.cacheid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TResourceCacheId& TShader::_internal_cacheid() const {
  const ::HmiScenegraph::TResourceCacheId* p = _impl_.cacheid_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TResourceCacheId&>(
      ::HmiScenegraph::_TResourceCacheId_default_instance_);
}
inline const ::HmiScenegraph::TResourceCacheId& TShader::cacheid() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.cacheId)
  return _internal_cacheid();
}
inline void TShader::unsafe_arena_set_allocated_cacheid(
    ::HmiScenegraph::TResourceCacheId* cacheid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cacheid_);
  }
  _impl_.cacheid_ = cacheid;
  if (cacheid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TShader.cacheId)
}
inline ::HmiScenegraph::TResourceCacheId* TShader::release_cacheid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TShader::unsafe_arena_release_cacheid() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TShader.cacheId)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TShader::_internal_mutable_cacheid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.cacheid_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TResourceCacheId>(GetArenaForAllocation());
    _impl_.cacheid_ = p;
  }
  return _impl_.cacheid_;
}
inline ::HmiScenegraph::TResourceCacheId* TShader::mutable_cacheid() {
  ::HmiScenegraph::TResourceCacheId* _msg = _internal_mutable_cacheid();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.cacheId)
  return _msg;
}
inline void TShader::set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cacheid_;
  }
  if (cacheid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cacheid);
    if (message_arena != submessage_arena) {
      cacheid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cacheid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.cacheid_ = cacheid;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TShader.cacheId)
}

// required string vertexShader = 2;
inline bool TShader::_internal_has_vertexshader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TShader::has_vertexshader() const {
  return _internal_has_vertexshader();
}
inline void TShader::clear_vertexshader() {
  _impl_.vertexshader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TShader::vertexshader() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.vertexShader)
  return _internal_vertexshader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TShader::set_vertexshader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vertexshader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.vertexShader)
}
inline std::string* TShader::mutable_vertexshader() {
  std::string* _s = _internal_mutable_vertexshader();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.vertexShader)
  return _s;
}
inline const std::string& TShader::_internal_vertexshader() const {
  return _impl_.vertexshader_.Get();
}
inline void TShader::_internal_set_vertexshader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vertexshader_.Set(value, GetArenaForAllocation());
}
inline std::string* TShader::_internal_mutable_vertexshader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vertexshader_.Mutable(GetArenaForAllocation());
}
inline std::string* TShader::release_vertexshader() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TShader.vertexShader)
  if (!_internal_has_vertexshader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vertexshader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vertexshader_.IsDefault()) {
    _impl_.vertexshader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TShader::set_allocated_vertexshader(std::string* vertexshader) {
  if (vertexshader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vertexshader_.SetAllocated(vertexshader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vertexshader_.IsDefault()) {
    _impl_.vertexshader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TShader.vertexShader)
}

// required string fragmentShader = 3;
inline bool TShader::_internal_has_fragmentshader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TShader::has_fragmentshader() const {
  return _internal_has_fragmentshader();
}
inline void TShader::clear_fragmentshader() {
  _impl_.fragmentshader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TShader::fragmentshader() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.fragmentShader)
  return _internal_fragmentshader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TShader::set_fragmentshader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.fragmentshader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.fragmentShader)
}
inline std::string* TShader::mutable_fragmentshader() {
  std::string* _s = _internal_mutable_fragmentshader();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.fragmentShader)
  return _s;
}
inline const std::string& TShader::_internal_fragmentshader() const {
  return _impl_.fragmentshader_.Get();
}
inline void TShader::_internal_set_fragmentshader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fragmentshader_.Set(value, GetArenaForAllocation());
}
inline std::string* TShader::_internal_mutable_fragmentshader() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.fragmentshader_.Mutable(GetArenaForAllocation());
}
inline std::string* TShader::release_fragmentshader() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TShader.fragmentShader)
  if (!_internal_has_fragmentshader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.fragmentshader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fragmentshader_.IsDefault()) {
    _impl_.fragmentshader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TShader::set_allocated_fragmentshader(std::string* fragmentshader) {
  if (fragmentshader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fragmentshader_.SetAllocated(fragmentshader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fragmentshader_.IsDefault()) {
    _impl_.fragmentshader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TShader.fragmentShader)
}

// repeated .HmiScenegraph.TAttributeMapping mapping = 4;
inline int TShader::_internal_mapping_size() const {
  return _impl_.mapping_.size();
}
inline int TShader::mapping_size() const {
  return _internal_mapping_size();
}
inline void TShader::clear_mapping() {
  _impl_.mapping_.Clear();
}
inline ::HmiScenegraph::TAttributeMapping* TShader::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.mapping)
  return _impl_.mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TAttributeMapping >*
TShader::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TShader.mapping)
  return &_impl_.mapping_;
}
inline const ::HmiScenegraph::TAttributeMapping& TShader::_internal_mapping(int index) const {
  return _impl_.mapping_.Get(index);
}
inline const ::HmiScenegraph::TAttributeMapping& TShader::mapping(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.mapping)
  return _internal_mapping(index);
}
inline ::HmiScenegraph::TAttributeMapping* TShader::_internal_add_mapping() {
  return _impl_.mapping_.Add();
}
inline ::HmiScenegraph::TAttributeMapping* TShader::add_mapping() {
  ::HmiScenegraph::TAttributeMapping* _add = _internal_add_mapping();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TShader.mapping)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TAttributeMapping >&
TShader::mapping() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TShader.mapping)
  return _impl_.mapping_;
}

// repeated string compilerDefine = 5;
inline int TShader::_internal_compilerdefine_size() const {
  return _impl_.compilerdefine_.size();
}
inline int TShader::compilerdefine_size() const {
  return _internal_compilerdefine_size();
}
inline void TShader::clear_compilerdefine() {
  _impl_.compilerdefine_.Clear();
}
inline std::string* TShader::add_compilerdefine() {
  std::string* _s = _internal_add_compilerdefine();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TShader.compilerDefine)
  return _s;
}
inline const std::string& TShader::_internal_compilerdefine(int index) const {
  return _impl_.compilerdefine_.Get(index);
}
inline const std::string& TShader::compilerdefine(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.compilerDefine)
  return _internal_compilerdefine(index);
}
inline std::string* TShader::mutable_compilerdefine(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TShader.compilerDefine)
  return _impl_.compilerdefine_.Mutable(index);
}
inline void TShader::set_compilerdefine(int index, const std::string& value) {
  _impl_.compilerdefine_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::set_compilerdefine(int index, std::string&& value) {
  _impl_.compilerdefine_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::set_compilerdefine(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.compilerdefine_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::set_compilerdefine(int index, const char* value, size_t size) {
  _impl_.compilerdefine_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TShader.compilerDefine)
}
inline std::string* TShader::_internal_add_compilerdefine() {
  return _impl_.compilerdefine_.Add();
}
inline void TShader::add_compilerdefine(const std::string& value) {
  _impl_.compilerdefine_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::add_compilerdefine(std::string&& value) {
  _impl_.compilerdefine_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::add_compilerdefine(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.compilerdefine_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TShader.compilerDefine)
}
inline void TShader::add_compilerdefine(const char* value, size_t size) {
  _impl_.compilerdefine_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TShader.compilerDefine)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TShader::compilerdefine() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TShader.compilerDefine)
  return _impl_.compilerdefine_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TShader::mutable_compilerdefine() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TShader.compilerDefine)
  return &_impl_.compilerdefine_;
}

// optional .TEScope scope = 6;
inline bool TShader::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TShader::has_scope() const {
  return _internal_has_scope();
}
inline void TShader::clear_scope() {
  _impl_.scope_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TEScope TShader::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TShader::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TShader.scope)
  return _internal_scope();
}
inline void TShader::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.scope_ = value;
}
inline void TShader::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TShader.scope)
}

// -------------------------------------------------------------------

// TBitmap_TCubeMapResource

// optional string resource = 1;
inline bool TBitmap_TCubeMapResource::_internal_has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TBitmap_TCubeMapResource::has_resource() const {
  return _internal_has_resource();
}
inline void TBitmap_TCubeMapResource::clear_resource() {
  _impl_.resource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TBitmap_TCubeMapResource::resource() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMapResource.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBitmap_TCubeMapResource::set_resource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.TCubeMapResource.resource)
}
inline std::string* TBitmap_TCubeMapResource::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMapResource.resource)
  return _s;
}
inline const std::string& TBitmap_TCubeMapResource::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void TBitmap_TCubeMapResource::_internal_set_resource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* TBitmap_TCubeMapResource::_internal_mutable_resource() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* TBitmap_TCubeMapResource::release_resource() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMapResource.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBitmap_TCubeMapResource::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMapResource.resource)
}

// repeated string mipmap = 2;
inline int TBitmap_TCubeMapResource::_internal_mipmap_size() const {
  return _impl_.mipmap_.size();
}
inline int TBitmap_TCubeMapResource::mipmap_size() const {
  return _internal_mipmap_size();
}
inline void TBitmap_TCubeMapResource::clear_mipmap() {
  _impl_.mipmap_.Clear();
}
inline std::string* TBitmap_TCubeMapResource::add_mipmap() {
  std::string* _s = _internal_add_mipmap();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
  return _s;
}
inline const std::string& TBitmap_TCubeMapResource::_internal_mipmap(int index) const {
  return _impl_.mipmap_.Get(index);
}
inline const std::string& TBitmap_TCubeMapResource::mipmap(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
  return _internal_mipmap(index);
}
inline std::string* TBitmap_TCubeMapResource::mutable_mipmap(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
  return _impl_.mipmap_.Mutable(index);
}
inline void TBitmap_TCubeMapResource::set_mipmap(int index, const std::string& value) {
  _impl_.mipmap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::set_mipmap(int index, std::string&& value) {
  _impl_.mipmap_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::set_mipmap(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mipmap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::set_mipmap(int index, const char* value, size_t size) {
  _impl_.mipmap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline std::string* TBitmap_TCubeMapResource::_internal_add_mipmap() {
  return _impl_.mipmap_.Add();
}
inline void TBitmap_TCubeMapResource::add_mipmap(const std::string& value) {
  _impl_.mipmap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::add_mipmap(std::string&& value) {
  _impl_.mipmap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::add_mipmap(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mipmap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline void TBitmap_TCubeMapResource::add_mipmap(const char* value, size_t size) {
  _impl_.mipmap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TBitmap_TCubeMapResource::mipmap() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
  return _impl_.mipmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TBitmap_TCubeMapResource::mutable_mipmap() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TBitmap.TCubeMapResource.mipmap)
  return &_impl_.mipmap_;
}

// -------------------------------------------------------------------

// TBitmap_TCubeMap

// optional .HmiScenegraph.TBitmap.TCubeMapResource combined = 1;
inline bool TBitmap_TCubeMap::_internal_has_combined() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.combined_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_combined() const {
  return _internal_has_combined();
}
inline void TBitmap_TCubeMap::clear_combined() {
  if (_impl_.combined_ != nullptr) _impl_.combined_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_combined() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.combined_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::combined() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.combined)
  return _internal_combined();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_combined(
    ::HmiScenegraph::TBitmap_TCubeMapResource* combined) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.combined_);
  }
  _impl_.combined_ = combined;
  if (combined) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.combined)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_combined() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.combined_;
  _impl_.combined_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_combined() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.combined)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.combined_;
  _impl_.combined_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_combined() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.combined_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.combined_ = p;
  }
  return _impl_.combined_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_combined() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_combined();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.combined)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_combined(::HmiScenegraph::TBitmap_TCubeMapResource* combined) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.combined_;
  }
  if (combined) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(combined);
    if (message_arena != submessage_arena) {
      combined = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, combined, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.combined_ = combined;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.combined)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource positive_x = 2;
inline bool TBitmap_TCubeMap::_internal_has_positive_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.positive_x_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_positive_x() const {
  return _internal_has_positive_x();
}
inline void TBitmap_TCubeMap::clear_positive_x() {
  if (_impl_.positive_x_ != nullptr) _impl_.positive_x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_positive_x() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.positive_x_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::positive_x() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.positive_x)
  return _internal_positive_x();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_positive_x(
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_x_);
  }
  _impl_.positive_x_ = positive_x;
  if (positive_x) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_x)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_positive_x() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_x_;
  _impl_.positive_x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_positive_x() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.positive_x)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_x_;
  _impl_.positive_x_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_positive_x() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.positive_x_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.positive_x_ = p;
  }
  return _impl_.positive_x_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_positive_x() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_positive_x();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.positive_x)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_positive_x(::HmiScenegraph::TBitmap_TCubeMapResource* positive_x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.positive_x_;
  }
  if (positive_x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(positive_x);
    if (message_arena != submessage_arena) {
      positive_x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_x, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.positive_x_ = positive_x;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_x)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource negative_x = 3;
inline bool TBitmap_TCubeMap::_internal_has_negative_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.negative_x_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_negative_x() const {
  return _internal_has_negative_x();
}
inline void TBitmap_TCubeMap::clear_negative_x() {
  if (_impl_.negative_x_ != nullptr) _impl_.negative_x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_negative_x() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.negative_x_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::negative_x() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.negative_x)
  return _internal_negative_x();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_negative_x(
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_x) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negative_x_);
  }
  _impl_.negative_x_ = negative_x;
  if (negative_x) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_x)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_negative_x() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_x_;
  _impl_.negative_x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_negative_x() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.negative_x)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_x_;
  _impl_.negative_x_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_negative_x() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.negative_x_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.negative_x_ = p;
  }
  return _impl_.negative_x_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_negative_x() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_negative_x();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.negative_x)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_negative_x(::HmiScenegraph::TBitmap_TCubeMapResource* negative_x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.negative_x_;
  }
  if (negative_x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(negative_x);
    if (message_arena != submessage_arena) {
      negative_x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_x, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.negative_x_ = negative_x;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_x)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource positive_y = 4;
inline bool TBitmap_TCubeMap::_internal_has_positive_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.positive_y_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_positive_y() const {
  return _internal_has_positive_y();
}
inline void TBitmap_TCubeMap::clear_positive_y() {
  if (_impl_.positive_y_ != nullptr) _impl_.positive_y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_positive_y() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.positive_y_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::positive_y() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.positive_y)
  return _internal_positive_y();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_positive_y(
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_y_);
  }
  _impl_.positive_y_ = positive_y;
  if (positive_y) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_y)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_positive_y() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_y_;
  _impl_.positive_y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_positive_y() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.positive_y)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_y_;
  _impl_.positive_y_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_positive_y() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.positive_y_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.positive_y_ = p;
  }
  return _impl_.positive_y_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_positive_y() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_positive_y();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.positive_y)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_positive_y(::HmiScenegraph::TBitmap_TCubeMapResource* positive_y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.positive_y_;
  }
  if (positive_y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(positive_y);
    if (message_arena != submessage_arena) {
      positive_y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_y, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.positive_y_ = positive_y;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_y)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource negative_y = 5;
inline bool TBitmap_TCubeMap::_internal_has_negative_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.negative_y_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_negative_y() const {
  return _internal_has_negative_y();
}
inline void TBitmap_TCubeMap::clear_negative_y() {
  if (_impl_.negative_y_ != nullptr) _impl_.negative_y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_negative_y() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.negative_y_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::negative_y() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.negative_y)
  return _internal_negative_y();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_negative_y(
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negative_y_);
  }
  _impl_.negative_y_ = negative_y;
  if (negative_y) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_y)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_negative_y() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_y_;
  _impl_.negative_y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_negative_y() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.negative_y)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_y_;
  _impl_.negative_y_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_negative_y() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.negative_y_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.negative_y_ = p;
  }
  return _impl_.negative_y_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_negative_y() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_negative_y();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.negative_y)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_negative_y(::HmiScenegraph::TBitmap_TCubeMapResource* negative_y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.negative_y_;
  }
  if (negative_y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(negative_y);
    if (message_arena != submessage_arena) {
      negative_y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_y, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.negative_y_ = negative_y;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_y)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource positive_z = 6;
inline bool TBitmap_TCubeMap::_internal_has_positive_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.positive_z_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_positive_z() const {
  return _internal_has_positive_z();
}
inline void TBitmap_TCubeMap::clear_positive_z() {
  if (_impl_.positive_z_ != nullptr) _impl_.positive_z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_positive_z() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.positive_z_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::positive_z() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.positive_z)
  return _internal_positive_z();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_positive_z(
    ::HmiScenegraph::TBitmap_TCubeMapResource* positive_z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.positive_z_);
  }
  _impl_.positive_z_ = positive_z;
  if (positive_z) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_z)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_positive_z() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_z_;
  _impl_.positive_z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_positive_z() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.positive_z)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.positive_z_;
  _impl_.positive_z_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_positive_z() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.positive_z_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.positive_z_ = p;
  }
  return _impl_.positive_z_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_positive_z() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_positive_z();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.positive_z)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_positive_z(::HmiScenegraph::TBitmap_TCubeMapResource* positive_z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.positive_z_;
  }
  if (positive_z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(positive_z);
    if (message_arena != submessage_arena) {
      positive_z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_z, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.positive_z_ = positive_z;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.positive_z)
}

// optional .HmiScenegraph.TBitmap.TCubeMapResource negative_z = 7;
inline bool TBitmap_TCubeMap::_internal_has_negative_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.negative_z_ != nullptr);
  return value;
}
inline bool TBitmap_TCubeMap::has_negative_z() const {
  return _internal_has_negative_z();
}
inline void TBitmap_TCubeMap::clear_negative_z() {
  if (_impl_.negative_z_ != nullptr) _impl_.negative_z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::_internal_negative_z() const {
  const ::HmiScenegraph::TBitmap_TCubeMapResource* p = _impl_.negative_z_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMapResource&>(
      ::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMapResource& TBitmap_TCubeMap::negative_z() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.TCubeMap.negative_z)
  return _internal_negative_z();
}
inline void TBitmap_TCubeMap::unsafe_arena_set_allocated_negative_z(
    ::HmiScenegraph::TBitmap_TCubeMapResource* negative_z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.negative_z_);
  }
  _impl_.negative_z_ = negative_z;
  if (negative_z) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_z)
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::release_negative_z() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_z_;
  _impl_.negative_z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::unsafe_arena_release_negative_z() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.TCubeMap.negative_z)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::HmiScenegraph::TBitmap_TCubeMapResource* temp = _impl_.negative_z_;
  _impl_.negative_z_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::_internal_mutable_negative_z() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.negative_z_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMapResource>(GetArenaForAllocation());
    _impl_.negative_z_ = p;
  }
  return _impl_.negative_z_;
}
inline ::HmiScenegraph::TBitmap_TCubeMapResource* TBitmap_TCubeMap::mutable_negative_z() {
  ::HmiScenegraph::TBitmap_TCubeMapResource* _msg = _internal_mutable_negative_z();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.TCubeMap.negative_z)
  return _msg;
}
inline void TBitmap_TCubeMap::set_allocated_negative_z(::HmiScenegraph::TBitmap_TCubeMapResource* negative_z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.negative_z_;
  }
  if (negative_z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(negative_z);
    if (message_arena != submessage_arena) {
      negative_z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_z, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.negative_z_ = negative_z;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.TCubeMap.negative_z)
}

// -------------------------------------------------------------------

// TBitmap

// required string name = 1;
inline bool TBitmap::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TBitmap::has_name() const {
  return _internal_has_name();
}
inline void TBitmap::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TBitmap::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBitmap::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.name)
}
inline std::string* TBitmap::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.name)
  return _s;
}
inline const std::string& TBitmap::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TBitmap::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TBitmap::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TBitmap::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBitmap::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.name)
}

// optional string resource = 2;
inline bool TBitmap::_internal_has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TBitmap::has_resource() const {
  return _internal_has_resource();
}
inline void TBitmap::clear_resource() {
  _impl_.resource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TBitmap::resource() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBitmap::set_resource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.resource)
}
inline std::string* TBitmap::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.resource)
  return _s;
}
inline const std::string& TBitmap::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void TBitmap::_internal_set_resource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* TBitmap::_internal_mutable_resource() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* TBitmap::release_resource() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBitmap::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.resource)
}

// optional .HmiScenegraph.TResourceCacheId cacheId = 17;
inline bool TBitmap::_internal_has_cacheid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cacheid_ != nullptr);
  return value;
}
inline bool TBitmap::has_cacheid() const {
  return _internal_has_cacheid();
}
inline void TBitmap::clear_cacheid() {
  if (_impl_.cacheid_ != nullptr) _impl_.cacheid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TResourceCacheId& TBitmap::_internal_cacheid() const {
  const ::HmiScenegraph::TResourceCacheId* p = _impl_.cacheid_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TResourceCacheId&>(
      ::HmiScenegraph::_TResourceCacheId_default_instance_);
}
inline const ::HmiScenegraph::TResourceCacheId& TBitmap::cacheid() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.cacheId)
  return _internal_cacheid();
}
inline void TBitmap::unsafe_arena_set_allocated_cacheid(
    ::HmiScenegraph::TResourceCacheId* cacheid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cacheid_);
  }
  _impl_.cacheid_ = cacheid;
  if (cacheid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.cacheId)
}
inline ::HmiScenegraph::TResourceCacheId* TBitmap::release_cacheid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TBitmap::unsafe_arena_release_cacheid() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.cacheId)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TBitmap::_internal_mutable_cacheid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.cacheid_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TResourceCacheId>(GetArenaForAllocation());
    _impl_.cacheid_ = p;
  }
  return _impl_.cacheid_;
}
inline ::HmiScenegraph::TResourceCacheId* TBitmap::mutable_cacheid() {
  ::HmiScenegraph::TResourceCacheId* _msg = _internal_mutable_cacheid();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.cacheId)
  return _msg;
}
inline void TBitmap::set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cacheid_;
  }
  if (cacheid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cacheid);
    if (message_arena != submessage_arena) {
      cacheid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cacheid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.cacheid_ = cacheid;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.cacheId)
}

// optional .HmiScenegraph.TEBitmapType type = 3 [default = TEBitmapType_Resource];
inline bool TBitmap::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TBitmap::has_type() const {
  return _internal_has_type();
}
inline void TBitmap::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::HmiScenegraph::TEBitmapType TBitmap::_internal_type() const {
  return static_cast< ::HmiScenegraph::TEBitmapType >(_impl_.type_);
}
inline ::HmiScenegraph::TEBitmapType TBitmap::type() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.type)
  return _internal_type();
}
inline void TBitmap::_internal_set_type(::HmiScenegraph::TEBitmapType value) {
  assert(::HmiScenegraph::TEBitmapType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void TBitmap::set_type(::HmiScenegraph::TEBitmapType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.type)
}

// optional uint32 width = 4;
inline bool TBitmap::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TBitmap::has_width() const {
  return _internal_has_width();
}
inline void TBitmap::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TBitmap::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t TBitmap::width() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.width)
  return _internal_width();
}
inline void TBitmap::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.width_ = value;
}
inline void TBitmap::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.width)
}

// optional uint32 height = 5;
inline bool TBitmap::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TBitmap::has_height() const {
  return _internal_has_height();
}
inline void TBitmap::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TBitmap::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t TBitmap::height() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.height)
  return _internal_height();
}
inline void TBitmap::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.height_ = value;
}
inline void TBitmap::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.height)
}

// optional uint32 depth = 6;
inline bool TBitmap::_internal_has_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TBitmap::has_depth() const {
  return _internal_has_depth();
}
inline void TBitmap::clear_depth() {
  _impl_.depth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TBitmap::_internal_depth() const {
  return _impl_.depth_;
}
inline uint32_t TBitmap::depth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.depth)
  return _internal_depth();
}
inline void TBitmap::_internal_set_depth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.depth_ = value;
}
inline void TBitmap::set_depth(uint32_t value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.depth)
}

// optional uint32 samples = 7 [default = 0];
inline bool TBitmap::_internal_has_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TBitmap::has_samples() const {
  return _internal_has_samples();
}
inline void TBitmap::clear_samples() {
  _impl_.samples_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TBitmap::_internal_samples() const {
  return _impl_.samples_;
}
inline uint32_t TBitmap::samples() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.samples)
  return _internal_samples();
}
inline void TBitmap::_internal_set_samples(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.samples_ = value;
}
inline void TBitmap::set_samples(uint32_t value) {
  _internal_set_samples(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.samples)
}

// optional .TEPixelFormat pixelFormat = 8;
inline bool TBitmap::_internal_has_pixelformat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TBitmap::has_pixelformat() const {
  return _internal_has_pixelformat();
}
inline void TBitmap::clear_pixelformat() {
  _impl_.pixelformat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::TEPixelFormat TBitmap::_internal_pixelformat() const {
  return static_cast< ::TEPixelFormat >(_impl_.pixelformat_);
}
inline ::TEPixelFormat TBitmap::pixelformat() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.pixelFormat)
  return _internal_pixelformat();
}
inline void TBitmap::_internal_set_pixelformat(::TEPixelFormat value) {
  assert(::TEPixelFormat_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.pixelformat_ = value;
}
inline void TBitmap::set_pixelformat(::TEPixelFormat value) {
  _internal_set_pixelformat(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.pixelFormat)
}

// optional .HmiScenegraph.TERenderBufferAccessMode renderBufferAccessMode = 18 [default = TERenderBufferAccessMode_WriteOnly];
inline bool TBitmap::_internal_has_renderbufferaccessmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TBitmap::has_renderbufferaccessmode() const {
  return _internal_has_renderbufferaccessmode();
}
inline void TBitmap::clear_renderbufferaccessmode() {
  _impl_.renderbufferaccessmode_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::HmiScenegraph::TERenderBufferAccessMode TBitmap::_internal_renderbufferaccessmode() const {
  return static_cast< ::HmiScenegraph::TERenderBufferAccessMode >(_impl_.renderbufferaccessmode_);
}
inline ::HmiScenegraph::TERenderBufferAccessMode TBitmap::renderbufferaccessmode() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.renderBufferAccessMode)
  return _internal_renderbufferaccessmode();
}
inline void TBitmap::_internal_set_renderbufferaccessmode(::HmiScenegraph::TERenderBufferAccessMode value) {
  assert(::HmiScenegraph::TERenderBufferAccessMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.renderbufferaccessmode_ = value;
}
inline void TBitmap::set_renderbufferaccessmode(::HmiScenegraph::TERenderBufferAccessMode value) {
  _internal_set_renderbufferaccessmode(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.renderBufferAccessMode)
}

// optional .HmiScenegraph.TESemanticValue semanticWidth = 12;
inline bool TBitmap::_internal_has_semanticwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TBitmap::has_semanticwidth() const {
  return _internal_has_semanticwidth();
}
inline void TBitmap::clear_semanticwidth() {
  _impl_.semanticwidth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::HmiScenegraph::TESemanticValue TBitmap::_internal_semanticwidth() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticwidth_);
}
inline ::HmiScenegraph::TESemanticValue TBitmap::semanticwidth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.semanticWidth)
  return _internal_semanticwidth();
}
inline void TBitmap::_internal_set_semanticwidth(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.semanticwidth_ = value;
}
inline void TBitmap::set_semanticwidth(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticwidth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.semanticWidth)
}

// optional .HmiScenegraph.TESemanticValue semanticHeight = 13;
inline bool TBitmap::_internal_has_semanticheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TBitmap::has_semanticheight() const {
  return _internal_has_semanticheight();
}
inline void TBitmap::clear_semanticheight() {
  _impl_.semanticheight_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::HmiScenegraph::TESemanticValue TBitmap::_internal_semanticheight() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticheight_);
}
inline ::HmiScenegraph::TESemanticValue TBitmap::semanticheight() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.semanticHeight)
  return _internal_semanticheight();
}
inline void TBitmap::_internal_set_semanticheight(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.semanticheight_ = value;
}
inline void TBitmap::set_semanticheight(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticheight(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.semanticHeight)
}

// optional .HmiScenegraph.TESemanticValue semanticDepth = 14;
inline bool TBitmap::_internal_has_semanticdepth() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TBitmap::has_semanticdepth() const {
  return _internal_has_semanticdepth();
}
inline void TBitmap::clear_semanticdepth() {
  _impl_.semanticdepth_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::HmiScenegraph::TESemanticValue TBitmap::_internal_semanticdepth() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticdepth_);
}
inline ::HmiScenegraph::TESemanticValue TBitmap::semanticdepth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.semanticDepth)
  return _internal_semanticdepth();
}
inline void TBitmap::_internal_set_semanticdepth(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.semanticdepth_ = value;
}
inline void TBitmap::set_semanticdepth(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticdepth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.semanticDepth)
}

// optional float resolutionMultiplier = 15;
inline bool TBitmap::_internal_has_resolutionmultiplier() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TBitmap::has_resolutionmultiplier() const {
  return _internal_has_resolutionmultiplier();
}
inline void TBitmap::clear_resolutionmultiplier() {
  _impl_.resolutionmultiplier_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float TBitmap::_internal_resolutionmultiplier() const {
  return _impl_.resolutionmultiplier_;
}
inline float TBitmap::resolutionmultiplier() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.resolutionMultiplier)
  return _internal_resolutionmultiplier();
}
inline void TBitmap::_internal_set_resolutionmultiplier(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.resolutionmultiplier_ = value;
}
inline void TBitmap::set_resolutionmultiplier(float value) {
  _internal_set_resolutionmultiplier(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.resolutionMultiplier)
}

// optional bool generateMipmaps = 9;
inline bool TBitmap::_internal_has_generatemipmaps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TBitmap::has_generatemipmaps() const {
  return _internal_has_generatemipmaps();
}
inline void TBitmap::clear_generatemipmaps() {
  _impl_.generatemipmaps_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool TBitmap::_internal_generatemipmaps() const {
  return _impl_.generatemipmaps_;
}
inline bool TBitmap::generatemipmaps() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.generateMipmaps)
  return _internal_generatemipmaps();
}
inline void TBitmap::_internal_set_generatemipmaps(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.generatemipmaps_ = value;
}
inline void TBitmap::set_generatemipmaps(bool value) {
  _internal_set_generatemipmaps(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.generateMipmaps)
}

// repeated string mipmap = 10;
inline int TBitmap::_internal_mipmap_size() const {
  return _impl_.mipmap_.size();
}
inline int TBitmap::mipmap_size() const {
  return _internal_mipmap_size();
}
inline void TBitmap::clear_mipmap() {
  _impl_.mipmap_.Clear();
}
inline std::string* TBitmap::add_mipmap() {
  std::string* _s = _internal_add_mipmap();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TBitmap.mipmap)
  return _s;
}
inline const std::string& TBitmap::_internal_mipmap(int index) const {
  return _impl_.mipmap_.Get(index);
}
inline const std::string& TBitmap::mipmap(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.mipmap)
  return _internal_mipmap(index);
}
inline std::string* TBitmap::mutable_mipmap(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.mipmap)
  return _impl_.mipmap_.Mutable(index);
}
inline void TBitmap::set_mipmap(int index, const std::string& value) {
  _impl_.mipmap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::set_mipmap(int index, std::string&& value) {
  _impl_.mipmap_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::set_mipmap(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mipmap_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::set_mipmap(int index, const char* value, size_t size) {
  _impl_.mipmap_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TBitmap.mipmap)
}
inline std::string* TBitmap::_internal_add_mipmap() {
  return _impl_.mipmap_.Add();
}
inline void TBitmap::add_mipmap(const std::string& value) {
  _impl_.mipmap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::add_mipmap(std::string&& value) {
  _impl_.mipmap_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::add_mipmap(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.mipmap_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TBitmap.mipmap)
}
inline void TBitmap::add_mipmap(const char* value, size_t size) {
  _impl_.mipmap_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TBitmap.mipmap)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TBitmap::mipmap() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TBitmap.mipmap)
  return _impl_.mipmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TBitmap::mutable_mipmap() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TBitmap.mipmap)
  return &_impl_.mipmap_;
}

// optional .HmiScenegraph.TBitmap.TCubeMap cubemap = 11;
inline bool TBitmap::_internal_has_cubemap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cubemap_ != nullptr);
  return value;
}
inline bool TBitmap::has_cubemap() const {
  return _internal_has_cubemap();
}
inline void TBitmap::clear_cubemap() {
  if (_impl_.cubemap_ != nullptr) _impl_.cubemap_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TBitmap_TCubeMap& TBitmap::_internal_cubemap() const {
  const ::HmiScenegraph::TBitmap_TCubeMap* p = _impl_.cubemap_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBitmap_TCubeMap&>(
      ::HmiScenegraph::_TBitmap_TCubeMap_default_instance_);
}
inline const ::HmiScenegraph::TBitmap_TCubeMap& TBitmap::cubemap() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.cubemap)
  return _internal_cubemap();
}
inline void TBitmap::unsafe_arena_set_allocated_cubemap(
    ::HmiScenegraph::TBitmap_TCubeMap* cubemap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cubemap_);
  }
  _impl_.cubemap_ = cubemap;
  if (cubemap) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBitmap.cubemap)
}
inline ::HmiScenegraph::TBitmap_TCubeMap* TBitmap::release_cubemap() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TBitmap_TCubeMap* temp = _impl_.cubemap_;
  _impl_.cubemap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMap* TBitmap::unsafe_arena_release_cubemap() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBitmap.cubemap)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TBitmap_TCubeMap* temp = _impl_.cubemap_;
  _impl_.cubemap_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBitmap_TCubeMap* TBitmap::_internal_mutable_cubemap() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cubemap_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBitmap_TCubeMap>(GetArenaForAllocation());
    _impl_.cubemap_ = p;
  }
  return _impl_.cubemap_;
}
inline ::HmiScenegraph::TBitmap_TCubeMap* TBitmap::mutable_cubemap() {
  ::HmiScenegraph::TBitmap_TCubeMap* _msg = _internal_mutable_cubemap();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBitmap.cubemap)
  return _msg;
}
inline void TBitmap::set_allocated_cubemap(::HmiScenegraph::TBitmap_TCubeMap* cubemap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cubemap_;
  }
  if (cubemap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cubemap);
    if (message_arena != submessage_arena) {
      cubemap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cubemap, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cubemap_ = cubemap;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBitmap.cubemap)
}

// optional .TEScope scope = 16;
inline bool TBitmap::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TBitmap::has_scope() const {
  return _internal_has_scope();
}
inline void TBitmap::clear_scope() {
  _impl_.scope_ = 1;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::TEScope TBitmap::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TBitmap::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBitmap.scope)
  return _internal_scope();
}
inline void TBitmap::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.scope_ = value;
}
inline void TBitmap::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBitmap.scope)
}

// -------------------------------------------------------------------

// TTexture

// required string name = 1 [deprecated = true];
inline bool TTexture::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TTexture::has_name() const {
  return _internal_has_name();
}
inline void TTexture::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TTexture::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTexture::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.name)
}
inline std::string* TTexture::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TTexture.name)
  return _s;
}
inline const std::string& TTexture::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TTexture::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TTexture::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TTexture::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TTexture.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TTexture::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TTexture.name)
}

// required string bitmapReference = 2;
inline bool TTexture::_internal_has_bitmapreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TTexture::has_bitmapreference() const {
  return _internal_has_bitmapreference();
}
inline void TTexture::clear_bitmapreference() {
  _impl_.bitmapreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TTexture::bitmapreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.bitmapReference)
  return _internal_bitmapreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTexture::set_bitmapreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.bitmapreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.bitmapReference)
}
inline std::string* TTexture::mutable_bitmapreference() {
  std::string* _s = _internal_mutable_bitmapreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TTexture.bitmapReference)
  return _s;
}
inline const std::string& TTexture::_internal_bitmapreference() const {
  return _impl_.bitmapreference_.Get();
}
inline void TTexture::_internal_set_bitmapreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitmapreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TTexture::_internal_mutable_bitmapreference() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bitmapreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TTexture::release_bitmapreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TTexture.bitmapReference)
  if (!_internal_has_bitmapreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.bitmapreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bitmapreference_.IsDefault()) {
    _impl_.bitmapreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TTexture::set_allocated_bitmapreference(std::string* bitmapreference) {
  if (bitmapreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bitmapreference_.SetAllocated(bitmapreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bitmapreference_.IsDefault()) {
    _impl_.bitmapreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TTexture.bitmapReference)
}

// optional .TETextureFilter minFilter = 3;
inline bool TTexture::_internal_has_minfilter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TTexture::has_minfilter() const {
  return _internal_has_minfilter();
}
inline void TTexture::clear_minfilter() {
  _impl_.minfilter_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TETextureFilter TTexture::_internal_minfilter() const {
  return static_cast< ::TETextureFilter >(_impl_.minfilter_);
}
inline ::TETextureFilter TTexture::minfilter() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.minFilter)
  return _internal_minfilter();
}
inline void TTexture::_internal_set_minfilter(::TETextureFilter value) {
  assert(::TETextureFilter_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.minfilter_ = value;
}
inline void TTexture::set_minfilter(::TETextureFilter value) {
  _internal_set_minfilter(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.minFilter)
}

// optional .TETextureFilter magFilter = 4;
inline bool TTexture::_internal_has_magfilter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TTexture::has_magfilter() const {
  return _internal_has_magfilter();
}
inline void TTexture::clear_magfilter() {
  _impl_.magfilter_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::TETextureFilter TTexture::_internal_magfilter() const {
  return static_cast< ::TETextureFilter >(_impl_.magfilter_);
}
inline ::TETextureFilter TTexture::magfilter() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.magFilter)
  return _internal_magfilter();
}
inline void TTexture::_internal_set_magfilter(::TETextureFilter value) {
  assert(::TETextureFilter_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.magfilter_ = value;
}
inline void TTexture::set_magfilter(::TETextureFilter value) {
  _internal_set_magfilter(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.magFilter)
}

// optional float anisotropicSamples = 6;
inline bool TTexture::_internal_has_anisotropicsamples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TTexture::has_anisotropicsamples() const {
  return _internal_has_anisotropicsamples();
}
inline void TTexture::clear_anisotropicsamples() {
  _impl_.anisotropicsamples_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float TTexture::_internal_anisotropicsamples() const {
  return _impl_.anisotropicsamples_;
}
inline float TTexture::anisotropicsamples() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.anisotropicSamples)
  return _internal_anisotropicsamples();
}
inline void TTexture::_internal_set_anisotropicsamples(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.anisotropicsamples_ = value;
}
inline void TTexture::set_anisotropicsamples(float value) {
  _internal_set_anisotropicsamples(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.anisotropicSamples)
}

// optional .TETextureWrapMode wrapModeU = 7;
inline bool TTexture::_internal_has_wrapmodeu() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TTexture::has_wrapmodeu() const {
  return _internal_has_wrapmodeu();
}
inline void TTexture::clear_wrapmodeu() {
  _impl_.wrapmodeu_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::TETextureWrapMode TTexture::_internal_wrapmodeu() const {
  return static_cast< ::TETextureWrapMode >(_impl_.wrapmodeu_);
}
inline ::TETextureWrapMode TTexture::wrapmodeu() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.wrapModeU)
  return _internal_wrapmodeu();
}
inline void TTexture::_internal_set_wrapmodeu(::TETextureWrapMode value) {
  assert(::TETextureWrapMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.wrapmodeu_ = value;
}
inline void TTexture::set_wrapmodeu(::TETextureWrapMode value) {
  _internal_set_wrapmodeu(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.wrapModeU)
}

// optional .TETextureWrapMode wrapModeV = 8;
inline bool TTexture::_internal_has_wrapmodev() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TTexture::has_wrapmodev() const {
  return _internal_has_wrapmodev();
}
inline void TTexture::clear_wrapmodev() {
  _impl_.wrapmodev_ = 1;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::TETextureWrapMode TTexture::_internal_wrapmodev() const {
  return static_cast< ::TETextureWrapMode >(_impl_.wrapmodev_);
}
inline ::TETextureWrapMode TTexture::wrapmodev() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.wrapModeV)
  return _internal_wrapmodev();
}
inline void TTexture::_internal_set_wrapmodev(::TETextureWrapMode value) {
  assert(::TETextureWrapMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.wrapmodev_ = value;
}
inline void TTexture::set_wrapmodev(::TETextureWrapMode value) {
  _internal_set_wrapmodev(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.wrapModeV)
}

// optional string uniformName = 9;
inline bool TTexture::_internal_has_uniformname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TTexture::has_uniformname() const {
  return _internal_has_uniformname();
}
inline void TTexture::clear_uniformname() {
  _impl_.uniformname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TTexture::uniformname() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TTexture.uniformName)
  return _internal_uniformname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TTexture::set_uniformname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.uniformname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TTexture.uniformName)
}
inline std::string* TTexture::mutable_uniformname() {
  std::string* _s = _internal_mutable_uniformname();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TTexture.uniformName)
  return _s;
}
inline const std::string& TTexture::_internal_uniformname() const {
  return _impl_.uniformname_.Get();
}
inline void TTexture::_internal_set_uniformname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uniformname_.Set(value, GetArenaForAllocation());
}
inline std::string* TTexture::_internal_mutable_uniformname() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.uniformname_.Mutable(GetArenaForAllocation());
}
inline std::string* TTexture::release_uniformname() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TTexture.uniformName)
  if (!_internal_has_uniformname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.uniformname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniformname_.IsDefault()) {
    _impl_.uniformname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TTexture::set_allocated_uniformname(std::string* uniformname) {
  if (uniformname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.uniformname_.SetAllocated(uniformname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniformname_.IsDefault()) {
    _impl_.uniformname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TTexture.uniformName)
}

// -------------------------------------------------------------------

// TMaterial

// required string name = 1;
inline bool TMaterial::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMaterial::has_name() const {
  return _internal_has_name();
}
inline void TMaterial::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMaterial::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMaterial::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMaterial.name)
}
inline std::string* TMaterial::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterial.name)
  return _s;
}
inline const std::string& TMaterial::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TMaterial::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TMaterial::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TMaterial::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMaterial.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMaterial::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMaterial.name)
}

// required .HmiScenegraph.TRenderMode renderMode = 2;
inline bool TMaterial::_internal_has_rendermode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rendermode_ != nullptr);
  return value;
}
inline bool TMaterial::has_rendermode() const {
  return _internal_has_rendermode();
}
inline void TMaterial::clear_rendermode() {
  if (_impl_.rendermode_ != nullptr) _impl_.rendermode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TRenderMode& TMaterial::_internal_rendermode() const {
  const ::HmiScenegraph::TRenderMode* p = _impl_.rendermode_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TRenderMode&>(
      ::HmiScenegraph::_TRenderMode_default_instance_);
}
inline const ::HmiScenegraph::TRenderMode& TMaterial::rendermode() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.renderMode)
  return _internal_rendermode();
}
inline void TMaterial::unsafe_arena_set_allocated_rendermode(
    ::HmiScenegraph::TRenderMode* rendermode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rendermode_);
  }
  _impl_.rendermode_ = rendermode;
  if (rendermode) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TMaterial.renderMode)
}
inline ::HmiScenegraph::TRenderMode* TMaterial::release_rendermode() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TRenderMode* temp = _impl_.rendermode_;
  _impl_.rendermode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TRenderMode* TMaterial::unsafe_arena_release_rendermode() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMaterial.renderMode)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TRenderMode* temp = _impl_.rendermode_;
  _impl_.rendermode_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TRenderMode* TMaterial::_internal_mutable_rendermode() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rendermode_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TRenderMode>(GetArenaForAllocation());
    _impl_.rendermode_ = p;
  }
  return _impl_.rendermode_;
}
inline ::HmiScenegraph::TRenderMode* TMaterial::mutable_rendermode() {
  ::HmiScenegraph::TRenderMode* _msg = _internal_mutable_rendermode();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterial.renderMode)
  return _msg;
}
inline void TMaterial::set_allocated_rendermode(::HmiScenegraph::TRenderMode* rendermode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rendermode_;
  }
  if (rendermode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendermode);
    if (message_arena != submessage_arena) {
      rendermode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendermode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rendermode_ = rendermode;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMaterial.renderMode)
}

// required string shaderReference = 3;
inline bool TMaterial::_internal_has_shaderreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMaterial::has_shaderreference() const {
  return _internal_has_shaderreference();
}
inline void TMaterial::clear_shaderreference() {
  _impl_.shaderreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMaterial::shaderreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.shaderReference)
  return _internal_shaderreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMaterial::set_shaderreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.shaderreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMaterial.shaderReference)
}
inline std::string* TMaterial::mutable_shaderreference() {
  std::string* _s = _internal_mutable_shaderreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterial.shaderReference)
  return _s;
}
inline const std::string& TMaterial::_internal_shaderreference() const {
  return _impl_.shaderreference_.Get();
}
inline void TMaterial::_internal_set_shaderreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shaderreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TMaterial::_internal_mutable_shaderreference() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.shaderreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TMaterial::release_shaderreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMaterial.shaderReference)
  if (!_internal_has_shaderreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.shaderreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shaderreference_.IsDefault()) {
    _impl_.shaderreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMaterial::set_allocated_shaderreference(std::string* shaderreference) {
  if (shaderreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.shaderreference_.SetAllocated(shaderreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shaderreference_.IsDefault()) {
    _impl_.shaderreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMaterial.shaderReference)
}

// repeated .HmiScenegraph.TTexture texture = 4;
inline int TMaterial::_internal_texture_size() const {
  return _impl_.texture_.size();
}
inline int TMaterial::texture_size() const {
  return _internal_texture_size();
}
inline void TMaterial::clear_texture() {
  _impl_.texture_.Clear();
}
inline ::HmiScenegraph::TTexture* TMaterial::mutable_texture(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterial.texture)
  return _impl_.texture_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >*
TMaterial::mutable_texture() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterial.texture)
  return &_impl_.texture_;
}
inline const ::HmiScenegraph::TTexture& TMaterial::_internal_texture(int index) const {
  return _impl_.texture_.Get(index);
}
inline const ::HmiScenegraph::TTexture& TMaterial::texture(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.texture)
  return _internal_texture(index);
}
inline ::HmiScenegraph::TTexture* TMaterial::_internal_add_texture() {
  return _impl_.texture_.Add();
}
inline ::HmiScenegraph::TTexture* TMaterial::add_texture() {
  ::HmiScenegraph::TTexture* _add = _internal_add_texture();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterial.texture)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >&
TMaterial::texture() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterial.texture)
  return _impl_.texture_;
}

// optional .TEScope scope = 5;
inline bool TMaterial::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMaterial::has_scope() const {
  return _internal_has_scope();
}
inline void TMaterial::clear_scope() {
  _impl_.scope_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TEScope TMaterial::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TMaterial::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.scope)
  return _internal_scope();
}
inline void TMaterial::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.scope_ = value;
}
inline void TMaterial::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMaterial.scope)
}

// repeated .HmiScenegraph.TUniform uniform = 6;
inline int TMaterial::_internal_uniform_size() const {
  return _impl_.uniform_.size();
}
inline int TMaterial::uniform_size() const {
  return _internal_uniform_size();
}
inline void TMaterial::clear_uniform() {
  _impl_.uniform_.Clear();
}
inline ::HmiScenegraph::TUniform* TMaterial::mutable_uniform(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterial.uniform)
  return _impl_.uniform_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
TMaterial::mutable_uniform() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterial.uniform)
  return &_impl_.uniform_;
}
inline const ::HmiScenegraph::TUniform& TMaterial::_internal_uniform(int index) const {
  return _impl_.uniform_.Get(index);
}
inline const ::HmiScenegraph::TUniform& TMaterial::uniform(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterial.uniform)
  return _internal_uniform(index);
}
inline ::HmiScenegraph::TUniform* TMaterial::_internal_add_uniform() {
  return _impl_.uniform_.Add();
}
inline ::HmiScenegraph::TUniform* TMaterial::add_uniform() {
  ::HmiScenegraph::TUniform* _add = _internal_add_uniform();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterial.uniform)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
TMaterial::uniform() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterial.uniform)
  return _impl_.uniform_;
}

// -------------------------------------------------------------------

// TMesh_TAttributeParamteter

// required string name = 1;
inline bool TMesh_TAttributeParamteter::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMesh_TAttributeParamteter::has_name() const {
  return _internal_has_name();
}
inline void TMesh_TAttributeParamteter::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMesh_TAttributeParamteter::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.TAttributeParamteter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMesh_TAttributeParamteter::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.TAttributeParamteter.name)
}
inline std::string* TMesh_TAttributeParamteter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.TAttributeParamteter.name)
  return _s;
}
inline const std::string& TMesh_TAttributeParamteter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TMesh_TAttributeParamteter::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TMesh_TAttributeParamteter::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TMesh_TAttributeParamteter::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMesh.TAttributeParamteter.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMesh_TAttributeParamteter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMesh.TAttributeParamteter.name)
}

// optional .HmiScenegraph.TEAttributePrecision precision = 2;
inline bool TMesh_TAttributeParamteter::_internal_has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMesh_TAttributeParamteter::has_precision() const {
  return _internal_has_precision();
}
inline void TMesh_TAttributeParamteter::clear_precision() {
  _impl_.precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::HmiScenegraph::TEAttributePrecision TMesh_TAttributeParamteter::_internal_precision() const {
  return static_cast< ::HmiScenegraph::TEAttributePrecision >(_impl_.precision_);
}
inline ::HmiScenegraph::TEAttributePrecision TMesh_TAttributeParamteter::precision() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.TAttributeParamteter.precision)
  return _internal_precision();
}
inline void TMesh_TAttributeParamteter::_internal_set_precision(::HmiScenegraph::TEAttributePrecision value) {
  assert(::HmiScenegraph::TEAttributePrecision_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.precision_ = value;
}
inline void TMesh_TAttributeParamteter::set_precision(::HmiScenegraph::TEAttributePrecision value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.TAttributeParamteter.precision)
}

// optional .HmiScenegraph.TEAttributeSize size = 3;
inline bool TMesh_TAttributeParamteter::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMesh_TAttributeParamteter::has_size() const {
  return _internal_has_size();
}
inline void TMesh_TAttributeParamteter::clear_size() {
  _impl_.size_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HmiScenegraph::TEAttributeSize TMesh_TAttributeParamteter::_internal_size() const {
  return static_cast< ::HmiScenegraph::TEAttributeSize >(_impl_.size_);
}
inline ::HmiScenegraph::TEAttributeSize TMesh_TAttributeParamteter::size() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.TAttributeParamteter.size)
  return _internal_size();
}
inline void TMesh_TAttributeParamteter::_internal_set_size(::HmiScenegraph::TEAttributeSize value) {
  assert(::HmiScenegraph::TEAttributeSize_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.size_ = value;
}
inline void TMesh_TAttributeParamteter::set_size(::HmiScenegraph::TEAttributeSize value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.TAttributeParamteter.size)
}

// -------------------------------------------------------------------

// TMesh

// required .HmiScenegraph.TNode baseNode = 1;
inline bool TMesh::_internal_has_basenode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.basenode_ != nullptr);
  return value;
}
inline bool TMesh::has_basenode() const {
  return _internal_has_basenode();
}
inline void TMesh::clear_basenode() {
  if (_impl_.basenode_ != nullptr) _impl_.basenode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TNode& TMesh::_internal_basenode() const {
  const ::HmiScenegraph::TNode* p = _impl_.basenode_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TNode&>(
      ::HmiScenegraph::_TNode_default_instance_);
}
inline const ::HmiScenegraph::TNode& TMesh::basenode() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.baseNode)
  return _internal_basenode();
}
inline void TMesh::unsafe_arena_set_allocated_basenode(
    ::HmiScenegraph::TNode* basenode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basenode_);
  }
  _impl_.basenode_ = basenode;
  if (basenode) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TMesh.baseNode)
}
inline ::HmiScenegraph::TNode* TMesh::release_basenode() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TNode* temp = _impl_.basenode_;
  _impl_.basenode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TNode* TMesh::unsafe_arena_release_basenode() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMesh.baseNode)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TNode* temp = _impl_.basenode_;
  _impl_.basenode_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TNode* TMesh::_internal_mutable_basenode() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.basenode_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TNode>(GetArenaForAllocation());
    _impl_.basenode_ = p;
  }
  return _impl_.basenode_;
}
inline ::HmiScenegraph::TNode* TMesh::mutable_basenode() {
  ::HmiScenegraph::TNode* _msg = _internal_mutable_basenode();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.baseNode)
  return _msg;
}
inline void TMesh::set_allocated_basenode(::HmiScenegraph::TNode* basenode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.basenode_;
  }
  if (basenode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basenode);
    if (message_arena != submessage_arena) {
      basenode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basenode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.basenode_ = basenode;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMesh.baseNode)
}

// required string meshResource = 2 [deprecated = true];
inline bool TMesh::_internal_has_meshresource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMesh::has_meshresource() const {
  return _internal_has_meshresource();
}
inline void TMesh::clear_meshresource() {
  _impl_.meshresource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMesh::meshresource() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.meshResource)
  return _internal_meshresource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMesh::set_meshresource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.meshresource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.meshResource)
}
inline std::string* TMesh::mutable_meshresource() {
  std::string* _s = _internal_mutable_meshresource();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.meshResource)
  return _s;
}
inline const std::string& TMesh::_internal_meshresource() const {
  return _impl_.meshresource_.Get();
}
inline void TMesh::_internal_set_meshresource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.meshresource_.Set(value, GetArenaForAllocation());
}
inline std::string* TMesh::_internal_mutable_meshresource() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.meshresource_.Mutable(GetArenaForAllocation());
}
inline std::string* TMesh::release_meshresource() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMesh.meshResource)
  if (!_internal_has_meshresource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.meshresource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meshresource_.IsDefault()) {
    _impl_.meshresource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMesh::set_allocated_meshresource(std::string* meshresource) {
  if (meshresource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.meshresource_.SetAllocated(meshresource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meshresource_.IsDefault()) {
    _impl_.meshresource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMesh.meshResource)
}

// optional string meshReference = 7;
inline bool TMesh::_internal_has_meshreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMesh::has_meshreference() const {
  return _internal_has_meshreference();
}
inline void TMesh::clear_meshreference() {
  _impl_.meshreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMesh::meshreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.meshReference)
  return _internal_meshreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMesh::set_meshreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.meshreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.meshReference)
}
inline std::string* TMesh::mutable_meshreference() {
  std::string* _s = _internal_mutable_meshreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.meshReference)
  return _s;
}
inline const std::string& TMesh::_internal_meshreference() const {
  return _impl_.meshreference_.Get();
}
inline void TMesh::_internal_set_meshreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.meshreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TMesh::_internal_mutable_meshreference() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.meshreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TMesh::release_meshreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMesh.meshReference)
  if (!_internal_has_meshreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.meshreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meshreference_.IsDefault()) {
    _impl_.meshreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMesh::set_allocated_meshreference(std::string* meshreference) {
  if (meshreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.meshreference_.SetAllocated(meshreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.meshreference_.IsDefault()) {
    _impl_.meshreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMesh.meshReference)
}

// required string materialReference = 3;
inline bool TMesh::_internal_has_materialreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMesh::has_materialreference() const {
  return _internal_has_materialreference();
}
inline void TMesh::clear_materialreference() {
  _impl_.materialreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMesh::materialreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.materialReference)
  return _internal_materialreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TMesh::set_materialreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.materialreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.materialReference)
}
inline std::string* TMesh::mutable_materialreference() {
  std::string* _s = _internal_mutable_materialreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.materialReference)
  return _s;
}
inline const std::string& TMesh::_internal_materialreference() const {
  return _impl_.materialreference_.Get();
}
inline void TMesh::_internal_set_materialreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.materialreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TMesh::_internal_mutable_materialreference() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.materialreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TMesh::release_materialreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TMesh.materialReference)
  if (!_internal_has_materialreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.materialreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialreference_.IsDefault()) {
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TMesh::set_allocated_materialreference(std::string* materialreference) {
  if (materialreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.materialreference_.SetAllocated(materialreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialreference_.IsDefault()) {
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TMesh.materialReference)
}

// repeated .HmiScenegraph.TUniform uniform = 4;
inline int TMesh::_internal_uniform_size() const {
  return _impl_.uniform_.size();
}
inline int TMesh::uniform_size() const {
  return _internal_uniform_size();
}
inline void TMesh::clear_uniform() {
  _impl_.uniform_.Clear();
}
inline ::HmiScenegraph::TUniform* TMesh::mutable_uniform(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.uniform)
  return _impl_.uniform_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
TMesh::mutable_uniform() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMesh.uniform)
  return &_impl_.uniform_;
}
inline const ::HmiScenegraph::TUniform& TMesh::_internal_uniform(int index) const {
  return _impl_.uniform_.Get(index);
}
inline const ::HmiScenegraph::TUniform& TMesh::uniform(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.uniform)
  return _internal_uniform(index);
}
inline ::HmiScenegraph::TUniform* TMesh::_internal_add_uniform() {
  return _impl_.uniform_.Add();
}
inline ::HmiScenegraph::TUniform* TMesh::add_uniform() {
  ::HmiScenegraph::TUniform* _add = _internal_add_uniform();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMesh.uniform)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
TMesh::uniform() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMesh.uniform)
  return _impl_.uniform_;
}

// repeated .HmiScenegraph.TTexture texture = 8;
inline int TMesh::_internal_texture_size() const {
  return _impl_.texture_.size();
}
inline int TMesh::texture_size() const {
  return _internal_texture_size();
}
inline void TMesh::clear_texture() {
  _impl_.texture_.Clear();
}
inline ::HmiScenegraph::TTexture* TMesh::mutable_texture(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.texture)
  return _impl_.texture_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >*
TMesh::mutable_texture() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMesh.texture)
  return &_impl_.texture_;
}
inline const ::HmiScenegraph::TTexture& TMesh::_internal_texture(int index) const {
  return _impl_.texture_.Get(index);
}
inline const ::HmiScenegraph::TTexture& TMesh::texture(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.texture)
  return _internal_texture(index);
}
inline ::HmiScenegraph::TTexture* TMesh::_internal_add_texture() {
  return _impl_.texture_.Add();
}
inline ::HmiScenegraph::TTexture* TMesh::add_texture() {
  ::HmiScenegraph::TTexture* _add = _internal_add_texture();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMesh.texture)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TTexture >&
TMesh::texture() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMesh.texture)
  return _impl_.texture_;
}

// repeated .HmiScenegraph.TMesh.TAttributeParamteter attributeParameter = 5 [deprecated = true];
inline int TMesh::_internal_attributeparameter_size() const {
  return _impl_.attributeparameter_.size();
}
inline int TMesh::attributeparameter_size() const {
  return _internal_attributeparameter_size();
}
inline void TMesh::clear_attributeparameter() {
  _impl_.attributeparameter_.Clear();
}
inline ::HmiScenegraph::TMesh_TAttributeParamteter* TMesh::mutable_attributeparameter(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.attributeParameter)
  return _impl_.attributeparameter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh_TAttributeParamteter >*
TMesh::mutable_attributeparameter() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMesh.attributeParameter)
  return &_impl_.attributeparameter_;
}
inline const ::HmiScenegraph::TMesh_TAttributeParamteter& TMesh::_internal_attributeparameter(int index) const {
  return _impl_.attributeparameter_.Get(index);
}
inline const ::HmiScenegraph::TMesh_TAttributeParamteter& TMesh::attributeparameter(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.attributeParameter)
  return _internal_attributeparameter(index);
}
inline ::HmiScenegraph::TMesh_TAttributeParamteter* TMesh::_internal_add_attributeparameter() {
  return _impl_.attributeparameter_.Add();
}
inline ::HmiScenegraph::TMesh_TAttributeParamteter* TMesh::add_attributeparameter() {
  ::HmiScenegraph::TMesh_TAttributeParamteter* _add = _internal_add_attributeparameter();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMesh.attributeParameter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh_TAttributeParamteter >&
TMesh::attributeparameter() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMesh.attributeParameter)
  return _impl_.attributeparameter_;
}

// repeated string renderPassDependency = 6;
inline int TMesh::_internal_renderpassdependency_size() const {
  return _impl_.renderpassdependency_.size();
}
inline int TMesh::renderpassdependency_size() const {
  return _internal_renderpassdependency_size();
}
inline void TMesh::clear_renderpassdependency() {
  _impl_.renderpassdependency_.Clear();
}
inline std::string* TMesh::add_renderpassdependency() {
  std::string* _s = _internal_add_renderpassdependency();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TMesh.renderPassDependency)
  return _s;
}
inline const std::string& TMesh::_internal_renderpassdependency(int index) const {
  return _impl_.renderpassdependency_.Get(index);
}
inline const std::string& TMesh::renderpassdependency(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMesh.renderPassDependency)
  return _internal_renderpassdependency(index);
}
inline std::string* TMesh::mutable_renderpassdependency(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMesh.renderPassDependency)
  return _impl_.renderpassdependency_.Mutable(index);
}
inline void TMesh::set_renderpassdependency(int index, const std::string& value) {
  _impl_.renderpassdependency_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::set_renderpassdependency(int index, std::string&& value) {
  _impl_.renderpassdependency_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::set_renderpassdependency(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.renderpassdependency_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::set_renderpassdependency(int index, const char* value, size_t size) {
  _impl_.renderpassdependency_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TMesh.renderPassDependency)
}
inline std::string* TMesh::_internal_add_renderpassdependency() {
  return _impl_.renderpassdependency_.Add();
}
inline void TMesh::add_renderpassdependency(const std::string& value) {
  _impl_.renderpassdependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::add_renderpassdependency(std::string&& value) {
  _impl_.renderpassdependency_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::add_renderpassdependency(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.renderpassdependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TMesh.renderPassDependency)
}
inline void TMesh::add_renderpassdependency(const char* value, size_t size) {
  _impl_.renderpassdependency_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TMesh.renderPassDependency)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMesh::renderpassdependency() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMesh.renderPassDependency)
  return _impl_.renderpassdependency_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMesh::mutable_renderpassdependency() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMesh.renderPassDependency)
  return &_impl_.renderpassdependency_;
}

// -------------------------------------------------------------------

// TRenderLayer

// required .HmiScenegraph.TNode baseNode = 1;
inline bool TRenderLayer::_internal_has_basenode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.basenode_ != nullptr);
  return value;
}
inline bool TRenderLayer::has_basenode() const {
  return _internal_has_basenode();
}
inline void TRenderLayer::clear_basenode() {
  if (_impl_.basenode_ != nullptr) _impl_.basenode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TNode& TRenderLayer::_internal_basenode() const {
  const ::HmiScenegraph::TNode* p = _impl_.basenode_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TNode&>(
      ::HmiScenegraph::_TNode_default_instance_);
}
inline const ::HmiScenegraph::TNode& TRenderLayer::basenode() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.baseNode)
  return _internal_basenode();
}
inline void TRenderLayer::unsafe_arena_set_allocated_basenode(
    ::HmiScenegraph::TNode* basenode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basenode_);
  }
  _impl_.basenode_ = basenode;
  if (basenode) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderLayer.baseNode)
}
inline ::HmiScenegraph::TNode* TRenderLayer::release_basenode() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TNode* temp = _impl_.basenode_;
  _impl_.basenode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TNode* TRenderLayer::unsafe_arena_release_basenode() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderLayer.baseNode)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TNode* temp = _impl_.basenode_;
  _impl_.basenode_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TNode* TRenderLayer::_internal_mutable_basenode() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.basenode_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TNode>(GetArenaForAllocation());
    _impl_.basenode_ = p;
  }
  return _impl_.basenode_;
}
inline ::HmiScenegraph::TNode* TRenderLayer::mutable_basenode() {
  ::HmiScenegraph::TNode* _msg = _internal_mutable_basenode();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.baseNode)
  return _msg;
}
inline void TRenderLayer::set_allocated_basenode(::HmiScenegraph::TNode* basenode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.basenode_;
  }
  if (basenode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basenode);
    if (message_arena != submessage_arena) {
      basenode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basenode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.basenode_ = basenode;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderLayer.baseNode)
}

// optional string materialReference = 2;
inline bool TRenderLayer::_internal_has_materialreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TRenderLayer::has_materialreference() const {
  return _internal_has_materialreference();
}
inline void TRenderLayer::clear_materialreference() {
  _impl_.materialreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TRenderLayer::materialreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.materialReference)
  return _internal_materialreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderLayer::set_materialreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.materialreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderLayer.materialReference)
}
inline std::string* TRenderLayer::mutable_materialreference() {
  std::string* _s = _internal_mutable_materialreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.materialReference)
  return _s;
}
inline const std::string& TRenderLayer::_internal_materialreference() const {
  return _impl_.materialreference_.Get();
}
inline void TRenderLayer::_internal_set_materialreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.materialreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderLayer::_internal_mutable_materialreference() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.materialreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderLayer::release_materialreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderLayer.materialReference)
  if (!_internal_has_materialreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.materialreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialreference_.IsDefault()) {
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderLayer::set_allocated_materialreference(std::string* materialreference) {
  if (materialreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.materialreference_.SetAllocated(materialreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.materialreference_.IsDefault()) {
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderLayer.materialReference)
}

// repeated .HmiScenegraph.TUniform uniform = 3;
inline int TRenderLayer::_internal_uniform_size() const {
  return _impl_.uniform_.size();
}
inline int TRenderLayer::uniform_size() const {
  return _internal_uniform_size();
}
inline void TRenderLayer::clear_uniform() {
  _impl_.uniform_.Clear();
}
inline ::HmiScenegraph::TUniform* TRenderLayer::mutable_uniform(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.uniform)
  return _impl_.uniform_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >*
TRenderLayer::mutable_uniform() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TRenderLayer.uniform)
  return &_impl_.uniform_;
}
inline const ::HmiScenegraph::TUniform& TRenderLayer::_internal_uniform(int index) const {
  return _impl_.uniform_.Get(index);
}
inline const ::HmiScenegraph::TUniform& TRenderLayer::uniform(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.uniform)
  return _internal_uniform(index);
}
inline ::HmiScenegraph::TUniform* TRenderLayer::_internal_add_uniform() {
  return _impl_.uniform_.Add();
}
inline ::HmiScenegraph::TUniform* TRenderLayer::add_uniform() {
  ::HmiScenegraph::TUniform* _add = _internal_add_uniform();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TRenderLayer.uniform)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TUniform >&
TRenderLayer::uniform() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TRenderLayer.uniform)
  return _impl_.uniform_;
}

// optional .HmiScenegraph.TRenderPass renderPass = 4;
inline bool TRenderLayer::_internal_has_renderpass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.renderpass_ != nullptr);
  return value;
}
inline bool TRenderLayer::has_renderpass() const {
  return _internal_has_renderpass();
}
inline void TRenderLayer::clear_renderpass() {
  if (_impl_.renderpass_ != nullptr) _impl_.renderpass_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TRenderPass& TRenderLayer::_internal_renderpass() const {
  const ::HmiScenegraph::TRenderPass* p = _impl_.renderpass_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TRenderPass&>(
      ::HmiScenegraph::_TRenderPass_default_instance_);
}
inline const ::HmiScenegraph::TRenderPass& TRenderLayer::renderpass() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.renderPass)
  return _internal_renderpass();
}
inline void TRenderLayer::unsafe_arena_set_allocated_renderpass(
    ::HmiScenegraph::TRenderPass* renderpass) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.renderpass_);
  }
  _impl_.renderpass_ = renderpass;
  if (renderpass) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderLayer.renderPass)
}
inline ::HmiScenegraph::TRenderPass* TRenderLayer::release_renderpass() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TRenderPass* temp = _impl_.renderpass_;
  _impl_.renderpass_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TRenderPass* TRenderLayer::unsafe_arena_release_renderpass() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderLayer.renderPass)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TRenderPass* temp = _impl_.renderpass_;
  _impl_.renderpass_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TRenderPass* TRenderLayer::_internal_mutable_renderpass() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.renderpass_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TRenderPass>(GetArenaForAllocation());
    _impl_.renderpass_ = p;
  }
  return _impl_.renderpass_;
}
inline ::HmiScenegraph::TRenderPass* TRenderLayer::mutable_renderpass() {
  ::HmiScenegraph::TRenderPass* _msg = _internal_mutable_renderpass();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.renderPass)
  return _msg;
}
inline void TRenderLayer::set_allocated_renderpass(::HmiScenegraph::TRenderPass* renderpass) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.renderpass_;
  }
  if (renderpass) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(renderpass);
    if (message_arena != submessage_arena) {
      renderpass = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renderpass, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.renderpass_ = renderpass;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderLayer.renderPass)
}

// optional float renderTargetScale = 5 [default = 0];
inline bool TRenderLayer::_internal_has_rendertargetscale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TRenderLayer::has_rendertargetscale() const {
  return _internal_has_rendertargetscale();
}
inline void TRenderLayer::clear_rendertargetscale() {
  _impl_.rendertargetscale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float TRenderLayer::_internal_rendertargetscale() const {
  return _impl_.rendertargetscale_;
}
inline float TRenderLayer::rendertargetscale() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.renderTargetScale)
  return _internal_rendertargetscale();
}
inline void TRenderLayer::_internal_set_rendertargetscale(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rendertargetscale_ = value;
}
inline void TRenderLayer::set_rendertargetscale(float value) {
  _internal_set_rendertargetscale(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderLayer.renderTargetScale)
}

// optional string boundingBoxRootName = 6;
inline bool TRenderLayer::_internal_has_boundingboxrootname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRenderLayer::has_boundingboxrootname() const {
  return _internal_has_boundingboxrootname();
}
inline void TRenderLayer::clear_boundingboxrootname() {
  _impl_.boundingboxrootname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TRenderLayer::boundingboxrootname() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.boundingBoxRootName)
  return _internal_boundingboxrootname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderLayer::set_boundingboxrootname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.boundingboxrootname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderLayer.boundingBoxRootName)
}
inline std::string* TRenderLayer::mutable_boundingboxrootname() {
  std::string* _s = _internal_mutable_boundingboxrootname();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.boundingBoxRootName)
  return _s;
}
inline const std::string& TRenderLayer::_internal_boundingboxrootname() const {
  return _impl_.boundingboxrootname_.Get();
}
inline void TRenderLayer::_internal_set_boundingboxrootname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.boundingboxrootname_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderLayer::_internal_mutable_boundingboxrootname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.boundingboxrootname_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderLayer::release_boundingboxrootname() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderLayer.boundingBoxRootName)
  if (!_internal_has_boundingboxrootname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.boundingboxrootname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundingboxrootname_.IsDefault()) {
    _impl_.boundingboxrootname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderLayer::set_allocated_boundingboxrootname(std::string* boundingboxrootname) {
  if (boundingboxrootname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.boundingboxrootname_.SetAllocated(boundingboxrootname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.boundingboxrootname_.IsDefault()) {
    _impl_.boundingboxrootname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderLayer.boundingBoxRootName)
}

// optional int32 borderSize = 7 [default = 0];
inline bool TRenderLayer::_internal_has_bordersize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TRenderLayer::has_bordersize() const {
  return _internal_has_bordersize();
}
inline void TRenderLayer::clear_bordersize() {
  _impl_.bordersize_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t TRenderLayer::_internal_bordersize() const {
  return _impl_.bordersize_;
}
inline int32_t TRenderLayer::bordersize() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.borderSize)
  return _internal_bordersize();
}
inline void TRenderLayer::_internal_set_bordersize(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.bordersize_ = value;
}
inline void TRenderLayer::set_bordersize(int32_t value) {
  _internal_set_bordersize(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderLayer.borderSize)
}

// repeated .HmiScenegraph.TNode child = 8;
inline int TRenderLayer::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int TRenderLayer::child_size() const {
  return _internal_child_size();
}
inline void TRenderLayer::clear_child() {
  _impl_.child_.Clear();
}
inline ::HmiScenegraph::TNode* TRenderLayer::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderLayer.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >*
TRenderLayer::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TRenderLayer.child)
  return &_impl_.child_;
}
inline const ::HmiScenegraph::TNode& TRenderLayer::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::HmiScenegraph::TNode& TRenderLayer::child(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderLayer.child)
  return _internal_child(index);
}
inline ::HmiScenegraph::TNode* TRenderLayer::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::HmiScenegraph::TNode* TRenderLayer::add_child() {
  ::HmiScenegraph::TNode* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TRenderLayer.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >&
TRenderLayer::child() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TRenderLayer.child)
  return _impl_.child_;
}

// -------------------------------------------------------------------

// TBoundingVolume_TBoundingBox

// optional .TVector3f minBound = 1;
inline bool TBoundingVolume_TBoundingBox::_internal_has_minbound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minbound_ != nullptr);
  return value;
}
inline bool TBoundingVolume_TBoundingBox::has_minbound() const {
  return _internal_has_minbound();
}
inline const ::TVector3f& TBoundingVolume_TBoundingBox::_internal_minbound() const {
  const ::TVector3f* p = _impl_.minbound_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TBoundingVolume_TBoundingBox::minbound() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.TBoundingBox.minBound)
  return _internal_minbound();
}
inline void TBoundingVolume_TBoundingBox::unsafe_arena_set_allocated_minbound(
    ::TVector3f* minbound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minbound_);
  }
  _impl_.minbound_ = minbound;
  if (minbound) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingBox.minBound)
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::release_minbound() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.minbound_;
  _impl_.minbound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::unsafe_arena_release_minbound() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBoundingVolume.TBoundingBox.minBound)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.minbound_;
  _impl_.minbound_ = nullptr;
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::_internal_mutable_minbound() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.minbound_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.minbound_ = p;
  }
  return _impl_.minbound_;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::mutable_minbound() {
  ::TVector3f* _msg = _internal_mutable_minbound();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBoundingVolume.TBoundingBox.minBound)
  return _msg;
}
inline void TBoundingVolume_TBoundingBox::set_allocated_minbound(::TVector3f* minbound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.minbound_);
  }
  if (minbound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minbound));
    if (message_arena != submessage_arena) {
      minbound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minbound, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.minbound_ = minbound;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingBox.minBound)
}

// optional .TVector3f maxBound = 2;
inline bool TBoundingVolume_TBoundingBox::_internal_has_maxbound() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maxbound_ != nullptr);
  return value;
}
inline bool TBoundingVolume_TBoundingBox::has_maxbound() const {
  return _internal_has_maxbound();
}
inline const ::TVector3f& TBoundingVolume_TBoundingBox::_internal_maxbound() const {
  const ::TVector3f* p = _impl_.maxbound_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TBoundingVolume_TBoundingBox::maxbound() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.TBoundingBox.maxBound)
  return _internal_maxbound();
}
inline void TBoundingVolume_TBoundingBox::unsafe_arena_set_allocated_maxbound(
    ::TVector3f* maxbound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maxbound_);
  }
  _impl_.maxbound_ = maxbound;
  if (maxbound) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingBox.maxBound)
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::release_maxbound() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.maxbound_;
  _impl_.maxbound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::unsafe_arena_release_maxbound() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBoundingVolume.TBoundingBox.maxBound)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TVector3f* temp = _impl_.maxbound_;
  _impl_.maxbound_ = nullptr;
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::_internal_mutable_maxbound() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.maxbound_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.maxbound_ = p;
  }
  return _impl_.maxbound_;
}
inline ::TVector3f* TBoundingVolume_TBoundingBox::mutable_maxbound() {
  ::TVector3f* _msg = _internal_mutable_maxbound();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBoundingVolume.TBoundingBox.maxBound)
  return _msg;
}
inline void TBoundingVolume_TBoundingBox::set_allocated_maxbound(::TVector3f* maxbound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maxbound_);
  }
  if (maxbound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxbound));
    if (message_arena != submessage_arena) {
      maxbound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxbound, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.maxbound_ = maxbound;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingBox.maxBound)
}

// -------------------------------------------------------------------

// TBoundingVolume_TBoundingSphere

// optional .TVector3f centerPosition = 1;
inline bool TBoundingVolume_TBoundingSphere::_internal_has_centerposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.centerposition_ != nullptr);
  return value;
}
inline bool TBoundingVolume_TBoundingSphere::has_centerposition() const {
  return _internal_has_centerposition();
}
inline const ::TVector3f& TBoundingVolume_TBoundingSphere::_internal_centerposition() const {
  const ::TVector3f* p = _impl_.centerposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TBoundingVolume_TBoundingSphere::centerposition() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.TBoundingSphere.centerPosition)
  return _internal_centerposition();
}
inline void TBoundingVolume_TBoundingSphere::unsafe_arena_set_allocated_centerposition(
    ::TVector3f* centerposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.centerposition_);
  }
  _impl_.centerposition_ = centerposition;
  if (centerposition) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingSphere.centerPosition)
}
inline ::TVector3f* TBoundingVolume_TBoundingSphere::release_centerposition() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.centerposition_;
  _impl_.centerposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingSphere::unsafe_arena_release_centerposition() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBoundingVolume.TBoundingSphere.centerPosition)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TVector3f* temp = _impl_.centerposition_;
  _impl_.centerposition_ = nullptr;
  return temp;
}
inline ::TVector3f* TBoundingVolume_TBoundingSphere::_internal_mutable_centerposition() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.centerposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.centerposition_ = p;
  }
  return _impl_.centerposition_;
}
inline ::TVector3f* TBoundingVolume_TBoundingSphere::mutable_centerposition() {
  ::TVector3f* _msg = _internal_mutable_centerposition();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBoundingVolume.TBoundingSphere.centerPosition)
  return _msg;
}
inline void TBoundingVolume_TBoundingSphere::set_allocated_centerposition(::TVector3f* centerposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.centerposition_);
  }
  if (centerposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centerposition));
    if (message_arena != submessage_arena) {
      centerposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centerposition, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.centerposition_ = centerposition;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBoundingVolume.TBoundingSphere.centerPosition)
}

// optional float radius = 2;
inline bool TBoundingVolume_TBoundingSphere::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TBoundingVolume_TBoundingSphere::has_radius() const {
  return _internal_has_radius();
}
inline void TBoundingVolume_TBoundingSphere::clear_radius() {
  _impl_.radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TBoundingVolume_TBoundingSphere::_internal_radius() const {
  return _impl_.radius_;
}
inline float TBoundingVolume_TBoundingSphere::radius() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.TBoundingSphere.radius)
  return _internal_radius();
}
inline void TBoundingVolume_TBoundingSphere::_internal_set_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.radius_ = value;
}
inline void TBoundingVolume_TBoundingSphere::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBoundingVolume.TBoundingSphere.radius)
}

// -------------------------------------------------------------------

// TBoundingVolume

// optional .HmiScenegraph.TBoundingVolume.TBoundingBox boundingBox = 1;
inline bool TBoundingVolume::_internal_has_boundingbox() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boundingbox_ != nullptr);
  return value;
}
inline bool TBoundingVolume::has_boundingbox() const {
  return _internal_has_boundingbox();
}
inline void TBoundingVolume::clear_boundingbox() {
  if (_impl_.boundingbox_ != nullptr) _impl_.boundingbox_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HmiScenegraph::TBoundingVolume_TBoundingBox& TBoundingVolume::_internal_boundingbox() const {
  const ::HmiScenegraph::TBoundingVolume_TBoundingBox* p = _impl_.boundingbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBoundingVolume_TBoundingBox&>(
      ::HmiScenegraph::_TBoundingVolume_TBoundingBox_default_instance_);
}
inline const ::HmiScenegraph::TBoundingVolume_TBoundingBox& TBoundingVolume::boundingbox() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.boundingBox)
  return _internal_boundingbox();
}
inline void TBoundingVolume::unsafe_arena_set_allocated_boundingbox(
    ::HmiScenegraph::TBoundingVolume_TBoundingBox* boundingbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boundingbox_);
  }
  _impl_.boundingbox_ = boundingbox;
  if (boundingbox) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBoundingVolume.boundingBox)
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingBox* TBoundingVolume::release_boundingbox() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* temp = _impl_.boundingbox_;
  _impl_.boundingbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingBox* TBoundingVolume::unsafe_arena_release_boundingbox() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBoundingVolume.boundingBox)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* temp = _impl_.boundingbox_;
  _impl_.boundingbox_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingBox* TBoundingVolume::_internal_mutable_boundingbox() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.boundingbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBoundingVolume_TBoundingBox>(GetArenaForAllocation());
    _impl_.boundingbox_ = p;
  }
  return _impl_.boundingbox_;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingBox* TBoundingVolume::mutable_boundingbox() {
  ::HmiScenegraph::TBoundingVolume_TBoundingBox* _msg = _internal_mutable_boundingbox();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBoundingVolume.boundingBox)
  return _msg;
}
inline void TBoundingVolume::set_allocated_boundingbox(::HmiScenegraph::TBoundingVolume_TBoundingBox* boundingbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.boundingbox_;
  }
  if (boundingbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boundingbox);
    if (message_arena != submessage_arena) {
      boundingbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundingbox, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.boundingbox_ = boundingbox;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBoundingVolume.boundingBox)
}

// optional .HmiScenegraph.TBoundingVolume.TBoundingSphere boundingSphere = 2;
inline bool TBoundingVolume::_internal_has_boundingsphere() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boundingsphere_ != nullptr);
  return value;
}
inline bool TBoundingVolume::has_boundingsphere() const {
  return _internal_has_boundingsphere();
}
inline void TBoundingVolume::clear_boundingsphere() {
  if (_impl_.boundingsphere_ != nullptr) _impl_.boundingsphere_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HmiScenegraph::TBoundingVolume_TBoundingSphere& TBoundingVolume::_internal_boundingsphere() const {
  const ::HmiScenegraph::TBoundingVolume_TBoundingSphere* p = _impl_.boundingsphere_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBoundingVolume_TBoundingSphere&>(
      ::HmiScenegraph::_TBoundingVolume_TBoundingSphere_default_instance_);
}
inline const ::HmiScenegraph::TBoundingVolume_TBoundingSphere& TBoundingVolume::boundingsphere() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBoundingVolume.boundingSphere)
  return _internal_boundingsphere();
}
inline void TBoundingVolume::unsafe_arena_set_allocated_boundingsphere(
    ::HmiScenegraph::TBoundingVolume_TBoundingSphere* boundingsphere) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boundingsphere_);
  }
  _impl_.boundingsphere_ = boundingsphere;
  if (boundingsphere) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TBoundingVolume.boundingSphere)
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingSphere* TBoundingVolume::release_boundingsphere() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* temp = _impl_.boundingsphere_;
  _impl_.boundingsphere_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingSphere* TBoundingVolume::unsafe_arena_release_boundingsphere() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBoundingVolume.boundingSphere)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* temp = _impl_.boundingsphere_;
  _impl_.boundingsphere_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingSphere* TBoundingVolume::_internal_mutable_boundingsphere() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.boundingsphere_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBoundingVolume_TBoundingSphere>(GetArenaForAllocation());
    _impl_.boundingsphere_ = p;
  }
  return _impl_.boundingsphere_;
}
inline ::HmiScenegraph::TBoundingVolume_TBoundingSphere* TBoundingVolume::mutable_boundingsphere() {
  ::HmiScenegraph::TBoundingVolume_TBoundingSphere* _msg = _internal_mutable_boundingsphere();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBoundingVolume.boundingSphere)
  return _msg;
}
inline void TBoundingVolume::set_allocated_boundingsphere(::HmiScenegraph::TBoundingVolume_TBoundingSphere* boundingsphere) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.boundingsphere_;
  }
  if (boundingsphere) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boundingsphere);
    if (message_arena != submessage_arena) {
      boundingsphere = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundingsphere, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.boundingsphere_ = boundingsphere;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBoundingVolume.boundingSphere)
}

// -------------------------------------------------------------------

// TNode_TRenderPassName

// optional string name = 1;
inline bool TNode_TRenderPassName::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TNode_TRenderPassName::has_name() const {
  return _internal_has_name();
}
inline void TNode_TRenderPassName::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TNode_TRenderPassName::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.TRenderPassName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TNode_TRenderPassName::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.TRenderPassName.name)
}
inline std::string* TNode_TRenderPassName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.TRenderPassName.name)
  return _s;
}
inline const std::string& TNode_TRenderPassName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TNode_TRenderPassName::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TNode_TRenderPassName::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TNode_TRenderPassName::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.TRenderPassName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TNode_TRenderPassName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.TRenderPassName.name)
}

// optional bool enabled = 2 [default = false];
inline bool TNode_TRenderPassName::_internal_has_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TNode_TRenderPassName::has_enabled() const {
  return _internal_has_enabled();
}
inline void TNode_TRenderPassName::clear_enabled() {
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TNode_TRenderPassName::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool TNode_TRenderPassName::enabled() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.TRenderPassName.enabled)
  return _internal_enabled();
}
inline void TNode_TRenderPassName::_internal_set_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.enabled_ = value;
}
inline void TNode_TRenderPassName::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.TRenderPassName.enabled)
}

// -------------------------------------------------------------------

// TNode

// optional string name = 1;
inline bool TNode::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TNode::has_name() const {
  return _internal_has_name();
}
inline void TNode::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TNode::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TNode::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.name)
}
inline std::string* TNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.name)
  return _s;
}
inline const std::string& TNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TNode::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TNode::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TNode::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.name)
}

// optional int32 renderOrder = 2;
inline bool TNode::_internal_has_renderorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TNode::has_renderorder() const {
  return _internal_has_renderorder();
}
inline void TNode::clear_renderorder() {
  _impl_.renderorder_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t TNode::_internal_renderorder() const {
  return _impl_.renderorder_;
}
inline int32_t TNode::renderorder() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderOrder)
  return _internal_renderorder();
}
inline void TNode::_internal_set_renderorder(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.renderorder_ = value;
}
inline void TNode::set_renderorder(int32_t value) {
  _internal_set_renderorder(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.renderOrder)
}

// optional int32 childSortOrderRank = 3;
inline bool TNode::_internal_has_childsortorderrank() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TNode::has_childsortorderrank() const {
  return _internal_has_childsortorderrank();
}
inline void TNode::clear_childsortorderrank() {
  _impl_.childsortorderrank_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t TNode::_internal_childsortorderrank() const {
  return _impl_.childsortorderrank_;
}
inline int32_t TNode::childsortorderrank() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.childSortOrderRank)
  return _internal_childsortorderrank();
}
inline void TNode::_internal_set_childsortorderrank(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.childsortorderrank_ = value;
}
inline void TNode::set_childsortorderrank(int32_t value) {
  _internal_set_childsortorderrank(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.childSortOrderRank)
}

// required .TVector3f scale = 4;
inline bool TNode::_internal_has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scale_ != nullptr);
  return value;
}
inline bool TNode::has_scale() const {
  return _internal_has_scale();
}
inline const ::TVector3f& TNode::_internal_scale() const {
  const ::TVector3f* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TNode::scale() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.scale)
  return _internal_scale();
}
inline void TNode::unsafe_arena_set_allocated_scale(
    ::TVector3f* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.scale)
}
inline ::TVector3f* TNode::release_scale() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector3f* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TNode::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.scale)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TVector3f* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::TVector3f* TNode::_internal_mutable_scale() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::TVector3f* TNode::mutable_scale() {
  ::TVector3f* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.scale)
  return _msg;
}
inline void TNode::set_allocated_scale(::TVector3f* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale));
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.scale)
}

// required .TVector3f rotation = 5;
inline bool TNode::_internal_has_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rotation_ != nullptr);
  return value;
}
inline bool TNode::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::TVector3f& TNode::_internal_rotation() const {
  const ::TVector3f* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TNode::rotation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.rotation)
  return _internal_rotation();
}
inline void TNode::unsafe_arena_set_allocated_rotation(
    ::TVector3f* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.rotation)
}
inline ::TVector3f* TNode::release_rotation() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TVector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TNode::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.rotation)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TVector3f* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::TVector3f* TNode::_internal_mutable_rotation() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::TVector3f* TNode::mutable_rotation() {
  ::TVector3f* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.rotation)
  return _msg;
}
inline void TNode::set_allocated_rotation(::TVector3f* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.rotation)
}

// required .TVector3f translation = 6;
inline bool TNode::_internal_has_translation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_ != nullptr);
  return value;
}
inline bool TNode::has_translation() const {
  return _internal_has_translation();
}
inline const ::TVector3f& TNode::_internal_translation() const {
  const ::TVector3f* p = _impl_.translation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TNode::translation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.translation)
  return _internal_translation();
}
inline void TNode::unsafe_arena_set_allocated_translation(
    ::TVector3f* translation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.translation_);
  }
  _impl_.translation_ = translation;
  if (translation) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.translation)
}
inline ::TVector3f* TNode::release_translation() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TVector3f* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TNode::unsafe_arena_release_translation() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.translation)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TVector3f* temp = _impl_.translation_;
  _impl_.translation_ = nullptr;
  return temp;
}
inline ::TVector3f* TNode::_internal_mutable_translation() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.translation_ = p;
  }
  return _impl_.translation_;
}
inline ::TVector3f* TNode::mutable_translation() {
  ::TVector3f* _msg = _internal_mutable_translation();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.translation)
  return _msg;
}
inline void TNode::set_allocated_translation(::TVector3f* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.translation_);
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(translation));
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.translation)
}

// optional .TMatrix4x4f transformation = 7 [deprecated = true];
inline bool TNode::_internal_has_transformation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transformation_ != nullptr);
  return value;
}
inline bool TNode::has_transformation() const {
  return _internal_has_transformation();
}
inline const ::TMatrix4x4f& TNode::_internal_transformation() const {
  const ::TMatrix4x4f* p = _impl_.transformation_;
  return p != nullptr ? *p : reinterpret_cast<const ::TMatrix4x4f&>(
      ::_TMatrix4x4f_default_instance_);
}
inline const ::TMatrix4x4f& TNode::transformation() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.transformation)
  return _internal_transformation();
}
inline void TNode::unsafe_arena_set_allocated_transformation(
    ::TMatrix4x4f* transformation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_);
  }
  _impl_.transformation_ = transformation;
  if (transformation) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.transformation)
}
inline ::TMatrix4x4f* TNode::release_transformation() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TMatrix4x4f* temp = _impl_.transformation_;
  _impl_.transformation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TMatrix4x4f* TNode::unsafe_arena_release_transformation() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.transformation)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TMatrix4x4f* temp = _impl_.transformation_;
  _impl_.transformation_ = nullptr;
  return temp;
}
inline ::TMatrix4x4f* TNode::_internal_mutable_transformation() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.transformation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TMatrix4x4f>(GetArenaForAllocation());
    _impl_.transformation_ = p;
  }
  return _impl_.transformation_;
}
inline ::TMatrix4x4f* TNode::mutable_transformation() {
  ::TMatrix4x4f* _msg = _internal_mutable_transformation();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.transformation)
  return _msg;
}
inline void TNode::set_allocated_transformation(::TMatrix4x4f* transformation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformation_);
  }
  if (transformation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transformation));
    if (message_arena != submessage_arena) {
      transformation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transformation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.transformation_ = transformation;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.transformation)
}

// optional .HmiScenegraph.TCamera camera = 12;
inline bool TNode::_internal_has_camera() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_ != nullptr);
  return value;
}
inline bool TNode::has_camera() const {
  return _internal_has_camera();
}
inline void TNode::clear_camera() {
  if (_impl_.camera_ != nullptr) _impl_.camera_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::HmiScenegraph::TCamera& TNode::_internal_camera() const {
  const ::HmiScenegraph::TCamera* p = _impl_.camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TCamera&>(
      ::HmiScenegraph::_TCamera_default_instance_);
}
inline const ::HmiScenegraph::TCamera& TNode::camera() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.camera)
  return _internal_camera();
}
inline void TNode::unsafe_arena_set_allocated_camera(
    ::HmiScenegraph::TCamera* camera) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_);
  }
  _impl_.camera_ = camera;
  if (camera) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.camera)
}
inline ::HmiScenegraph::TCamera* TNode::release_camera() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::HmiScenegraph::TCamera* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TCamera* TNode::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.camera)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::HmiScenegraph::TCamera* temp = _impl_.camera_;
  _impl_.camera_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TCamera* TNode::_internal_mutable_camera() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TCamera>(GetArenaForAllocation());
    _impl_.camera_ = p;
  }
  return _impl_.camera_;
}
inline ::HmiScenegraph::TCamera* TNode::mutable_camera() {
  ::HmiScenegraph::TCamera* _msg = _internal_mutable_camera();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.camera)
  return _msg;
}
inline void TNode::set_allocated_camera(::HmiScenegraph::TCamera* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_;
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera);
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.camera)
}

// repeated .HmiScenegraph.TNode child = 10;
inline int TNode::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int TNode::child_size() const {
  return _internal_child_size();
}
inline void TNode::clear_child() {
  _impl_.child_.Clear();
}
inline ::HmiScenegraph::TNode* TNode::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >*
TNode::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TNode.child)
  return &_impl_.child_;
}
inline const ::HmiScenegraph::TNode& TNode::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::HmiScenegraph::TNode& TNode::child(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.child)
  return _internal_child(index);
}
inline ::HmiScenegraph::TNode* TNode::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::HmiScenegraph::TNode* TNode::add_child() {
  ::HmiScenegraph::TNode* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TNode.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode >&
TNode::child() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TNode.child)
  return _impl_.child_;
}

// repeated .HmiScenegraph.TMesh mesh = 11;
inline int TNode::_internal_mesh_size() const {
  return _impl_.mesh_.size();
}
inline int TNode::mesh_size() const {
  return _internal_mesh_size();
}
inline void TNode::clear_mesh() {
  _impl_.mesh_.Clear();
}
inline ::HmiScenegraph::TMesh* TNode::mutable_mesh(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.mesh)
  return _impl_.mesh_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh >*
TNode::mutable_mesh() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TNode.mesh)
  return &_impl_.mesh_;
}
inline const ::HmiScenegraph::TMesh& TNode::_internal_mesh(int index) const {
  return _impl_.mesh_.Get(index);
}
inline const ::HmiScenegraph::TMesh& TNode::mesh(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.mesh)
  return _internal_mesh(index);
}
inline ::HmiScenegraph::TMesh* TNode::_internal_add_mesh() {
  return _impl_.mesh_.Add();
}
inline ::HmiScenegraph::TMesh* TNode::add_mesh() {
  ::HmiScenegraph::TMesh* _add = _internal_add_mesh();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TNode.mesh)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMesh >&
TNode::mesh() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TNode.mesh)
  return _impl_.mesh_;
}

// repeated .HmiScenegraph.TRenderLayer renderLayer = 13;
inline int TNode::_internal_renderlayer_size() const {
  return _impl_.renderlayer_.size();
}
inline int TNode::renderlayer_size() const {
  return _internal_renderlayer_size();
}
inline void TNode::clear_renderlayer() {
  _impl_.renderlayer_.Clear();
}
inline ::HmiScenegraph::TRenderLayer* TNode::mutable_renderlayer(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.renderLayer)
  return _impl_.renderlayer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderLayer >*
TNode::mutable_renderlayer() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TNode.renderLayer)
  return &_impl_.renderlayer_;
}
inline const ::HmiScenegraph::TRenderLayer& TNode::_internal_renderlayer(int index) const {
  return _impl_.renderlayer_.Get(index);
}
inline const ::HmiScenegraph::TRenderLayer& TNode::renderlayer(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderLayer)
  return _internal_renderlayer(index);
}
inline ::HmiScenegraph::TRenderLayer* TNode::_internal_add_renderlayer() {
  return _impl_.renderlayer_.Add();
}
inline ::HmiScenegraph::TRenderLayer* TNode::add_renderlayer() {
  ::HmiScenegraph::TRenderLayer* _add = _internal_add_renderlayer();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TNode.renderLayer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderLayer >&
TNode::renderlayer() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TNode.renderLayer)
  return _impl_.renderlayer_;
}

// optional string lookAtTargetName = 14 [deprecated = true];
inline bool TNode::_internal_has_lookattargetname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TNode::has_lookattargetname() const {
  return _internal_has_lookattargetname();
}
inline void TNode::clear_lookattargetname() {
  _impl_.lookattargetname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TNode::lookattargetname() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.lookAtTargetName)
  return _internal_lookattargetname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TNode::set_lookattargetname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.lookattargetname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.lookAtTargetName)
}
inline std::string* TNode::mutable_lookattargetname() {
  std::string* _s = _internal_mutable_lookattargetname();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.lookAtTargetName)
  return _s;
}
inline const std::string& TNode::_internal_lookattargetname() const {
  return _impl_.lookattargetname_.Get();
}
inline void TNode::_internal_set_lookattargetname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.lookattargetname_.Set(value, GetArenaForAllocation());
}
inline std::string* TNode::_internal_mutable_lookattargetname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.lookattargetname_.Mutable(GetArenaForAllocation());
}
inline std::string* TNode::release_lookattargetname() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.lookAtTargetName)
  if (!_internal_has_lookattargetname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.lookattargetname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lookattargetname_.IsDefault()) {
    _impl_.lookattargetname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TNode::set_allocated_lookattargetname(std::string* lookattargetname) {
  if (lookattargetname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.lookattargetname_.SetAllocated(lookattargetname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lookattargetname_.IsDefault()) {
    _impl_.lookattargetname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.lookAtTargetName)
}

// optional .TVector3f lookAtUpVector = 15 [deprecated = true];
inline bool TNode::_internal_has_lookatupvector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lookatupvector_ != nullptr);
  return value;
}
inline bool TNode::has_lookatupvector() const {
  return _internal_has_lookatupvector();
}
inline const ::TVector3f& TNode::_internal_lookatupvector() const {
  const ::TVector3f* p = _impl_.lookatupvector_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector3f&>(
      ::_TVector3f_default_instance_);
}
inline const ::TVector3f& TNode::lookatupvector() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.lookAtUpVector)
  return _internal_lookatupvector();
}
inline void TNode::unsafe_arena_set_allocated_lookatupvector(
    ::TVector3f* lookatupvector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lookatupvector_);
  }
  _impl_.lookatupvector_ = lookatupvector;
  if (lookatupvector) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.lookAtUpVector)
}
inline ::TVector3f* TNode::release_lookatupvector() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TVector3f* temp = _impl_.lookatupvector_;
  _impl_.lookatupvector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector3f* TNode::unsafe_arena_release_lookatupvector() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.lookAtUpVector)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TVector3f* temp = _impl_.lookatupvector_;
  _impl_.lookatupvector_ = nullptr;
  return temp;
}
inline ::TVector3f* TNode::_internal_mutable_lookatupvector() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.lookatupvector_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector3f>(GetArenaForAllocation());
    _impl_.lookatupvector_ = p;
  }
  return _impl_.lookatupvector_;
}
inline ::TVector3f* TNode::mutable_lookatupvector() {
  ::TVector3f* _msg = _internal_mutable_lookatupvector();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.lookAtUpVector)
  return _msg;
}
inline void TNode::set_allocated_lookatupvector(::TVector3f* lookatupvector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lookatupvector_);
  }
  if (lookatupvector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lookatupvector));
    if (message_arena != submessage_arena) {
      lookatupvector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lookatupvector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.lookatupvector_ = lookatupvector;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.lookAtUpVector)
}

// optional .HmiScenegraph.TEAxis lookAtUpAxis = 16 [deprecated = true];
inline bool TNode::_internal_has_lookatupaxis() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TNode::has_lookatupaxis() const {
  return _internal_has_lookatupaxis();
}
inline void TNode::clear_lookatupaxis() {
  _impl_.lookatupaxis_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::HmiScenegraph::TEAxis TNode::_internal_lookatupaxis() const {
  return static_cast< ::HmiScenegraph::TEAxis >(_impl_.lookatupaxis_);
}
inline ::HmiScenegraph::TEAxis TNode::lookatupaxis() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.lookAtUpAxis)
  return _internal_lookatupaxis();
}
inline void TNode::_internal_set_lookatupaxis(::HmiScenegraph::TEAxis value) {
  assert(::HmiScenegraph::TEAxis_IsValid(value));
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.lookatupaxis_ = value;
}
inline void TNode::set_lookatupaxis(::HmiScenegraph::TEAxis value) {
  _internal_set_lookatupaxis(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.lookAtUpAxis)
}

// optional .HmiScenegraph.TEAxis lookAtForwardAxis = 17 [deprecated = true];
inline bool TNode::_internal_has_lookatforwardaxis() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TNode::has_lookatforwardaxis() const {
  return _internal_has_lookatforwardaxis();
}
inline void TNode::clear_lookatforwardaxis() {
  _impl_.lookatforwardaxis_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::HmiScenegraph::TEAxis TNode::_internal_lookatforwardaxis() const {
  return static_cast< ::HmiScenegraph::TEAxis >(_impl_.lookatforwardaxis_);
}
inline ::HmiScenegraph::TEAxis TNode::lookatforwardaxis() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.lookAtForwardAxis)
  return _internal_lookatforwardaxis();
}
inline void TNode::_internal_set_lookatforwardaxis(::HmiScenegraph::TEAxis value) {
  assert(::HmiScenegraph::TEAxis_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.lookatforwardaxis_ = value;
}
inline void TNode::set_lookatforwardaxis(::HmiScenegraph::TEAxis value) {
  _internal_set_lookatforwardaxis(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.lookAtForwardAxis)
}

// optional .HmiScenegraph.TEAxis lookAtAlignToTargetAxis = 18 [deprecated = true];
inline bool TNode::_internal_has_lookataligntotargetaxis() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TNode::has_lookataligntotargetaxis() const {
  return _internal_has_lookataligntotargetaxis();
}
inline void TNode::clear_lookataligntotargetaxis() {
  _impl_.lookataligntotargetaxis_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::HmiScenegraph::TEAxis TNode::_internal_lookataligntotargetaxis() const {
  return static_cast< ::HmiScenegraph::TEAxis >(_impl_.lookataligntotargetaxis_);
}
inline ::HmiScenegraph::TEAxis TNode::lookataligntotargetaxis() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.lookAtAlignToTargetAxis)
  return _internal_lookataligntotargetaxis();
}
inline void TNode::_internal_set_lookataligntotargetaxis(::HmiScenegraph::TEAxis value) {
  assert(::HmiScenegraph::TEAxis_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.lookataligntotargetaxis_ = value;
}
inline void TNode::set_lookataligntotargetaxis(::HmiScenegraph::TEAxis value) {
  _internal_set_lookataligntotargetaxis(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.lookAtAlignToTargetAxis)
}

// optional string renderPassName = 19 [deprecated = true];
inline bool TNode::_internal_has_renderpassname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TNode::has_renderpassname() const {
  return _internal_has_renderpassname();
}
inline void TNode::clear_renderpassname() {
  _impl_.renderpassname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TNode::renderpassname() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderPassName)
  return _internal_renderpassname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TNode::set_renderpassname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.renderpassname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.renderPassName)
}
inline std::string* TNode::mutable_renderpassname() {
  std::string* _s = _internal_mutable_renderpassname();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.renderPassName)
  return _s;
}
inline const std::string& TNode::_internal_renderpassname() const {
  return _impl_.renderpassname_.Get();
}
inline void TNode::_internal_set_renderpassname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.renderpassname_.Set(value, GetArenaForAllocation());
}
inline std::string* TNode::_internal_mutable_renderpassname() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.renderpassname_.Mutable(GetArenaForAllocation());
}
inline std::string* TNode::release_renderpassname() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.renderPassName)
  if (!_internal_has_renderpassname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.renderpassname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.renderpassname_.IsDefault()) {
    _impl_.renderpassname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TNode::set_allocated_renderpassname(std::string* renderpassname) {
  if (renderpassname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.renderpassname_.SetAllocated(renderpassname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.renderpassname_.IsDefault()) {
    _impl_.renderpassname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.renderPassName)
}

// optional bool renderPassEnabled = 20 [default = false, deprecated = true];
inline bool TNode::_internal_has_renderpassenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TNode::has_renderpassenabled() const {
  return _internal_has_renderpassenabled();
}
inline void TNode::clear_renderpassenabled() {
  _impl_.renderpassenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool TNode::_internal_renderpassenabled() const {
  return _impl_.renderpassenabled_;
}
inline bool TNode::renderpassenabled() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderPassEnabled)
  return _internal_renderpassenabled();
}
inline void TNode::_internal_set_renderpassenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.renderpassenabled_ = value;
}
inline void TNode::set_renderpassenabled(bool value) {
  _internal_set_renderpassenabled(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TNode.renderPassEnabled)
}

// repeated .HmiScenegraph.TNode.TRenderPassName renderPassNameEXT = 21;
inline int TNode::_internal_renderpassnameext_size() const {
  return _impl_.renderpassnameext_.size();
}
inline int TNode::renderpassnameext_size() const {
  return _internal_renderpassnameext_size();
}
inline void TNode::clear_renderpassnameext() {
  _impl_.renderpassnameext_.Clear();
}
inline ::HmiScenegraph::TNode_TRenderPassName* TNode::mutable_renderpassnameext(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.renderPassNameEXT)
  return _impl_.renderpassnameext_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode_TRenderPassName >*
TNode::mutable_renderpassnameext() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TNode.renderPassNameEXT)
  return &_impl_.renderpassnameext_;
}
inline const ::HmiScenegraph::TNode_TRenderPassName& TNode::_internal_renderpassnameext(int index) const {
  return _impl_.renderpassnameext_.Get(index);
}
inline const ::HmiScenegraph::TNode_TRenderPassName& TNode::renderpassnameext(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderPassNameEXT)
  return _internal_renderpassnameext(index);
}
inline ::HmiScenegraph::TNode_TRenderPassName* TNode::_internal_add_renderpassnameext() {
  return _impl_.renderpassnameext_.Add();
}
inline ::HmiScenegraph::TNode_TRenderPassName* TNode::add_renderpassnameext() {
  ::HmiScenegraph::TNode_TRenderPassName* _add = _internal_add_renderpassnameext();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TNode.renderPassNameEXT)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TNode_TRenderPassName >&
TNode::renderpassnameext() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TNode.renderPassNameEXT)
  return _impl_.renderpassnameext_;
}

// optional .HmiScenegraph.TBoundingVolume boundingVolume = 23;
inline bool TNode::_internal_has_boundingvolume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boundingvolume_ != nullptr);
  return value;
}
inline bool TNode::has_boundingvolume() const {
  return _internal_has_boundingvolume();
}
inline void TNode::clear_boundingvolume() {
  if (_impl_.boundingvolume_ != nullptr) _impl_.boundingvolume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::HmiScenegraph::TBoundingVolume& TNode::_internal_boundingvolume() const {
  const ::HmiScenegraph::TBoundingVolume* p = _impl_.boundingvolume_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TBoundingVolume&>(
      ::HmiScenegraph::_TBoundingVolume_default_instance_);
}
inline const ::HmiScenegraph::TBoundingVolume& TNode::boundingvolume() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.boundingVolume)
  return _internal_boundingvolume();
}
inline void TNode::unsafe_arena_set_allocated_boundingvolume(
    ::HmiScenegraph::TBoundingVolume* boundingvolume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boundingvolume_);
  }
  _impl_.boundingvolume_ = boundingvolume;
  if (boundingvolume) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.boundingVolume)
}
inline ::HmiScenegraph::TBoundingVolume* TNode::release_boundingvolume() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::HmiScenegraph::TBoundingVolume* temp = _impl_.boundingvolume_;
  _impl_.boundingvolume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume* TNode::unsafe_arena_release_boundingvolume() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.boundingVolume)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::HmiScenegraph::TBoundingVolume* temp = _impl_.boundingvolume_;
  _impl_.boundingvolume_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TBoundingVolume* TNode::_internal_mutable_boundingvolume() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.boundingvolume_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TBoundingVolume>(GetArenaForAllocation());
    _impl_.boundingvolume_ = p;
  }
  return _impl_.boundingvolume_;
}
inline ::HmiScenegraph::TBoundingVolume* TNode::mutable_boundingvolume() {
  ::HmiScenegraph::TBoundingVolume* _msg = _internal_mutable_boundingvolume();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.boundingVolume)
  return _msg;
}
inline void TNode::set_allocated_boundingvolume(::HmiScenegraph::TBoundingVolume* boundingvolume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.boundingvolume_;
  }
  if (boundingvolume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boundingvolume);
    if (message_arena != submessage_arena) {
      boundingvolume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundingvolume, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.boundingvolume_ = boundingvolume;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.boundingVolume)
}

// optional .TIdentifier renderOrderBin = 22;
inline bool TNode::_internal_has_renderorderbin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.renderorderbin_ != nullptr);
  return value;
}
inline bool TNode::has_renderorderbin() const {
  return _internal_has_renderorderbin();
}
inline const ::TIdentifier& TNode::_internal_renderorderbin() const {
  const ::TIdentifier* p = _impl_.renderorderbin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TIdentifier&>(
      ::_TIdentifier_default_instance_);
}
inline const ::TIdentifier& TNode::renderorderbin() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderOrderBin)
  return _internal_renderorderbin();
}
inline void TNode::unsafe_arena_set_allocated_renderorderbin(
    ::TIdentifier* renderorderbin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.renderorderbin_);
  }
  _impl_.renderorderbin_ = renderorderbin;
  if (renderorderbin) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TNode.renderOrderBin)
}
inline ::TIdentifier* TNode::release_renderorderbin() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TIdentifier* temp = _impl_.renderorderbin_;
  _impl_.renderorderbin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TIdentifier* TNode::unsafe_arena_release_renderorderbin() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TNode.renderOrderBin)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TIdentifier* temp = _impl_.renderorderbin_;
  _impl_.renderorderbin_ = nullptr;
  return temp;
}
inline ::TIdentifier* TNode::_internal_mutable_renderorderbin() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.renderorderbin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TIdentifier>(GetArenaForAllocation());
    _impl_.renderorderbin_ = p;
  }
  return _impl_.renderorderbin_;
}
inline ::TIdentifier* TNode::mutable_renderorderbin() {
  ::TIdentifier* _msg = _internal_mutable_renderorderbin();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.renderOrderBin)
  return _msg;
}
inline void TNode::set_allocated_renderorderbin(::TIdentifier* renderorderbin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.renderorderbin_);
  }
  if (renderorderbin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(renderorderbin));
    if (message_arena != submessage_arena) {
      renderorderbin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renderorderbin, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.renderorderbin_ = renderorderbin;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TNode.renderOrderBin)
}

// repeated .HmiScenegraph.TRenderPass renderPass = 24;
inline int TNode::_internal_renderpass_size() const {
  return _impl_.renderpass_.size();
}
inline int TNode::renderpass_size() const {
  return _internal_renderpass_size();
}
inline void TNode::clear_renderpass() {
  _impl_.renderpass_.Clear();
}
inline ::HmiScenegraph::TRenderPass* TNode::mutable_renderpass(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TNode.renderPass)
  return _impl_.renderpass_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
TNode::mutable_renderpass() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TNode.renderPass)
  return &_impl_.renderpass_;
}
inline const ::HmiScenegraph::TRenderPass& TNode::_internal_renderpass(int index) const {
  return _impl_.renderpass_.Get(index);
}
inline const ::HmiScenegraph::TRenderPass& TNode::renderpass(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TNode.renderPass)
  return _internal_renderpass(index);
}
inline ::HmiScenegraph::TRenderPass* TNode::_internal_add_renderpass() {
  return _impl_.renderpass_.Add();
}
inline ::HmiScenegraph::TRenderPass* TNode::add_renderpass() {
  ::HmiScenegraph::TRenderPass* _add = _internal_add_renderpass();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TNode.renderPass)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
TNode::renderpass() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TNode.renderPass)
  return _impl_.renderpass_;
}

// -------------------------------------------------------------------

// TRenderOrder

// -------------------------------------------------------------------

// TRenderOrderBin

// optional .TIdentifier name = 1;
inline bool TRenderOrderBin::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.name_ != nullptr);
  return value;
}
inline bool TRenderOrderBin::has_name() const {
  return _internal_has_name();
}
inline const ::TIdentifier& TRenderOrderBin::_internal_name() const {
  const ::TIdentifier* p = _impl_.name_;
  return p != nullptr ? *p : reinterpret_cast<const ::TIdentifier&>(
      ::_TIdentifier_default_instance_);
}
inline const ::TIdentifier& TRenderOrderBin::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderOrderBin.name)
  return _internal_name();
}
inline void TRenderOrderBin::unsafe_arena_set_allocated_name(
    ::TIdentifier* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  _impl_.name_ = name;
  if (name) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderOrderBin.name)
}
inline ::TIdentifier* TRenderOrderBin::release_name() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TIdentifier* temp = _impl_.name_;
  _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TIdentifier* TRenderOrderBin::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderOrderBin.name)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TIdentifier* temp = _impl_.name_;
  _impl_.name_ = nullptr;
  return temp;
}
inline ::TIdentifier* TRenderOrderBin::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.name_ == nullptr) {
    auto* p = CreateMaybeMessage<::TIdentifier>(GetArenaForAllocation());
    _impl_.name_ = p;
  }
  return _impl_.name_;
}
inline ::TIdentifier* TRenderOrderBin::mutable_name() {
  ::TIdentifier* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderOrderBin.name)
  return _msg;
}
inline void TRenderOrderBin::set_allocated_name(::TIdentifier* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name));
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_ = name;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderOrderBin.name)
}

// optional int32 renderOrderRank = 2 [default = 0];
inline bool TRenderOrderBin::_internal_has_renderorderrank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRenderOrderBin::has_renderorderrank() const {
  return _internal_has_renderorderrank();
}
inline void TRenderOrderBin::clear_renderorderrank() {
  _impl_.renderorderrank_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TRenderOrderBin::_internal_renderorderrank() const {
  return _impl_.renderorderrank_;
}
inline int32_t TRenderOrderBin::renderorderrank() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderOrderBin.renderOrderRank)
  return _internal_renderorderrank();
}
inline void TRenderOrderBin::_internal_set_renderorderrank(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.renderorderrank_ = value;
}
inline void TRenderOrderBin::set_renderorderrank(int32_t value) {
  _internal_set_renderorderrank(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderOrderBin.renderOrderRank)
}

// optional .HmiScenegraph.TERenderBinSortOrder sortOrder = 3 [default = TERenderBinSortOrder_ChildSortOrder];
inline bool TRenderOrderBin::_internal_has_sortorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TRenderOrderBin::has_sortorder() const {
  return _internal_has_sortorder();
}
inline void TRenderOrderBin::clear_sortorder() {
  _impl_.sortorder_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HmiScenegraph::TERenderBinSortOrder TRenderOrderBin::_internal_sortorder() const {
  return static_cast< ::HmiScenegraph::TERenderBinSortOrder >(_impl_.sortorder_);
}
inline ::HmiScenegraph::TERenderBinSortOrder TRenderOrderBin::sortorder() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderOrderBin.sortOrder)
  return _internal_sortorder();
}
inline void TRenderOrderBin::_internal_set_sortorder(::HmiScenegraph::TERenderBinSortOrder value) {
  assert(::HmiScenegraph::TERenderBinSortOrder_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sortorder_ = value;
}
inline void TRenderOrderBin::set_sortorder(::HmiScenegraph::TERenderBinSortOrder value) {
  _internal_set_sortorder(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderOrderBin.sortOrder)
}

// -------------------------------------------------------------------

// TRenderTarget

// optional string name = 12;
inline bool TRenderTarget::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TRenderTarget::has_name() const {
  return _internal_has_name();
}
inline void TRenderTarget::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TRenderTarget::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderTarget::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.name)
}
inline std::string* TRenderTarget::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderTarget.name)
  return _s;
}
inline const std::string& TRenderTarget::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TRenderTarget::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderTarget::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderTarget::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderTarget.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderTarget::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderTarget.name)
}

// optional uint32 width = 1;
inline bool TRenderTarget::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TRenderTarget::has_width() const {
  return _internal_has_width();
}
inline void TRenderTarget::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TRenderTarget::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t TRenderTarget::width() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.width)
  return _internal_width();
}
inline void TRenderTarget::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.width_ = value;
}
inline void TRenderTarget::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.width)
}

// optional uint32 height = 2;
inline bool TRenderTarget::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TRenderTarget::has_height() const {
  return _internal_has_height();
}
inline void TRenderTarget::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TRenderTarget::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t TRenderTarget::height() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.height)
  return _internal_height();
}
inline void TRenderTarget::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.height_ = value;
}
inline void TRenderTarget::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.height)
}

// optional int32 samples = 3 [default = 0];
inline bool TRenderTarget::_internal_has_samples() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TRenderTarget::has_samples() const {
  return _internal_has_samples();
}
inline void TRenderTarget::clear_samples() {
  _impl_.samples_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t TRenderTarget::_internal_samples() const {
  return _impl_.samples_;
}
inline int32_t TRenderTarget::samples() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.samples)
  return _internal_samples();
}
inline void TRenderTarget::_internal_set_samples(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.samples_ = value;
}
inline void TRenderTarget::set_samples(int32_t value) {
  _internal_set_samples(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.samples)
}

// optional .HmiScenegraph.TESemanticValue semanticWidth = 8;
inline bool TRenderTarget::_internal_has_semanticwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TRenderTarget::has_semanticwidth() const {
  return _internal_has_semanticwidth();
}
inline void TRenderTarget::clear_semanticwidth() {
  _impl_.semanticwidth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::_internal_semanticwidth() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticwidth_);
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::semanticwidth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.semanticWidth)
  return _internal_semanticwidth();
}
inline void TRenderTarget::_internal_set_semanticwidth(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.semanticwidth_ = value;
}
inline void TRenderTarget::set_semanticwidth(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticwidth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.semanticWidth)
}

// optional .HmiScenegraph.TESemanticValue semanticHeight = 9;
inline bool TRenderTarget::_internal_has_semanticheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TRenderTarget::has_semanticheight() const {
  return _internal_has_semanticheight();
}
inline void TRenderTarget::clear_semanticheight() {
  _impl_.semanticheight_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::_internal_semanticheight() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticheight_);
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::semanticheight() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.semanticHeight)
  return _internal_semanticheight();
}
inline void TRenderTarget::_internal_set_semanticheight(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.semanticheight_ = value;
}
inline void TRenderTarget::set_semanticheight(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticheight(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.semanticHeight)
}

// optional .HmiScenegraph.TESemanticValue semanticDepth = 10;
inline bool TRenderTarget::_internal_has_semanticdepth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TRenderTarget::has_semanticdepth() const {
  return _internal_has_semanticdepth();
}
inline void TRenderTarget::clear_semanticdepth() {
  _impl_.semanticdepth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::_internal_semanticdepth() const {
  return static_cast< ::HmiScenegraph::TESemanticValue >(_impl_.semanticdepth_);
}
inline ::HmiScenegraph::TESemanticValue TRenderTarget::semanticdepth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.semanticDepth)
  return _internal_semanticdepth();
}
inline void TRenderTarget::_internal_set_semanticdepth(::HmiScenegraph::TESemanticValue value) {
  assert(::HmiScenegraph::TESemanticValue_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.semanticdepth_ = value;
}
inline void TRenderTarget::set_semanticdepth(::HmiScenegraph::TESemanticValue value) {
  _internal_set_semanticdepth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.semanticDepth)
}

// optional float resolutionMultiplier = 11;
inline bool TRenderTarget::_internal_has_resolutionmultiplier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TRenderTarget::has_resolutionmultiplier() const {
  return _internal_has_resolutionmultiplier();
}
inline void TRenderTarget::clear_resolutionmultiplier() {
  _impl_.resolutionmultiplier_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float TRenderTarget::_internal_resolutionmultiplier() const {
  return _impl_.resolutionmultiplier_;
}
inline float TRenderTarget::resolutionmultiplier() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.resolutionMultiplier)
  return _internal_resolutionmultiplier();
}
inline void TRenderTarget::_internal_set_resolutionmultiplier(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.resolutionmultiplier_ = value;
}
inline void TRenderTarget::set_resolutionmultiplier(float value) {
  _internal_set_resolutionmultiplier(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.resolutionMultiplier)
}

// repeated string colorBuffer = 4;
inline int TRenderTarget::_internal_colorbuffer_size() const {
  return _impl_.colorbuffer_.size();
}
inline int TRenderTarget::colorbuffer_size() const {
  return _internal_colorbuffer_size();
}
inline void TRenderTarget::clear_colorbuffer() {
  _impl_.colorbuffer_.Clear();
}
inline std::string* TRenderTarget::add_colorbuffer() {
  std::string* _s = _internal_add_colorbuffer();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TRenderTarget.colorBuffer)
  return _s;
}
inline const std::string& TRenderTarget::_internal_colorbuffer(int index) const {
  return _impl_.colorbuffer_.Get(index);
}
inline const std::string& TRenderTarget::colorbuffer(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.colorBuffer)
  return _internal_colorbuffer(index);
}
inline std::string* TRenderTarget::mutable_colorbuffer(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderTarget.colorBuffer)
  return _impl_.colorbuffer_.Mutable(index);
}
inline void TRenderTarget::set_colorbuffer(int index, const std::string& value) {
  _impl_.colorbuffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::set_colorbuffer(int index, std::string&& value) {
  _impl_.colorbuffer_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::set_colorbuffer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.colorbuffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::set_colorbuffer(int index, const char* value, size_t size) {
  _impl_.colorbuffer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline std::string* TRenderTarget::_internal_add_colorbuffer() {
  return _impl_.colorbuffer_.Add();
}
inline void TRenderTarget::add_colorbuffer(const std::string& value) {
  _impl_.colorbuffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::add_colorbuffer(std::string&& value) {
  _impl_.colorbuffer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::add_colorbuffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.colorbuffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline void TRenderTarget::add_colorbuffer(const char* value, size_t size) {
  _impl_.colorbuffer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TRenderTarget.colorBuffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TRenderTarget::colorbuffer() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TRenderTarget.colorBuffer)
  return _impl_.colorbuffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TRenderTarget::mutable_colorbuffer() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TRenderTarget.colorBuffer)
  return &_impl_.colorbuffer_;
}

// optional string depthBuffer = 5;
inline bool TRenderTarget::_internal_has_depthbuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TRenderTarget::has_depthbuffer() const {
  return _internal_has_depthbuffer();
}
inline void TRenderTarget::clear_depthbuffer() {
  _impl_.depthbuffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TRenderTarget::depthbuffer() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.depthBuffer)
  return _internal_depthbuffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderTarget::set_depthbuffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.depthbuffer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.depthBuffer)
}
inline std::string* TRenderTarget::mutable_depthbuffer() {
  std::string* _s = _internal_mutable_depthbuffer();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderTarget.depthBuffer)
  return _s;
}
inline const std::string& TRenderTarget::_internal_depthbuffer() const {
  return _impl_.depthbuffer_.Get();
}
inline void TRenderTarget::_internal_set_depthbuffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.depthbuffer_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderTarget::_internal_mutable_depthbuffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.depthbuffer_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderTarget::release_depthbuffer() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderTarget.depthBuffer)
  if (!_internal_has_depthbuffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.depthbuffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.depthbuffer_.IsDefault()) {
    _impl_.depthbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderTarget::set_allocated_depthbuffer(std::string* depthbuffer) {
  if (depthbuffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.depthbuffer_.SetAllocated(depthbuffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.depthbuffer_.IsDefault()) {
    _impl_.depthbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderTarget.depthBuffer)
}

// optional string stencilBuffer = 6;
inline bool TRenderTarget::_internal_has_stencilbuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRenderTarget::has_stencilbuffer() const {
  return _internal_has_stencilbuffer();
}
inline void TRenderTarget::clear_stencilbuffer() {
  _impl_.stencilbuffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TRenderTarget::stencilbuffer() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.stencilBuffer)
  return _internal_stencilbuffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderTarget::set_stencilbuffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.stencilbuffer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.stencilBuffer)
}
inline std::string* TRenderTarget::mutable_stencilbuffer() {
  std::string* _s = _internal_mutable_stencilbuffer();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderTarget.stencilBuffer)
  return _s;
}
inline const std::string& TRenderTarget::_internal_stencilbuffer() const {
  return _impl_.stencilbuffer_.Get();
}
inline void TRenderTarget::_internal_set_stencilbuffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.stencilbuffer_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderTarget::_internal_mutable_stencilbuffer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.stencilbuffer_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderTarget::release_stencilbuffer() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderTarget.stencilBuffer)
  if (!_internal_has_stencilbuffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.stencilbuffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stencilbuffer_.IsDefault()) {
    _impl_.stencilbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderTarget::set_allocated_stencilbuffer(std::string* stencilbuffer) {
  if (stencilbuffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stencilbuffer_.SetAllocated(stencilbuffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stencilbuffer_.IsDefault()) {
    _impl_.stencilbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderTarget.stencilBuffer)
}

// optional .HmiScenegraph.TDiscardFramebuffer discardFramebuffer = 7;
inline bool TRenderTarget::_internal_has_discardframebuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.discardframebuffer_ != nullptr);
  return value;
}
inline bool TRenderTarget::has_discardframebuffer() const {
  return _internal_has_discardframebuffer();
}
inline void TRenderTarget::clear_discardframebuffer() {
  if (_impl_.discardframebuffer_ != nullptr) _impl_.discardframebuffer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TDiscardFramebuffer& TRenderTarget::_internal_discardframebuffer() const {
  const ::HmiScenegraph::TDiscardFramebuffer* p = _impl_.discardframebuffer_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TDiscardFramebuffer&>(
      ::HmiScenegraph::_TDiscardFramebuffer_default_instance_);
}
inline const ::HmiScenegraph::TDiscardFramebuffer& TRenderTarget::discardframebuffer() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.discardFramebuffer)
  return _internal_discardframebuffer();
}
inline void TRenderTarget::unsafe_arena_set_allocated_discardframebuffer(
    ::HmiScenegraph::TDiscardFramebuffer* discardframebuffer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.discardframebuffer_);
  }
  _impl_.discardframebuffer_ = discardframebuffer;
  if (discardframebuffer) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderTarget.discardFramebuffer)
}
inline ::HmiScenegraph::TDiscardFramebuffer* TRenderTarget::release_discardframebuffer() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TDiscardFramebuffer* temp = _impl_.discardframebuffer_;
  _impl_.discardframebuffer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TDiscardFramebuffer* TRenderTarget::unsafe_arena_release_discardframebuffer() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderTarget.discardFramebuffer)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TDiscardFramebuffer* temp = _impl_.discardframebuffer_;
  _impl_.discardframebuffer_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TDiscardFramebuffer* TRenderTarget::_internal_mutable_discardframebuffer() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.discardframebuffer_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TDiscardFramebuffer>(GetArenaForAllocation());
    _impl_.discardframebuffer_ = p;
  }
  return _impl_.discardframebuffer_;
}
inline ::HmiScenegraph::TDiscardFramebuffer* TRenderTarget::mutable_discardframebuffer() {
  ::HmiScenegraph::TDiscardFramebuffer* _msg = _internal_mutable_discardframebuffer();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderTarget.discardFramebuffer)
  return _msg;
}
inline void TRenderTarget::set_allocated_discardframebuffer(::HmiScenegraph::TDiscardFramebuffer* discardframebuffer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.discardframebuffer_;
  }
  if (discardframebuffer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(discardframebuffer);
    if (message_arena != submessage_arena) {
      discardframebuffer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, discardframebuffer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.discardframebuffer_ = discardframebuffer;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderTarget.discardFramebuffer)
}

// optional .TEScope scope = 14;
inline bool TRenderTarget::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TRenderTarget::has_scope() const {
  return _internal_has_scope();
}
inline void TRenderTarget::clear_scope() {
  _impl_.scope_ = 1;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::TEScope TRenderTarget::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TRenderTarget::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderTarget.scope)
  return _internal_scope();
}
inline void TRenderTarget::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.scope_ = value;
}
inline void TRenderTarget::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderTarget.scope)
}

// -------------------------------------------------------------------

// TClearMode

// optional fixed32 clearColor = 1;
inline bool TClearMode::_internal_has_clearcolor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TClearMode::has_clearcolor() const {
  return _internal_has_clearcolor();
}
inline void TClearMode::clear_clearcolor() {
  _impl_.clearcolor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TClearMode::_internal_clearcolor() const {
  return _impl_.clearcolor_;
}
inline uint32_t TClearMode::clearcolor() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TClearMode.clearColor)
  return _internal_clearcolor();
}
inline void TClearMode::_internal_set_clearcolor(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.clearcolor_ = value;
}
inline void TClearMode::set_clearcolor(uint32_t value) {
  _internal_set_clearcolor(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TClearMode.clearColor)
}

// optional float clearDepth = 2;
inline bool TClearMode::_internal_has_cleardepth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TClearMode::has_cleardepth() const {
  return _internal_has_cleardepth();
}
inline void TClearMode::clear_cleardepth() {
  _impl_.cleardepth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float TClearMode::_internal_cleardepth() const {
  return _impl_.cleardepth_;
}
inline float TClearMode::cleardepth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TClearMode.clearDepth)
  return _internal_cleardepth();
}
inline void TClearMode::_internal_set_cleardepth(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cleardepth_ = value;
}
inline void TClearMode::set_cleardepth(float value) {
  _internal_set_cleardepth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TClearMode.clearDepth)
}

// optional fixed32 clearStencil = 3;
inline bool TClearMode::_internal_has_clearstencil() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TClearMode::has_clearstencil() const {
  return _internal_has_clearstencil();
}
inline void TClearMode::clear_clearstencil() {
  _impl_.clearstencil_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TClearMode::_internal_clearstencil() const {
  return _impl_.clearstencil_;
}
inline uint32_t TClearMode::clearstencil() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TClearMode.clearStencil)
  return _internal_clearstencil();
}
inline void TClearMode::_internal_set_clearstencil(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.clearstencil_ = value;
}
inline void TClearMode::set_clearstencil(uint32_t value) {
  _internal_set_clearstencil(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TClearMode.clearStencil)
}

// -------------------------------------------------------------------

// TDiscardFramebuffer

// optional bool color = 1;
inline bool TDiscardFramebuffer::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TDiscardFramebuffer::has_color() const {
  return _internal_has_color();
}
inline void TDiscardFramebuffer::clear_color() {
  _impl_.color_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TDiscardFramebuffer::_internal_color() const {
  return _impl_.color_;
}
inline bool TDiscardFramebuffer::color() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TDiscardFramebuffer.color)
  return _internal_color();
}
inline void TDiscardFramebuffer::_internal_set_color(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.color_ = value;
}
inline void TDiscardFramebuffer::set_color(bool value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TDiscardFramebuffer.color)
}

// optional bool depth = 2;
inline bool TDiscardFramebuffer::_internal_has_depth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TDiscardFramebuffer::has_depth() const {
  return _internal_has_depth();
}
inline void TDiscardFramebuffer::clear_depth() {
  _impl_.depth_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TDiscardFramebuffer::_internal_depth() const {
  return _impl_.depth_;
}
inline bool TDiscardFramebuffer::depth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TDiscardFramebuffer.depth)
  return _internal_depth();
}
inline void TDiscardFramebuffer::_internal_set_depth(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.depth_ = value;
}
inline void TDiscardFramebuffer::set_depth(bool value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TDiscardFramebuffer.depth)
}

// optional bool stencil = 3;
inline bool TDiscardFramebuffer::_internal_has_stencil() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TDiscardFramebuffer::has_stencil() const {
  return _internal_has_stencil();
}
inline void TDiscardFramebuffer::clear_stencil() {
  _impl_.stencil_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TDiscardFramebuffer::_internal_stencil() const {
  return _impl_.stencil_;
}
inline bool TDiscardFramebuffer::stencil() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TDiscardFramebuffer.stencil)
  return _internal_stencil();
}
inline void TDiscardFramebuffer::_internal_set_stencil(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stencil_ = value;
}
inline void TDiscardFramebuffer::set_stencil(bool value) {
  _internal_set_stencil(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TDiscardFramebuffer.stencil)
}

// -------------------------------------------------------------------

// TRenderPass

// required string name = 1;
inline bool TRenderPass::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TRenderPass::has_name() const {
  return _internal_has_name();
}
inline void TRenderPass::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TRenderPass::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderPass::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.name)
}
inline std::string* TRenderPass::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.name)
  return _s;
}
inline const std::string& TRenderPass::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TRenderPass::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderPass::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderPass::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderPass::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.name)
}

// optional uint32 rank = 2;
inline bool TRenderPass::_internal_has_rank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TRenderPass::has_rank() const {
  return _internal_has_rank();
}
inline void TRenderPass::clear_rank() {
  _impl_.rank_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TRenderPass::_internal_rank() const {
  return _impl_.rank_;
}
inline uint32_t TRenderPass::rank() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.rank)
  return _internal_rank();
}
inline void TRenderPass::_internal_set_rank(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.rank_ = value;
}
inline void TRenderPass::set_rank(uint32_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.rank)
}

// optional .HmiScenegraph.TRenderOrder renderOrder = 3 [deprecated = true];
inline bool TRenderPass::_internal_has_renderorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.renderorder_ != nullptr);
  return value;
}
inline bool TRenderPass::has_renderorder() const {
  return _internal_has_renderorder();
}
inline void TRenderPass::clear_renderorder() {
  if (_impl_.renderorder_ != nullptr) _impl_.renderorder_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::HmiScenegraph::TRenderOrder& TRenderPass::_internal_renderorder() const {
  const ::HmiScenegraph::TRenderOrder* p = _impl_.renderorder_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TRenderOrder&>(
      ::HmiScenegraph::_TRenderOrder_default_instance_);
}
inline const ::HmiScenegraph::TRenderOrder& TRenderPass::renderorder() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.renderOrder)
  return _internal_renderorder();
}
inline void TRenderPass::unsafe_arena_set_allocated_renderorder(
    ::HmiScenegraph::TRenderOrder* renderorder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.renderorder_);
  }
  _impl_.renderorder_ = renderorder;
  if (renderorder) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderPass.renderOrder)
}
inline ::HmiScenegraph::TRenderOrder* TRenderPass::release_renderorder() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TRenderOrder* temp = _impl_.renderorder_;
  _impl_.renderorder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TRenderOrder* TRenderPass::unsafe_arena_release_renderorder() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.renderOrder)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::HmiScenegraph::TRenderOrder* temp = _impl_.renderorder_;
  _impl_.renderorder_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TRenderOrder* TRenderPass::_internal_mutable_renderorder() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.renderorder_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TRenderOrder>(GetArenaForAllocation());
    _impl_.renderorder_ = p;
  }
  return _impl_.renderorder_;
}
inline ::HmiScenegraph::TRenderOrder* TRenderPass::mutable_renderorder() {
  ::HmiScenegraph::TRenderOrder* _msg = _internal_mutable_renderorder();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.renderOrder)
  return _msg;
}
inline void TRenderPass::set_allocated_renderorder(::HmiScenegraph::TRenderOrder* renderorder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.renderorder_;
  }
  if (renderorder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(renderorder);
    if (message_arena != submessage_arena) {
      renderorder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renderorder, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.renderorder_ = renderorder;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.renderOrder)
}

// repeated .HmiScenegraph.TRenderOrderBin renderOrderBin = 12;
inline int TRenderPass::_internal_renderorderbin_size() const {
  return _impl_.renderorderbin_.size();
}
inline int TRenderPass::renderorderbin_size() const {
  return _internal_renderorderbin_size();
}
inline void TRenderPass::clear_renderorderbin() {
  _impl_.renderorderbin_.Clear();
}
inline ::HmiScenegraph::TRenderOrderBin* TRenderPass::mutable_renderorderbin(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.renderOrderBin)
  return _impl_.renderorderbin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderOrderBin >*
TRenderPass::mutable_renderorderbin() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TRenderPass.renderOrderBin)
  return &_impl_.renderorderbin_;
}
inline const ::HmiScenegraph::TRenderOrderBin& TRenderPass::_internal_renderorderbin(int index) const {
  return _impl_.renderorderbin_.Get(index);
}
inline const ::HmiScenegraph::TRenderOrderBin& TRenderPass::renderorderbin(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.renderOrderBin)
  return _internal_renderorderbin(index);
}
inline ::HmiScenegraph::TRenderOrderBin* TRenderPass::_internal_add_renderorderbin() {
  return _impl_.renderorderbin_.Add();
}
inline ::HmiScenegraph::TRenderOrderBin* TRenderPass::add_renderorderbin() {
  ::HmiScenegraph::TRenderOrderBin* _add = _internal_add_renderorderbin();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TRenderPass.renderOrderBin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderOrderBin >&
TRenderPass::renderorderbin() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TRenderPass.renderOrderBin)
  return _impl_.renderorderbin_;
}

// optional .HmiScenegraph.TRenderTarget renderTarget = 4;
inline bool TRenderPass::_internal_has_rendertarget() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rendertarget_ != nullptr);
  return value;
}
inline bool TRenderPass::has_rendertarget() const {
  return _internal_has_rendertarget();
}
inline void TRenderPass::clear_rendertarget() {
  if (_impl_.rendertarget_ != nullptr) _impl_.rendertarget_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::HmiScenegraph::TRenderTarget& TRenderPass::_internal_rendertarget() const {
  const ::HmiScenegraph::TRenderTarget* p = _impl_.rendertarget_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TRenderTarget&>(
      ::HmiScenegraph::_TRenderTarget_default_instance_);
}
inline const ::HmiScenegraph::TRenderTarget& TRenderPass::rendertarget() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.renderTarget)
  return _internal_rendertarget();
}
inline void TRenderPass::unsafe_arena_set_allocated_rendertarget(
    ::HmiScenegraph::TRenderTarget* rendertarget) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rendertarget_);
  }
  _impl_.rendertarget_ = rendertarget;
  if (rendertarget) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderPass.renderTarget)
}
inline ::HmiScenegraph::TRenderTarget* TRenderPass::release_rendertarget() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TRenderTarget* temp = _impl_.rendertarget_;
  _impl_.rendertarget_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TRenderTarget* TRenderPass::unsafe_arena_release_rendertarget() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.renderTarget)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::HmiScenegraph::TRenderTarget* temp = _impl_.rendertarget_;
  _impl_.rendertarget_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TRenderTarget* TRenderPass::_internal_mutable_rendertarget() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.rendertarget_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TRenderTarget>(GetArenaForAllocation());
    _impl_.rendertarget_ = p;
  }
  return _impl_.rendertarget_;
}
inline ::HmiScenegraph::TRenderTarget* TRenderPass::mutable_rendertarget() {
  ::HmiScenegraph::TRenderTarget* _msg = _internal_mutable_rendertarget();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.renderTarget)
  return _msg;
}
inline void TRenderPass::set_allocated_rendertarget(::HmiScenegraph::TRenderTarget* rendertarget) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rendertarget_;
  }
  if (rendertarget) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendertarget);
    if (message_arena != submessage_arena) {
      rendertarget = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendertarget, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rendertarget_ = rendertarget;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.renderTarget)
}

// optional string renderTargetReference = 11;
inline bool TRenderPass::_internal_has_rendertargetreference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TRenderPass::has_rendertargetreference() const {
  return _internal_has_rendertargetreference();
}
inline void TRenderPass::clear_rendertargetreference() {
  _impl_.rendertargetreference_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TRenderPass::rendertargetreference() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.renderTargetReference)
  return _internal_rendertargetreference();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderPass::set_rendertargetreference(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.rendertargetreference_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.renderTargetReference)
}
inline std::string* TRenderPass::mutable_rendertargetreference() {
  std::string* _s = _internal_mutable_rendertargetreference();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.renderTargetReference)
  return _s;
}
inline const std::string& TRenderPass::_internal_rendertargetreference() const {
  return _impl_.rendertargetreference_.Get();
}
inline void TRenderPass::_internal_set_rendertargetreference(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rendertargetreference_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderPass::_internal_mutable_rendertargetreference() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.rendertargetreference_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderPass::release_rendertargetreference() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.renderTargetReference)
  if (!_internal_has_rendertargetreference()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.rendertargetreference_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rendertargetreference_.IsDefault()) {
    _impl_.rendertargetreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderPass::set_allocated_rendertargetreference(std::string* rendertargetreference) {
  if (rendertargetreference != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rendertargetreference_.SetAllocated(rendertargetreference, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rendertargetreference_.IsDefault()) {
    _impl_.rendertargetreference_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.renderTargetReference)
}

// optional .HmiScenegraph.TClearMode clearMode = 5;
inline bool TRenderPass::_internal_has_clearmode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.clearmode_ != nullptr);
  return value;
}
inline bool TRenderPass::has_clearmode() const {
  return _internal_has_clearmode();
}
inline void TRenderPass::clear_clearmode() {
  if (_impl_.clearmode_ != nullptr) _impl_.clearmode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::HmiScenegraph::TClearMode& TRenderPass::_internal_clearmode() const {
  const ::HmiScenegraph::TClearMode* p = _impl_.clearmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TClearMode&>(
      ::HmiScenegraph::_TClearMode_default_instance_);
}
inline const ::HmiScenegraph::TClearMode& TRenderPass::clearmode() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.clearMode)
  return _internal_clearmode();
}
inline void TRenderPass::unsafe_arena_set_allocated_clearmode(
    ::HmiScenegraph::TClearMode* clearmode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clearmode_);
  }
  _impl_.clearmode_ = clearmode;
  if (clearmode) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderPass.clearMode)
}
inline ::HmiScenegraph::TClearMode* TRenderPass::release_clearmode() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HmiScenegraph::TClearMode* temp = _impl_.clearmode_;
  _impl_.clearmode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TClearMode* TRenderPass::unsafe_arena_release_clearmode() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.clearMode)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::HmiScenegraph::TClearMode* temp = _impl_.clearmode_;
  _impl_.clearmode_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TClearMode* TRenderPass::_internal_mutable_clearmode() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.clearmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TClearMode>(GetArenaForAllocation());
    _impl_.clearmode_ = p;
  }
  return _impl_.clearmode_;
}
inline ::HmiScenegraph::TClearMode* TRenderPass::mutable_clearmode() {
  ::HmiScenegraph::TClearMode* _msg = _internal_mutable_clearmode();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.clearMode)
  return _msg;
}
inline void TRenderPass::set_allocated_clearmode(::HmiScenegraph::TClearMode* clearmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clearmode_;
  }
  if (clearmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clearmode);
    if (message_arena != submessage_arena) {
      clearmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clearmode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.clearmode_ = clearmode;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.clearMode)
}

// optional string cameraName = 6;
inline bool TRenderPass::_internal_has_cameraname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TRenderPass::has_cameraname() const {
  return _internal_has_cameraname();
}
inline void TRenderPass::clear_cameraname() {
  _impl_.cameraname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TRenderPass::cameraname() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.cameraName)
  return _internal_cameraname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TRenderPass::set_cameraname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cameraname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.cameraName)
}
inline std::string* TRenderPass::mutable_cameraname() {
  std::string* _s = _internal_mutable_cameraname();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.cameraName)
  return _s;
}
inline const std::string& TRenderPass::_internal_cameraname() const {
  return _impl_.cameraname_.Get();
}
inline void TRenderPass::_internal_set_cameraname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cameraname_.Set(value, GetArenaForAllocation());
}
inline std::string* TRenderPass::_internal_mutable_cameraname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cameraname_.Mutable(GetArenaForAllocation());
}
inline std::string* TRenderPass::release_cameraname() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.cameraName)
  if (!_internal_has_cameraname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cameraname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cameraname_.IsDefault()) {
    _impl_.cameraname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TRenderPass::set_allocated_cameraname(std::string* cameraname) {
  if (cameraname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cameraname_.SetAllocated(cameraname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cameraname_.IsDefault()) {
    _impl_.cameraname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.cameraName)
}

// optional .TVector4f viewport = 7;
inline bool TRenderPass::_internal_has_viewport() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.viewport_ != nullptr);
  return value;
}
inline bool TRenderPass::has_viewport() const {
  return _internal_has_viewport();
}
inline const ::TVector4f& TRenderPass::_internal_viewport() const {
  const ::TVector4f* p = _impl_.viewport_;
  return p != nullptr ? *p : reinterpret_cast<const ::TVector4f&>(
      ::_TVector4f_default_instance_);
}
inline const ::TVector4f& TRenderPass::viewport() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.viewport)
  return _internal_viewport();
}
inline void TRenderPass::unsafe_arena_set_allocated_viewport(
    ::TVector4f* viewport) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewport_);
  }
  _impl_.viewport_ = viewport;
  if (viewport) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TRenderPass.viewport)
}
inline ::TVector4f* TRenderPass::release_viewport() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TVector4f* temp = _impl_.viewport_;
  _impl_.viewport_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TVector4f* TRenderPass::unsafe_arena_release_viewport() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TRenderPass.viewport)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TVector4f* temp = _impl_.viewport_;
  _impl_.viewport_ = nullptr;
  return temp;
}
inline ::TVector4f* TRenderPass::_internal_mutable_viewport() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.viewport_ == nullptr) {
    auto* p = CreateMaybeMessage<::TVector4f>(GetArenaForAllocation());
    _impl_.viewport_ = p;
  }
  return _impl_.viewport_;
}
inline ::TVector4f* TRenderPass::mutable_viewport() {
  ::TVector4f* _msg = _internal_mutable_viewport();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TRenderPass.viewport)
  return _msg;
}
inline void TRenderPass::set_allocated_viewport(::TVector4f* viewport) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.viewport_);
  }
  if (viewport) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(viewport));
    if (message_arena != submessage_arena) {
      viewport = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, viewport, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.viewport_ = viewport;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TRenderPass.viewport)
}

// optional bool viewFrustumCullingEnabled = 8 [default = false];
inline bool TRenderPass::_internal_has_viewfrustumcullingenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TRenderPass::has_viewfrustumcullingenabled() const {
  return _internal_has_viewfrustumcullingenabled();
}
inline void TRenderPass::clear_viewfrustumcullingenabled() {
  _impl_.viewfrustumcullingenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool TRenderPass::_internal_viewfrustumcullingenabled() const {
  return _impl_.viewfrustumcullingenabled_;
}
inline bool TRenderPass::viewfrustumcullingenabled() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.viewFrustumCullingEnabled)
  return _internal_viewfrustumcullingenabled();
}
inline void TRenderPass::_internal_set_viewfrustumcullingenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.viewfrustumcullingenabled_ = value;
}
inline void TRenderPass::set_viewfrustumcullingenabled(bool value) {
  _internal_set_viewfrustumcullingenabled(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.viewFrustumCullingEnabled)
}

// optional fixed32 scopeMask = 9 [deprecated = true];
inline bool TRenderPass::_internal_has_scopemask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TRenderPass::has_scopemask() const {
  return _internal_has_scopemask();
}
inline void TRenderPass::clear_scopemask() {
  _impl_.scopemask_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TRenderPass::_internal_scopemask() const {
  return _impl_.scopemask_;
}
inline uint32_t TRenderPass::scopemask() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.scopeMask)
  return _internal_scopemask();
}
inline void TRenderPass::_internal_set_scopemask(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.scopemask_ = value;
}
inline void TRenderPass::set_scopemask(uint32_t value) {
  _internal_set_scopemask(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.scopeMask)
}

// optional .TEScope scope = 10;
inline bool TRenderPass::_internal_has_scope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TRenderPass::has_scope() const {
  return _internal_has_scope();
}
inline void TRenderPass::clear_scope() {
  _impl_.scope_ = 1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::TEScope TRenderPass::_internal_scope() const {
  return static_cast< ::TEScope >(_impl_.scope_);
}
inline ::TEScope TRenderPass::scope() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TRenderPass.scope)
  return _internal_scope();
}
inline void TRenderPass::_internal_set_scope(::TEScope value) {
  assert(::TEScope_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.scope_ = value;
}
inline void TRenderPass::set_scope(::TEScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TRenderPass.scope)
}

// -------------------------------------------------------------------

// TBlitPass

// required string name = 1;
inline bool TBlitPass::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TBlitPass::has_name() const {
  return _internal_has_name();
}
inline void TBlitPass::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TBlitPass::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBlitPass::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.name)
}
inline std::string* TBlitPass::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBlitPass.name)
  return _s;
}
inline const std::string& TBlitPass::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TBlitPass::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TBlitPass::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TBlitPass::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBlitPass.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBlitPass::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBlitPass.name)
}

// optional uint32 rank = 2;
inline bool TBlitPass::_internal_has_rank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TBlitPass::has_rank() const {
  return _internal_has_rank();
}
inline void TBlitPass::clear_rank() {
  _impl_.rank_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TBlitPass::_internal_rank() const {
  return _impl_.rank_;
}
inline uint32_t TBlitPass::rank() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.rank)
  return _internal_rank();
}
inline void TBlitPass::_internal_set_rank(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rank_ = value;
}
inline void TBlitPass::set_rank(uint32_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.rank)
}

// optional string sourceRenderBuffer = 3;
inline bool TBlitPass::_internal_has_sourcerenderbuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TBlitPass::has_sourcerenderbuffer() const {
  return _internal_has_sourcerenderbuffer();
}
inline void TBlitPass::clear_sourcerenderbuffer() {
  _impl_.sourcerenderbuffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TBlitPass::sourcerenderbuffer() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.sourceRenderBuffer)
  return _internal_sourcerenderbuffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBlitPass::set_sourcerenderbuffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourcerenderbuffer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.sourceRenderBuffer)
}
inline std::string* TBlitPass::mutable_sourcerenderbuffer() {
  std::string* _s = _internal_mutable_sourcerenderbuffer();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBlitPass.sourceRenderBuffer)
  return _s;
}
inline const std::string& TBlitPass::_internal_sourcerenderbuffer() const {
  return _impl_.sourcerenderbuffer_.Get();
}
inline void TBlitPass::_internal_set_sourcerenderbuffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourcerenderbuffer_.Set(value, GetArenaForAllocation());
}
inline std::string* TBlitPass::_internal_mutable_sourcerenderbuffer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourcerenderbuffer_.Mutable(GetArenaForAllocation());
}
inline std::string* TBlitPass::release_sourcerenderbuffer() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBlitPass.sourceRenderBuffer)
  if (!_internal_has_sourcerenderbuffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourcerenderbuffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcerenderbuffer_.IsDefault()) {
    _impl_.sourcerenderbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBlitPass::set_allocated_sourcerenderbuffer(std::string* sourcerenderbuffer) {
  if (sourcerenderbuffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourcerenderbuffer_.SetAllocated(sourcerenderbuffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcerenderbuffer_.IsDefault()) {
    _impl_.sourcerenderbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBlitPass.sourceRenderBuffer)
}

// optional string destinationRenderBuffer = 4;
inline bool TBlitPass::_internal_has_destinationrenderbuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TBlitPass::has_destinationrenderbuffer() const {
  return _internal_has_destinationrenderbuffer();
}
inline void TBlitPass::clear_destinationrenderbuffer() {
  _impl_.destinationrenderbuffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TBlitPass::destinationrenderbuffer() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.destinationRenderBuffer)
  return _internal_destinationrenderbuffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TBlitPass::set_destinationrenderbuffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.destinationrenderbuffer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.destinationRenderBuffer)
}
inline std::string* TBlitPass::mutable_destinationrenderbuffer() {
  std::string* _s = _internal_mutable_destinationrenderbuffer();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TBlitPass.destinationRenderBuffer)
  return _s;
}
inline const std::string& TBlitPass::_internal_destinationrenderbuffer() const {
  return _impl_.destinationrenderbuffer_.Get();
}
inline void TBlitPass::_internal_set_destinationrenderbuffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.destinationrenderbuffer_.Set(value, GetArenaForAllocation());
}
inline std::string* TBlitPass::_internal_mutable_destinationrenderbuffer() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.destinationrenderbuffer_.Mutable(GetArenaForAllocation());
}
inline std::string* TBlitPass::release_destinationrenderbuffer() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TBlitPass.destinationRenderBuffer)
  if (!_internal_has_destinationrenderbuffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.destinationrenderbuffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destinationrenderbuffer_.IsDefault()) {
    _impl_.destinationrenderbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TBlitPass::set_allocated_destinationrenderbuffer(std::string* destinationrenderbuffer) {
  if (destinationrenderbuffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.destinationrenderbuffer_.SetAllocated(destinationrenderbuffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destinationrenderbuffer_.IsDefault()) {
    _impl_.destinationrenderbuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TBlitPass.destinationRenderBuffer)
}

// optional uint32 regionWidth = 5;
inline bool TBlitPass::_internal_has_regionwidth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TBlitPass::has_regionwidth() const {
  return _internal_has_regionwidth();
}
inline void TBlitPass::clear_regionwidth() {
  _impl_.regionwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TBlitPass::_internal_regionwidth() const {
  return _impl_.regionwidth_;
}
inline uint32_t TBlitPass::regionwidth() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionWidth)
  return _internal_regionwidth();
}
inline void TBlitPass::_internal_set_regionwidth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.regionwidth_ = value;
}
inline void TBlitPass::set_regionwidth(uint32_t value) {
  _internal_set_regionwidth(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionWidth)
}

// optional uint32 regionHeight = 6;
inline bool TBlitPass::_internal_has_regionheight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TBlitPass::has_regionheight() const {
  return _internal_has_regionheight();
}
inline void TBlitPass::clear_regionheight() {
  _impl_.regionheight_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t TBlitPass::_internal_regionheight() const {
  return _impl_.regionheight_;
}
inline uint32_t TBlitPass::regionheight() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionHeight)
  return _internal_regionheight();
}
inline void TBlitPass::_internal_set_regionheight(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.regionheight_ = value;
}
inline void TBlitPass::set_regionheight(uint32_t value) {
  _internal_set_regionheight(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionHeight)
}

// optional uint32 regionSourceX = 7 [default = 0];
inline bool TBlitPass::_internal_has_regionsourcex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TBlitPass::has_regionsourcex() const {
  return _internal_has_regionsourcex();
}
inline void TBlitPass::clear_regionsourcex() {
  _impl_.regionsourcex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t TBlitPass::_internal_regionsourcex() const {
  return _impl_.regionsourcex_;
}
inline uint32_t TBlitPass::regionsourcex() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionSourceX)
  return _internal_regionsourcex();
}
inline void TBlitPass::_internal_set_regionsourcex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.regionsourcex_ = value;
}
inline void TBlitPass::set_regionsourcex(uint32_t value) {
  _internal_set_regionsourcex(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionSourceX)
}

// optional uint32 regionSourceY = 8 [default = 0];
inline bool TBlitPass::_internal_has_regionsourcey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TBlitPass::has_regionsourcey() const {
  return _internal_has_regionsourcey();
}
inline void TBlitPass::clear_regionsourcey() {
  _impl_.regionsourcey_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t TBlitPass::_internal_regionsourcey() const {
  return _impl_.regionsourcey_;
}
inline uint32_t TBlitPass::regionsourcey() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionSourceY)
  return _internal_regionsourcey();
}
inline void TBlitPass::_internal_set_regionsourcey(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.regionsourcey_ = value;
}
inline void TBlitPass::set_regionsourcey(uint32_t value) {
  _internal_set_regionsourcey(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionSourceY)
}

// optional uint32 regionDestinationX = 9 [default = 0];
inline bool TBlitPass::_internal_has_regiondestinationx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TBlitPass::has_regiondestinationx() const {
  return _internal_has_regiondestinationx();
}
inline void TBlitPass::clear_regiondestinationx() {
  _impl_.regiondestinationx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TBlitPass::_internal_regiondestinationx() const {
  return _impl_.regiondestinationx_;
}
inline uint32_t TBlitPass::regiondestinationx() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionDestinationX)
  return _internal_regiondestinationx();
}
inline void TBlitPass::_internal_set_regiondestinationx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.regiondestinationx_ = value;
}
inline void TBlitPass::set_regiondestinationx(uint32_t value) {
  _internal_set_regiondestinationx(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionDestinationX)
}

// optional uint32 regionDestinationY = 10 [default = 0];
inline bool TBlitPass::_internal_has_regiondestinationy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TBlitPass::has_regiondestinationy() const {
  return _internal_has_regiondestinationy();
}
inline void TBlitPass::clear_regiondestinationy() {
  _impl_.regiondestinationy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TBlitPass::_internal_regiondestinationy() const {
  return _impl_.regiondestinationy_;
}
inline uint32_t TBlitPass::regiondestinationy() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TBlitPass.regionDestinationY)
  return _internal_regiondestinationy();
}
inline void TBlitPass::_internal_set_regiondestinationy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.regiondestinationy_ = value;
}
inline void TBlitPass::set_regiondestinationy(uint32_t value) {
  _internal_set_regiondestinationy(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TBlitPass.regionDestinationY)
}

// -------------------------------------------------------------------

// TGeometry_TAttributeParamteter

// required string name = 1;
inline bool TGeometry_TAttributeParamteter::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_name() const {
  return _internal_has_name();
}
inline void TGeometry_TAttributeParamteter::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TGeometry_TAttributeParamteter::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TGeometry_TAttributeParamteter::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.TAttributeParamteter.name)
}
inline std::string* TGeometry_TAttributeParamteter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.TAttributeParamteter.name)
  return _s;
}
inline const std::string& TGeometry_TAttributeParamteter::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TGeometry_TAttributeParamteter::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TGeometry_TAttributeParamteter::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TGeometry_TAttributeParamteter::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TGeometry.TAttributeParamteter.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TGeometry_TAttributeParamteter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TGeometry.TAttributeParamteter.name)
}

// optional .HmiScenegraph.TEAttributePrecision precision = 2;
inline bool TGeometry_TAttributeParamteter::_internal_has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_precision() const {
  return _internal_has_precision();
}
inline void TGeometry_TAttributeParamteter::clear_precision() {
  _impl_.precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::HmiScenegraph::TEAttributePrecision TGeometry_TAttributeParamteter::_internal_precision() const {
  return static_cast< ::HmiScenegraph::TEAttributePrecision >(_impl_.precision_);
}
inline ::HmiScenegraph::TEAttributePrecision TGeometry_TAttributeParamteter::precision() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.precision)
  return _internal_precision();
}
inline void TGeometry_TAttributeParamteter::_internal_set_precision(::HmiScenegraph::TEAttributePrecision value) {
  assert(::HmiScenegraph::TEAttributePrecision_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.precision_ = value;
}
inline void TGeometry_TAttributeParamteter::set_precision(::HmiScenegraph::TEAttributePrecision value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.TAttributeParamteter.precision)
}

// optional .HmiScenegraph.TEAttributeSize size = 3;
inline bool TGeometry_TAttributeParamteter::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_size() const {
  return _internal_has_size();
}
inline void TGeometry_TAttributeParamteter::clear_size() {
  _impl_.size_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::HmiScenegraph::TEAttributeSize TGeometry_TAttributeParamteter::_internal_size() const {
  return static_cast< ::HmiScenegraph::TEAttributeSize >(_impl_.size_);
}
inline ::HmiScenegraph::TEAttributeSize TGeometry_TAttributeParamteter::size() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.size)
  return _internal_size();
}
inline void TGeometry_TAttributeParamteter::_internal_set_size(::HmiScenegraph::TEAttributeSize value) {
  assert(::HmiScenegraph::TEAttributeSize_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.size_ = value;
}
inline void TGeometry_TAttributeParamteter::set_size(::HmiScenegraph::TEAttributeSize value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.TAttributeParamteter.size)
}

// optional .HmiScenegraph.TEAttributeSemantic semantic = 4;
inline bool TGeometry_TAttributeParamteter::_internal_has_semantic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_semantic() const {
  return _internal_has_semantic();
}
inline void TGeometry_TAttributeParamteter::clear_semantic() {
  _impl_.semantic_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::HmiScenegraph::TEAttributeSemantic TGeometry_TAttributeParamteter::_internal_semantic() const {
  return static_cast< ::HmiScenegraph::TEAttributeSemantic >(_impl_.semantic_);
}
inline ::HmiScenegraph::TEAttributeSemantic TGeometry_TAttributeParamteter::semantic() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.semantic)
  return _internal_semantic();
}
inline void TGeometry_TAttributeParamteter::_internal_set_semantic(::HmiScenegraph::TEAttributeSemantic value) {
  assert(::HmiScenegraph::TEAttributeSemantic_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.semantic_ = value;
}
inline void TGeometry_TAttributeParamteter::set_semantic(::HmiScenegraph::TEAttributeSemantic value) {
  _internal_set_semantic(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.TAttributeParamteter.semantic)
}

// optional uint32 usageIndex = 5;
inline bool TGeometry_TAttributeParamteter::_internal_has_usageindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_usageindex() const {
  return _internal_has_usageindex();
}
inline void TGeometry_TAttributeParamteter::clear_usageindex() {
  _impl_.usageindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TGeometry_TAttributeParamteter::_internal_usageindex() const {
  return _impl_.usageindex_;
}
inline uint32_t TGeometry_TAttributeParamteter::usageindex() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.usageIndex)
  return _internal_usageindex();
}
inline void TGeometry_TAttributeParamteter::_internal_set_usageindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.usageindex_ = value;
}
inline void TGeometry_TAttributeParamteter::set_usageindex(uint32_t value) {
  _internal_set_usageindex(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.TAttributeParamteter.usageIndex)
}

// optional .HmiScenegraph.TResourceCacheId cacheId = 6;
inline bool TGeometry_TAttributeParamteter::_internal_has_cacheid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cacheid_ != nullptr);
  return value;
}
inline bool TGeometry_TAttributeParamteter::has_cacheid() const {
  return _internal_has_cacheid();
}
inline void TGeometry_TAttributeParamteter::clear_cacheid() {
  if (_impl_.cacheid_ != nullptr) _impl_.cacheid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HmiScenegraph::TResourceCacheId& TGeometry_TAttributeParamteter::_internal_cacheid() const {
  const ::HmiScenegraph::TResourceCacheId* p = _impl_.cacheid_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TResourceCacheId&>(
      ::HmiScenegraph::_TResourceCacheId_default_instance_);
}
inline const ::HmiScenegraph::TResourceCacheId& TGeometry_TAttributeParamteter::cacheid() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.TAttributeParamteter.cacheId)
  return _internal_cacheid();
}
inline void TGeometry_TAttributeParamteter::unsafe_arena_set_allocated_cacheid(
    ::HmiScenegraph::TResourceCacheId* cacheid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cacheid_);
  }
  _impl_.cacheid_ = cacheid;
  if (cacheid) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TGeometry.TAttributeParamteter.cacheId)
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry_TAttributeParamteter::release_cacheid() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry_TAttributeParamteter::unsafe_arena_release_cacheid() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TGeometry.TAttributeParamteter.cacheId)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.cacheid_;
  _impl_.cacheid_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry_TAttributeParamteter::_internal_mutable_cacheid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cacheid_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TResourceCacheId>(GetArenaForAllocation());
    _impl_.cacheid_ = p;
  }
  return _impl_.cacheid_;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry_TAttributeParamteter::mutable_cacheid() {
  ::HmiScenegraph::TResourceCacheId* _msg = _internal_mutable_cacheid();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.TAttributeParamteter.cacheId)
  return _msg;
}
inline void TGeometry_TAttributeParamteter::set_allocated_cacheid(::HmiScenegraph::TResourceCacheId* cacheid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cacheid_;
  }
  if (cacheid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cacheid);
    if (message_arena != submessage_arena) {
      cacheid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cacheid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cacheid_ = cacheid;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TGeometry.TAttributeParamteter.cacheId)
}

// -------------------------------------------------------------------

// TGeometry

// required string name = 1;
inline bool TGeometry::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TGeometry::has_name() const {
  return _internal_has_name();
}
inline void TGeometry::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TGeometry::name() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TGeometry::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.name)
}
inline std::string* TGeometry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.name)
  return _s;
}
inline const std::string& TGeometry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TGeometry::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TGeometry::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TGeometry::release_name() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TGeometry.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TGeometry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TGeometry.name)
}

// optional string resource = 2;
inline bool TGeometry::_internal_has_resource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TGeometry::has_resource() const {
  return _internal_has_resource();
}
inline void TGeometry::clear_resource() {
  _impl_.resource_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TGeometry::resource() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.resource)
  return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TGeometry::set_resource(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.resource)
}
inline std::string* TGeometry::mutable_resource() {
  std::string* _s = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.resource)
  return _s;
}
inline const std::string& TGeometry::_internal_resource() const {
  return _impl_.resource_.Get();
}
inline void TGeometry::_internal_set_resource(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.resource_.Set(value, GetArenaForAllocation());
}
inline std::string* TGeometry::_internal_mutable_resource() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.resource_.Mutable(GetArenaForAllocation());
}
inline std::string* TGeometry::release_resource() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TGeometry.resource)
  if (!_internal_has_resource()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TGeometry::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resource_.IsDefault()) {
    _impl_.resource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TGeometry.resource)
}

// optional uint32 vertexCount = 4;
inline bool TGeometry::_internal_has_vertexcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TGeometry::has_vertexcount() const {
  return _internal_has_vertexcount();
}
inline void TGeometry::clear_vertexcount() {
  _impl_.vertexcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TGeometry::_internal_vertexcount() const {
  return _impl_.vertexcount_;
}
inline uint32_t TGeometry::vertexcount() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.vertexCount)
  return _internal_vertexcount();
}
inline void TGeometry::_internal_set_vertexcount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.vertexcount_ = value;
}
inline void TGeometry::set_vertexcount(uint32_t value) {
  _internal_set_vertexcount(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.vertexCount)
}

// optional uint32 primitiveCount = 5;
inline bool TGeometry::_internal_has_primitivecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TGeometry::has_primitivecount() const {
  return _internal_has_primitivecount();
}
inline void TGeometry::clear_primitivecount() {
  _impl_.primitivecount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TGeometry::_internal_primitivecount() const {
  return _impl_.primitivecount_;
}
inline uint32_t TGeometry::primitivecount() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.primitiveCount)
  return _internal_primitivecount();
}
inline void TGeometry::_internal_set_primitivecount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.primitivecount_ = value;
}
inline void TGeometry::set_primitivecount(uint32_t value) {
  _internal_set_primitivecount(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.primitiveCount)
}

// optional .HmiScenegraph.TEPrimitiveType primitiveType = 6 [default = TEPrimitiveType_Triangles];
inline bool TGeometry::_internal_has_primitivetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TGeometry::has_primitivetype() const {
  return _internal_has_primitivetype();
}
inline void TGeometry::clear_primitivetype() {
  _impl_.primitivetype_ = 4;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::HmiScenegraph::TEPrimitiveType TGeometry::_internal_primitivetype() const {
  return static_cast< ::HmiScenegraph::TEPrimitiveType >(_impl_.primitivetype_);
}
inline ::HmiScenegraph::TEPrimitiveType TGeometry::primitivetype() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.primitiveType)
  return _internal_primitivetype();
}
inline void TGeometry::_internal_set_primitivetype(::HmiScenegraph::TEPrimitiveType value) {
  assert(::HmiScenegraph::TEPrimitiveType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.primitivetype_ = value;
}
inline void TGeometry::set_primitivetype(::HmiScenegraph::TEPrimitiveType value) {
  _internal_set_primitivetype(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TGeometry.primitiveType)
}

// optional .HmiScenegraph.TResourceCacheId indexDataCacheId = 8;
inline bool TGeometry::_internal_has_indexdatacacheid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indexdatacacheid_ != nullptr);
  return value;
}
inline bool TGeometry::has_indexdatacacheid() const {
  return _internal_has_indexdatacacheid();
}
inline void TGeometry::clear_indexdatacacheid() {
  if (_impl_.indexdatacacheid_ != nullptr) _impl_.indexdatacacheid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::HmiScenegraph::TResourceCacheId& TGeometry::_internal_indexdatacacheid() const {
  const ::HmiScenegraph::TResourceCacheId* p = _impl_.indexdatacacheid_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TResourceCacheId&>(
      ::HmiScenegraph::_TResourceCacheId_default_instance_);
}
inline const ::HmiScenegraph::TResourceCacheId& TGeometry::indexdatacacheid() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.indexDataCacheId)
  return _internal_indexdatacacheid();
}
inline void TGeometry::unsafe_arena_set_allocated_indexdatacacheid(
    ::HmiScenegraph::TResourceCacheId* indexdatacacheid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.indexdatacacheid_);
  }
  _impl_.indexdatacacheid_ = indexdatacacheid;
  if (indexdatacacheid) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TGeometry.indexDataCacheId)
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry::release_indexdatacacheid() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.indexdatacacheid_;
  _impl_.indexdatacacheid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry::unsafe_arena_release_indexdatacacheid() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TGeometry.indexDataCacheId)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::HmiScenegraph::TResourceCacheId* temp = _impl_.indexdatacacheid_;
  _impl_.indexdatacacheid_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry::_internal_mutable_indexdatacacheid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.indexdatacacheid_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TResourceCacheId>(GetArenaForAllocation());
    _impl_.indexdatacacheid_ = p;
  }
  return _impl_.indexdatacacheid_;
}
inline ::HmiScenegraph::TResourceCacheId* TGeometry::mutable_indexdatacacheid() {
  ::HmiScenegraph::TResourceCacheId* _msg = _internal_mutable_indexdatacacheid();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.indexDataCacheId)
  return _msg;
}
inline void TGeometry::set_allocated_indexdatacacheid(::HmiScenegraph::TResourceCacheId* indexdatacacheid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.indexdatacacheid_;
  }
  if (indexdatacacheid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(indexdatacacheid);
    if (message_arena != submessage_arena) {
      indexdatacacheid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, indexdatacacheid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.indexdatacacheid_ = indexdatacacheid;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TGeometry.indexDataCacheId)
}

// repeated .HmiScenegraph.TGeometry.TAttributeParamteter attributeParameter = 3;
inline int TGeometry::_internal_attributeparameter_size() const {
  return _impl_.attributeparameter_.size();
}
inline int TGeometry::attributeparameter_size() const {
  return _internal_attributeparameter_size();
}
inline void TGeometry::clear_attributeparameter() {
  _impl_.attributeparameter_.Clear();
}
inline ::HmiScenegraph::TGeometry_TAttributeParamteter* TGeometry::mutable_attributeparameter(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TGeometry.attributeParameter)
  return _impl_.attributeparameter_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry_TAttributeParamteter >*
TGeometry::mutable_attributeparameter() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TGeometry.attributeParameter)
  return &_impl_.attributeparameter_;
}
inline const ::HmiScenegraph::TGeometry_TAttributeParamteter& TGeometry::_internal_attributeparameter(int index) const {
  return _impl_.attributeparameter_.Get(index);
}
inline const ::HmiScenegraph::TGeometry_TAttributeParamteter& TGeometry::attributeparameter(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TGeometry.attributeParameter)
  return _internal_attributeparameter(index);
}
inline ::HmiScenegraph::TGeometry_TAttributeParamteter* TGeometry::_internal_add_attributeparameter() {
  return _impl_.attributeparameter_.Add();
}
inline ::HmiScenegraph::TGeometry_TAttributeParamteter* TGeometry::add_attributeparameter() {
  ::HmiScenegraph::TGeometry_TAttributeParamteter* _add = _internal_add_attributeparameter();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TGeometry.attributeParameter)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry_TAttributeParamteter >&
TGeometry::attributeparameter() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TGeometry.attributeParameter)
  return _impl_.attributeparameter_;
}

// -------------------------------------------------------------------

// TMaterialLib

// repeated .HmiScenegraph.TMaterial material = 1;
inline int TMaterialLib::_internal_material_size() const {
  return _impl_.material_.size();
}
inline int TMaterialLib::material_size() const {
  return _internal_material_size();
}
inline void TMaterialLib::clear_material() {
  _impl_.material_.Clear();
}
inline ::HmiScenegraph::TMaterial* TMaterialLib::mutable_material(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.material)
  return _impl_.material_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMaterial >*
TMaterialLib::mutable_material() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.material)
  return &_impl_.material_;
}
inline const ::HmiScenegraph::TMaterial& TMaterialLib::_internal_material(int index) const {
  return _impl_.material_.Get(index);
}
inline const ::HmiScenegraph::TMaterial& TMaterialLib::material(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.material)
  return _internal_material(index);
}
inline ::HmiScenegraph::TMaterial* TMaterialLib::_internal_add_material() {
  return _impl_.material_.Add();
}
inline ::HmiScenegraph::TMaterial* TMaterialLib::add_material() {
  ::HmiScenegraph::TMaterial* _add = _internal_add_material();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.material)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TMaterial >&
TMaterialLib::material() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.material)
  return _impl_.material_;
}

// repeated .HmiScenegraph.TShader shader = 2;
inline int TMaterialLib::_internal_shader_size() const {
  return _impl_.shader_.size();
}
inline int TMaterialLib::shader_size() const {
  return _internal_shader_size();
}
inline void TMaterialLib::clear_shader() {
  _impl_.shader_.Clear();
}
inline ::HmiScenegraph::TShader* TMaterialLib::mutable_shader(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.shader)
  return _impl_.shader_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TShader >*
TMaterialLib::mutable_shader() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.shader)
  return &_impl_.shader_;
}
inline const ::HmiScenegraph::TShader& TMaterialLib::_internal_shader(int index) const {
  return _impl_.shader_.Get(index);
}
inline const ::HmiScenegraph::TShader& TMaterialLib::shader(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.shader)
  return _internal_shader(index);
}
inline ::HmiScenegraph::TShader* TMaterialLib::_internal_add_shader() {
  return _impl_.shader_.Add();
}
inline ::HmiScenegraph::TShader* TMaterialLib::add_shader() {
  ::HmiScenegraph::TShader* _add = _internal_add_shader();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.shader)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TShader >&
TMaterialLib::shader() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.shader)
  return _impl_.shader_;
}

// repeated .HmiScenegraph.TBitmap bitmap = 3;
inline int TMaterialLib::_internal_bitmap_size() const {
  return _impl_.bitmap_.size();
}
inline int TMaterialLib::bitmap_size() const {
  return _internal_bitmap_size();
}
inline void TMaterialLib::clear_bitmap() {
  _impl_.bitmap_.Clear();
}
inline ::HmiScenegraph::TBitmap* TMaterialLib::mutable_bitmap(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.bitmap)
  return _impl_.bitmap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBitmap >*
TMaterialLib::mutable_bitmap() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.bitmap)
  return &_impl_.bitmap_;
}
inline const ::HmiScenegraph::TBitmap& TMaterialLib::_internal_bitmap(int index) const {
  return _impl_.bitmap_.Get(index);
}
inline const ::HmiScenegraph::TBitmap& TMaterialLib::bitmap(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.bitmap)
  return _internal_bitmap(index);
}
inline ::HmiScenegraph::TBitmap* TMaterialLib::_internal_add_bitmap() {
  return _impl_.bitmap_.Add();
}
inline ::HmiScenegraph::TBitmap* TMaterialLib::add_bitmap() {
  ::HmiScenegraph::TBitmap* _add = _internal_add_bitmap();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.bitmap)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBitmap >&
TMaterialLib::bitmap() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.bitmap)
  return _impl_.bitmap_;
}

// repeated .HmiScenegraph.TGeometry geometry = 4;
inline int TMaterialLib::_internal_geometry_size() const {
  return _impl_.geometry_.size();
}
inline int TMaterialLib::geometry_size() const {
  return _internal_geometry_size();
}
inline void TMaterialLib::clear_geometry() {
  _impl_.geometry_.Clear();
}
inline ::HmiScenegraph::TGeometry* TMaterialLib::mutable_geometry(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.geometry)
  return _impl_.geometry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry >*
TMaterialLib::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.geometry)
  return &_impl_.geometry_;
}
inline const ::HmiScenegraph::TGeometry& TMaterialLib::_internal_geometry(int index) const {
  return _impl_.geometry_.Get(index);
}
inline const ::HmiScenegraph::TGeometry& TMaterialLib::geometry(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.geometry)
  return _internal_geometry(index);
}
inline ::HmiScenegraph::TGeometry* TMaterialLib::_internal_add_geometry() {
  return _impl_.geometry_.Add();
}
inline ::HmiScenegraph::TGeometry* TMaterialLib::add_geometry() {
  ::HmiScenegraph::TGeometry* _add = _internal_add_geometry();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.geometry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TGeometry >&
TMaterialLib::geometry() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.geometry)
  return _impl_.geometry_;
}

// repeated .HmiScenegraph.TRenderTarget renderTarget = 5;
inline int TMaterialLib::_internal_rendertarget_size() const {
  return _impl_.rendertarget_.size();
}
inline int TMaterialLib::rendertarget_size() const {
  return _internal_rendertarget_size();
}
inline void TMaterialLib::clear_rendertarget() {
  _impl_.rendertarget_.Clear();
}
inline ::HmiScenegraph::TRenderTarget* TMaterialLib::mutable_rendertarget(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.renderTarget)
  return _impl_.rendertarget_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderTarget >*
TMaterialLib::mutable_rendertarget() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.renderTarget)
  return &_impl_.rendertarget_;
}
inline const ::HmiScenegraph::TRenderTarget& TMaterialLib::_internal_rendertarget(int index) const {
  return _impl_.rendertarget_.Get(index);
}
inline const ::HmiScenegraph::TRenderTarget& TMaterialLib::rendertarget(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.renderTarget)
  return _internal_rendertarget(index);
}
inline ::HmiScenegraph::TRenderTarget* TMaterialLib::_internal_add_rendertarget() {
  return _impl_.rendertarget_.Add();
}
inline ::HmiScenegraph::TRenderTarget* TMaterialLib::add_rendertarget() {
  ::HmiScenegraph::TRenderTarget* _add = _internal_add_rendertarget();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.renderTarget)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderTarget >&
TMaterialLib::rendertarget() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.renderTarget)
  return _impl_.rendertarget_;
}

// repeated .HmiScenegraph.TRenderPass renderPass = 6;
inline int TMaterialLib::_internal_renderpass_size() const {
  return _impl_.renderpass_.size();
}
inline int TMaterialLib::renderpass_size() const {
  return _internal_renderpass_size();
}
inline void TMaterialLib::clear_renderpass() {
  _impl_.renderpass_.Clear();
}
inline ::HmiScenegraph::TRenderPass* TMaterialLib::mutable_renderpass(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.renderPass)
  return _impl_.renderpass_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
TMaterialLib::mutable_renderpass() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.renderPass)
  return &_impl_.renderpass_;
}
inline const ::HmiScenegraph::TRenderPass& TMaterialLib::_internal_renderpass(int index) const {
  return _impl_.renderpass_.Get(index);
}
inline const ::HmiScenegraph::TRenderPass& TMaterialLib::renderpass(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.renderPass)
  return _internal_renderpass(index);
}
inline ::HmiScenegraph::TRenderPass* TMaterialLib::_internal_add_renderpass() {
  return _impl_.renderpass_.Add();
}
inline ::HmiScenegraph::TRenderPass* TMaterialLib::add_renderpass() {
  ::HmiScenegraph::TRenderPass* _add = _internal_add_renderpass();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.renderPass)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
TMaterialLib::renderpass() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.renderPass)
  return _impl_.renderpass_;
}

// repeated .HmiScenegraph.TBlitPass blitPass = 8;
inline int TMaterialLib::_internal_blitpass_size() const {
  return _impl_.blitpass_.size();
}
inline int TMaterialLib::blitpass_size() const {
  return _internal_blitpass_size();
}
inline void TMaterialLib::clear_blitpass() {
  _impl_.blitpass_.Clear();
}
inline ::HmiScenegraph::TBlitPass* TMaterialLib::mutable_blitpass(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.blitPass)
  return _impl_.blitpass_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBlitPass >*
TMaterialLib::mutable_blitpass() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.blitPass)
  return &_impl_.blitpass_;
}
inline const ::HmiScenegraph::TBlitPass& TMaterialLib::_internal_blitpass(int index) const {
  return _impl_.blitpass_.Get(index);
}
inline const ::HmiScenegraph::TBlitPass& TMaterialLib::blitpass(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.blitPass)
  return _internal_blitpass(index);
}
inline ::HmiScenegraph::TBlitPass* TMaterialLib::_internal_add_blitpass() {
  return _impl_.blitpass_.Add();
}
inline ::HmiScenegraph::TBlitPass* TMaterialLib::add_blitpass() {
  ::HmiScenegraph::TBlitPass* _add = _internal_add_blitpass();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.blitPass)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TBlitPass >&
TMaterialLib::blitpass() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.blitPass)
  return _impl_.blitpass_;
}

// repeated string resourceCache = 7;
inline int TMaterialLib::_internal_resourcecache_size() const {
  return _impl_.resourcecache_.size();
}
inline int TMaterialLib::resourcecache_size() const {
  return _internal_resourcecache_size();
}
inline void TMaterialLib::clear_resourcecache() {
  _impl_.resourcecache_.Clear();
}
inline std::string* TMaterialLib::add_resourcecache() {
  std::string* _s = _internal_add_resourcecache();
  // @@protoc_insertion_point(field_add_mutable:HmiScenegraph.TMaterialLib.resourceCache)
  return _s;
}
inline const std::string& TMaterialLib::_internal_resourcecache(int index) const {
  return _impl_.resourcecache_.Get(index);
}
inline const std::string& TMaterialLib::resourcecache(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TMaterialLib.resourceCache)
  return _internal_resourcecache(index);
}
inline std::string* TMaterialLib::mutable_resourcecache(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TMaterialLib.resourceCache)
  return _impl_.resourcecache_.Mutable(index);
}
inline void TMaterialLib::set_resourcecache(int index, const std::string& value) {
  _impl_.resourcecache_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::set_resourcecache(int index, std::string&& value) {
  _impl_.resourcecache_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::set_resourcecache(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.resourcecache_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::set_resourcecache(int index, const char* value, size_t size) {
  _impl_.resourcecache_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HmiScenegraph.TMaterialLib.resourceCache)
}
inline std::string* TMaterialLib::_internal_add_resourcecache() {
  return _impl_.resourcecache_.Add();
}
inline void TMaterialLib::add_resourcecache(const std::string& value) {
  _impl_.resourcecache_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::add_resourcecache(std::string&& value) {
  _impl_.resourcecache_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::add_resourcecache(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.resourcecache_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HmiScenegraph.TMaterialLib.resourceCache)
}
inline void TMaterialLib::add_resourcecache(const char* value, size_t size) {
  _impl_.resourcecache_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HmiScenegraph.TMaterialLib.resourceCache)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMaterialLib::resourcecache() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TMaterialLib.resourceCache)
  return _impl_.resourcecache_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMaterialLib::mutable_resourcecache() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TMaterialLib.resourceCache)
  return &_impl_.resourcecache_;
}

// -------------------------------------------------------------------

// TScene

// required .HmiScenegraph.TNode root = 1;
inline bool TScene::_internal_has_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.root_ != nullptr);
  return value;
}
inline bool TScene::has_root() const {
  return _internal_has_root();
}
inline void TScene::clear_root() {
  if (_impl_.root_ != nullptr) _impl_.root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::HmiScenegraph::TNode& TScene::_internal_root() const {
  const ::HmiScenegraph::TNode* p = _impl_.root_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TNode&>(
      ::HmiScenegraph::_TNode_default_instance_);
}
inline const ::HmiScenegraph::TNode& TScene::root() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScene.root)
  return _internal_root();
}
inline void TScene::unsafe_arena_set_allocated_root(
    ::HmiScenegraph::TNode* root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.root_);
  }
  _impl_.root_ = root;
  if (root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TScene.root)
}
inline ::HmiScenegraph::TNode* TScene::release_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TNode* temp = _impl_.root_;
  _impl_.root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TNode* TScene::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TScene.root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::HmiScenegraph::TNode* temp = _impl_.root_;
  _impl_.root_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TNode* TScene::_internal_mutable_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.root_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TNode>(GetArenaForAllocation());
    _impl_.root_ = p;
  }
  return _impl_.root_;
}
inline ::HmiScenegraph::TNode* TScene::mutable_root() {
  ::HmiScenegraph::TNode* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TScene.root)
  return _msg;
}
inline void TScene::set_allocated_root(::HmiScenegraph::TNode* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.root_ = root;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TScene.root)
}

// optional .HmiScenegraph.TMaterialLib materialLibrary = 3;
inline bool TScene::_internal_has_materiallibrary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.materiallibrary_ != nullptr);
  return value;
}
inline bool TScene::has_materiallibrary() const {
  return _internal_has_materiallibrary();
}
inline void TScene::clear_materiallibrary() {
  if (_impl_.materiallibrary_ != nullptr) _impl_.materiallibrary_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::HmiScenegraph::TMaterialLib& TScene::_internal_materiallibrary() const {
  const ::HmiScenegraph::TMaterialLib* p = _impl_.materiallibrary_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiScenegraph::TMaterialLib&>(
      ::HmiScenegraph::_TMaterialLib_default_instance_);
}
inline const ::HmiScenegraph::TMaterialLib& TScene::materiallibrary() const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScene.materialLibrary)
  return _internal_materiallibrary();
}
inline void TScene::unsafe_arena_set_allocated_materiallibrary(
    ::HmiScenegraph::TMaterialLib* materiallibrary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.materiallibrary_);
  }
  _impl_.materiallibrary_ = materiallibrary;
  if (materiallibrary) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiScenegraph.TScene.materialLibrary)
}
inline ::HmiScenegraph::TMaterialLib* TScene::release_materiallibrary() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TMaterialLib* temp = _impl_.materiallibrary_;
  _impl_.materiallibrary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiScenegraph::TMaterialLib* TScene::unsafe_arena_release_materiallibrary() {
  // @@protoc_insertion_point(field_release:HmiScenegraph.TScene.materialLibrary)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::HmiScenegraph::TMaterialLib* temp = _impl_.materiallibrary_;
  _impl_.materiallibrary_ = nullptr;
  return temp;
}
inline ::HmiScenegraph::TMaterialLib* TScene::_internal_mutable_materiallibrary() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.materiallibrary_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiScenegraph::TMaterialLib>(GetArenaForAllocation());
    _impl_.materiallibrary_ = p;
  }
  return _impl_.materiallibrary_;
}
inline ::HmiScenegraph::TMaterialLib* TScene::mutable_materiallibrary() {
  ::HmiScenegraph::TMaterialLib* _msg = _internal_mutable_materiallibrary();
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TScene.materialLibrary)
  return _msg;
}
inline void TScene::set_allocated_materiallibrary(::HmiScenegraph::TMaterialLib* materiallibrary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.materiallibrary_;
  }
  if (materiallibrary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(materiallibrary);
    if (message_arena != submessage_arena) {
      materiallibrary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, materiallibrary, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.materiallibrary_ = materiallibrary;
  // @@protoc_insertion_point(field_set_allocated:HmiScenegraph.TScene.materialLibrary)
}

// repeated .HmiScenegraph.TRenderPass renderPass = 4 [deprecated = true];
inline int TScene::_internal_renderpass_size() const {
  return _impl_.renderpass_.size();
}
inline int TScene::renderpass_size() const {
  return _internal_renderpass_size();
}
inline void TScene::clear_renderpass() {
  _impl_.renderpass_.Clear();
}
inline ::HmiScenegraph::TRenderPass* TScene::mutable_renderpass(int index) {
  // @@protoc_insertion_point(field_mutable:HmiScenegraph.TScene.renderPass)
  return _impl_.renderpass_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >*
TScene::mutable_renderpass() {
  // @@protoc_insertion_point(field_mutable_list:HmiScenegraph.TScene.renderPass)
  return &_impl_.renderpass_;
}
inline const ::HmiScenegraph::TRenderPass& TScene::_internal_renderpass(int index) const {
  return _impl_.renderpass_.Get(index);
}
inline const ::HmiScenegraph::TRenderPass& TScene::renderpass(int index) const {
  // @@protoc_insertion_point(field_get:HmiScenegraph.TScene.renderPass)
  return _internal_renderpass(index);
}
inline ::HmiScenegraph::TRenderPass* TScene::_internal_add_renderpass() {
  return _impl_.renderpass_.Add();
}
inline ::HmiScenegraph::TRenderPass* TScene::add_renderpass() {
  ::HmiScenegraph::TRenderPass* _add = _internal_add_renderpass();
  // @@protoc_insertion_point(field_add:HmiScenegraph.TScene.renderPass)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HmiScenegraph::TRenderPass >&
TScene::renderpass() const {
  // @@protoc_insertion_point(field_list:HmiScenegraph.TScene.renderPass)
  return _impl_.renderpass_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace HmiScenegraph

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::HmiScenegraph::TECameraProjectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TECameraProjectionType>() {
  return ::HmiScenegraph::TECameraProjectionType_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEAttributeUsage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEAttributeUsage>() {
  return ::HmiScenegraph::TEAttributeUsage_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEBitmapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEBitmapType>() {
  return ::HmiScenegraph::TEBitmapType_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TESemanticValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TESemanticValue>() {
  return ::HmiScenegraph::TESemanticValue_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TERenderBufferAccessMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TERenderBufferAccessMode>() {
  return ::HmiScenegraph::TERenderBufferAccessMode_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEPrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEPrimitiveType>() {
  return ::HmiScenegraph::TEPrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEIndexDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEIndexDataType>() {
  return ::HmiScenegraph::TEIndexDataType_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEAttributePrecision> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEAttributePrecision>() {
  return ::HmiScenegraph::TEAttributePrecision_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEAttributeSize> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEAttributeSize>() {
  return ::HmiScenegraph::TEAttributeSize_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEAttributeSemantic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEAttributeSemantic>() {
  return ::HmiScenegraph::TEAttributeSemantic_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TEAxis> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TEAxis>() {
  return ::HmiScenegraph::TEAxis_descriptor();
}
template <> struct is_proto_enum< ::HmiScenegraph::TERenderBinSortOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HmiScenegraph::TERenderBinSortOrder>() {
  return ::HmiScenegraph::TERenderBinSortOrder_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Scenegraph_2eproto
