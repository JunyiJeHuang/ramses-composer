// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Numeric.proto

#include "proto/Numeric.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR TVector2i::TVector2i(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct TVector2iDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector2iDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector2iDefaultTypeInternal() {}
  union {
    TVector2i _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector2iDefaultTypeInternal _TVector2i_default_instance_;
PROTOBUF_CONSTEXPR TVector3i::TVector3i(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct TVector3iDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector3iDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector3iDefaultTypeInternal() {}
  union {
    TVector3i _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector3iDefaultTypeInternal _TVector3i_default_instance_;
PROTOBUF_CONSTEXPR TVector4i::TVector4i(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0} {}
struct TVector4iDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector4iDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector4iDefaultTypeInternal() {}
  union {
    TVector4i _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector4iDefaultTypeInternal _TVector4i_default_instance_;
PROTOBUF_CONSTEXPR TVector2f::TVector2f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct TVector2fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector2fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector2fDefaultTypeInternal() {}
  union {
    TVector2f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector2fDefaultTypeInternal _TVector2f_default_instance_;
PROTOBUF_CONSTEXPR TVector3f::TVector3f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct TVector3fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector3fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector3fDefaultTypeInternal() {}
  union {
    TVector3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector3fDefaultTypeInternal _TVector3f_default_instance_;
PROTOBUF_CONSTEXPR TVector4f::TVector4f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.w_)*/0} {}
struct TVector4fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TVector4fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TVector4fDefaultTypeInternal() {}
  union {
    TVector4f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TVector4fDefaultTypeInternal _TVector4f_default_instance_;
PROTOBUF_CONSTEXPR TMatrix3x3f::TMatrix3x3f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m11_)*/0
  , /*decltype(_impl_.m12_)*/0
  , /*decltype(_impl_.m13_)*/0
  , /*decltype(_impl_.m21_)*/0
  , /*decltype(_impl_.m22_)*/0
  , /*decltype(_impl_.m23_)*/0
  , /*decltype(_impl_.m31_)*/0
  , /*decltype(_impl_.m32_)*/0
  , /*decltype(_impl_.m33_)*/0} {}
struct TMatrix3x3fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMatrix3x3fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMatrix3x3fDefaultTypeInternal() {}
  union {
    TMatrix3x3f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMatrix3x3fDefaultTypeInternal _TMatrix3x3f_default_instance_;
PROTOBUF_CONSTEXPR TMatrix4x4f::TMatrix4x4f(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m11_)*/0
  , /*decltype(_impl_.m12_)*/0
  , /*decltype(_impl_.m13_)*/0
  , /*decltype(_impl_.m14_)*/0
  , /*decltype(_impl_.m21_)*/0
  , /*decltype(_impl_.m22_)*/0
  , /*decltype(_impl_.m23_)*/0
  , /*decltype(_impl_.m24_)*/0
  , /*decltype(_impl_.m31_)*/0
  , /*decltype(_impl_.m32_)*/0
  , /*decltype(_impl_.m33_)*/0
  , /*decltype(_impl_.m34_)*/0
  , /*decltype(_impl_.m41_)*/0
  , /*decltype(_impl_.m42_)*/0
  , /*decltype(_impl_.m43_)*/0
  , /*decltype(_impl_.m44_)*/0} {}
struct TMatrix4x4fDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMatrix4x4fDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMatrix4x4fDefaultTypeInternal() {}
  union {
    TMatrix4x4f _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMatrix4x4fDefaultTypeInternal _TMatrix4x4f_default_instance_;
PROTOBUF_CONSTEXPR TAxisAlignedBoundingBox::TAxisAlignedBoundingBox(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.min_)*/nullptr
  , /*decltype(_impl_.max_)*/nullptr} {}
struct TAxisAlignedBoundingBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TAxisAlignedBoundingBoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TAxisAlignedBoundingBoxDefaultTypeInternal() {}
  union {
    TAxisAlignedBoundingBox _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TAxisAlignedBoundingBoxDefaultTypeInternal _TAxisAlignedBoundingBox_default_instance_;
PROTOBUF_CONSTEXPR TNumericValue::TNumericValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.vec2f_)*/nullptr
  , /*decltype(_impl_.vec3f_)*/nullptr
  , /*decltype(_impl_.vec4f_)*/nullptr
  , /*decltype(_impl_.vec2i_)*/nullptr
  , /*decltype(_impl_.vec3i_)*/nullptr
  , /*decltype(_impl_.vec4i_)*/nullptr
  , /*decltype(_impl_.floatmatrix3_)*/nullptr
  , /*decltype(_impl_.floatmatrix4_)*/nullptr
  , /*decltype(_impl_.int__)*/0
  , /*decltype(_impl_.uint_)*/0u
  , /*decltype(_impl_.float__)*/0} {}
struct TNumericValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TNumericValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TNumericValueDefaultTypeInternal() {}
  union {
    TNumericValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TNumericValueDefaultTypeInternal _TNumericValue_default_instance_;
PROTOBUF_CONSTEXPR TMultidimensionalPoint::TMultidimensionalPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.domain_)*/0} {}
struct TMultidimensionalPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMultidimensionalPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMultidimensionalPointDefaultTypeInternal() {}
  union {
    TMultidimensionalPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMultidimensionalPointDefaultTypeInternal _TMultidimensionalPoint_default_instance_;
PROTOBUF_CONSTEXPR TCurvePointInterpolation::TCurvePointInterpolation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tangentvector_)*/nullptr
  , /*decltype(_impl_.interpolation_)*/0} {}
struct TCurvePointInterpolationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TCurvePointInterpolationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TCurvePointInterpolationDefaultTypeInternal() {}
  union {
    TCurvePointInterpolation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TCurvePointInterpolationDefaultTypeInternal _TCurvePointInterpolation_default_instance_;
PROTOBUF_CONSTEXPR TCurvePoint::TCurvePoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.incomminginterpolation_)*/nullptr
  , /*decltype(_impl_.outgoinginterpolation_)*/nullptr} {}
struct TCurvePointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TCurvePointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TCurvePointDefaultTypeInternal() {}
  union {
    TCurvePoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TCurvePointDefaultTypeInternal _TCurvePoint_default_instance_;
PROTOBUF_CONSTEXPR TCurveDefinition::TCurveDefinition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/{}
  , /*decltype(_impl_.curvevaluetype_)*/1} {}
struct TCurveDefinitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TCurveDefinitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TCurveDefinitionDefaultTypeInternal() {}
  union {
    TCurveDefinition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TCurveDefinitionDefaultTypeInternal _TCurveDefinition_default_instance_;
PROTOBUF_CONSTEXPR TKeyFrame::TKeyFrame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.frame_)*/0} {}
struct TKeyFrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TKeyFrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TKeyFrameDefaultTypeInternal() {}
  union {
    TKeyFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TKeyFrameDefaultTypeInternal _TKeyFrame_default_instance_;
PROTOBUF_CONSTEXPR TKeyFrameSequence::TKeyFrameSequence(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.keyframe_)*/{}
  , /*decltype(_impl_.fps_)*/0
  , /*decltype(_impl_.type_)*/1} {}
struct TKeyFrameSequenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TKeyFrameSequenceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TKeyFrameSequenceDefaultTypeInternal() {}
  union {
    TKeyFrameSequence _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TKeyFrameSequenceDefaultTypeInternal _TKeyFrameSequence_default_instance_;
static ::_pb::Metadata file_level_metadata_Numeric_2eproto[16];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Numeric_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Numeric_2eproto = nullptr;

const uint32_t TableStruct_Numeric_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TVector2i, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector2i, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector2i, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector2i, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TVector3i, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector3i, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector3i, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector3i, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::TVector3i, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TVector4i, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector4i, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector4i, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector4i, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::TVector4i, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::TVector4i, _impl_.w_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TVector2f, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector2f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector2f, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector2f, _impl_.y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TVector3f, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector3f, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector3f, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::TVector3f, _impl_.z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TVector4f, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TVector4f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TVector4f, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::TVector4f, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::TVector4f, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::TVector4f, _impl_.w_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m11_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m12_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m13_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m21_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m22_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m23_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m31_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m32_),
  PROTOBUF_FIELD_OFFSET(::TMatrix3x3f, _impl_.m33_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m11_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m12_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m13_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m14_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m21_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m22_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m23_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m24_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m31_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m32_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m33_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m34_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m41_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m42_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m43_),
  PROTOBUF_FIELD_OFFSET(::TMatrix4x4f, _impl_.m44_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::TAxisAlignedBoundingBox, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TAxisAlignedBoundingBox, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TAxisAlignedBoundingBox, _impl_.min_),
  PROTOBUF_FIELD_OFFSET(::TAxisAlignedBoundingBox, _impl_.max_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.int__),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.uint_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.float__),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec2f_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec3f_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec4f_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec2i_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec3i_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.vec4i_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.floatmatrix3_),
  PROTOBUF_FIELD_OFFSET(::TNumericValue, _impl_.floatmatrix4_),
  8,
  9,
  10,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TMultidimensionalPoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TMultidimensionalPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TMultidimensionalPoint, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::TMultidimensionalPoint, _impl_.domain_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TCurvePointInterpolation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TCurvePointInterpolation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TCurvePointInterpolation, _impl_.interpolation_),
  PROTOBUF_FIELD_OFFSET(::TCurvePointInterpolation, _impl_.tangentvector_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TCurvePoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TCurvePoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TCurvePoint, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::TCurvePoint, _impl_.incomminginterpolation_),
  PROTOBUF_FIELD_OFFSET(::TCurvePoint, _impl_.outgoinginterpolation_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TCurveDefinition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TCurveDefinition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TCurveDefinition, _impl_.curvevaluetype_),
  PROTOBUF_FIELD_OFFSET(::TCurveDefinition, _impl_.point_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TKeyFrame, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TKeyFrame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TKeyFrame, _impl_.frame_),
  PROTOBUF_FIELD_OFFSET(::TKeyFrame, _impl_.value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TKeyFrameSequence, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TKeyFrameSequence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TKeyFrameSequence, _impl_.fps_),
  PROTOBUF_FIELD_OFFSET(::TKeyFrameSequence, _impl_.keyframe_),
  PROTOBUF_FIELD_OFFSET(::TKeyFrameSequence, _impl_.type_),
  0,
  ~0u,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::TVector2i)},
  { 10, 19, -1, sizeof(::TVector3i)},
  { 22, 32, -1, sizeof(::TVector4i)},
  { 36, 44, -1, sizeof(::TVector2f)},
  { 46, 55, -1, sizeof(::TVector3f)},
  { 58, 68, -1, sizeof(::TVector4f)},
  { 72, 87, -1, sizeof(::TMatrix3x3f)},
  { 96, 118, -1, sizeof(::TMatrix4x4f)},
  { 134, 142, -1, sizeof(::TAxisAlignedBoundingBox)},
  { 144, 161, -1, sizeof(::TNumericValue)},
  { 172, 180, -1, sizeof(::TMultidimensionalPoint)},
  { 182, 190, -1, sizeof(::TCurvePointInterpolation)},
  { 192, 201, -1, sizeof(::TCurvePoint)},
  { 204, 212, -1, sizeof(::TCurveDefinition)},
  { 214, 222, -1, sizeof(::TKeyFrame)},
  { 224, 233, -1, sizeof(::TKeyFrameSequence)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_TVector2i_default_instance_._instance,
  &::_TVector3i_default_instance_._instance,
  &::_TVector4i_default_instance_._instance,
  &::_TVector2f_default_instance_._instance,
  &::_TVector3f_default_instance_._instance,
  &::_TVector4f_default_instance_._instance,
  &::_TMatrix3x3f_default_instance_._instance,
  &::_TMatrix4x4f_default_instance_._instance,
  &::_TAxisAlignedBoundingBox_default_instance_._instance,
  &::_TNumericValue_default_instance_._instance,
  &::_TMultidimensionalPoint_default_instance_._instance,
  &::_TCurvePointInterpolation_default_instance_._instance,
  &::_TCurvePoint_default_instance_._instance,
  &::_TCurveDefinition_default_instance_._instance,
  &::_TKeyFrame_default_instance_._instance,
  &::_TKeyFrameSequence_default_instance_._instance,
};

const char descriptor_table_protodef_Numeric_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rNumeric.proto\"!\n\tTVector2i\022\t\n\001x\030\001 \002(\005\022"
  "\t\n\001y\030\002 \002(\005\",\n\tTVector3i\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030"
  "\002 \002(\005\022\t\n\001z\030\003 \002(\005\"7\n\tTVector4i\022\t\n\001x\030\001 \002(\005"
  "\022\t\n\001y\030\002 \002(\005\022\t\n\001z\030\003 \002(\005\022\t\n\001w\030\004 \002(\005\"!\n\tTVe"
  "ctor2f\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\",\n\tTVector3"
  "f\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"7\n\tTV"
  "ector4f\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002"
  "\022\t\n\001w\030\004 \002(\002\"\202\001\n\013TMatrix3x3f\022\013\n\003m11\030\001 \001(\002"
  "\022\013\n\003m12\030\002 \001(\002\022\013\n\003m13\030\003 \001(\002\022\013\n\003m21\030\004 \001(\002\022"
  "\013\n\003m22\030\005 \001(\002\022\013\n\003m23\030\006 \001(\002\022\013\n\003m31\030\007 \001(\002\022\013"
  "\n\003m32\030\010 \001(\002\022\013\n\003m33\030\t \001(\002\"\335\001\n\013TMatrix4x4f"
  "\022\013\n\003m11\030\001 \001(\002\022\013\n\003m12\030\002 \001(\002\022\013\n\003m13\030\003 \001(\002\022"
  "\013\n\003m14\030\004 \001(\002\022\013\n\003m21\030\005 \001(\002\022\013\n\003m22\030\006 \001(\002\022\013"
  "\n\003m23\030\007 \001(\002\022\013\n\003m24\030\010 \001(\002\022\013\n\003m31\030\t \001(\002\022\013\n"
  "\003m32\030\n \001(\002\022\013\n\003m33\030\013 \001(\002\022\013\n\003m34\030\014 \001(\002\022\013\n\003"
  "m41\030\r \001(\002\022\013\n\003m42\030\016 \001(\002\022\013\n\003m43\030\017 \001(\002\022\013\n\003m"
  "44\030\020 \001(\002\"K\n\027TAxisAlignedBoundingBox\022\027\n\003m"
  "in\030\001 \002(\0132\n.TVector3f\022\027\n\003max\030\002 \002(\0132\n.TVec"
  "tor3f\"\243\002\n\rTNumericValue\022\013\n\003Int\030\001 \001(\005\022\014\n\004"
  "UInt\030\002 \001(\r\022\r\n\005Float\030\003 \001(\002\022\031\n\005Vec2f\030\004 \001(\013"
  "2\n.TVector2f\022\031\n\005Vec3f\030\005 \001(\0132\n.TVector3f\022"
  "\031\n\005Vec4f\030\006 \001(\0132\n.TVector4f\022\031\n\005Vec2i\030\007 \001("
  "\0132\n.TVector2i\022\031\n\005Vec3i\030\010 \001(\0132\n.TVector3i"
  "\022\031\n\005Vec4i\030\t \001(\0132\n.TVector4i\022\"\n\014FloatMatr"
  "ix3\030\n \001(\0132\014.TMatrix3x3f\022\"\n\014FloatMatrix4\030"
  "\013 \001(\0132\014.TMatrix4x4f\"G\n\026TMultidimensional"
  "Point\022\035\n\005value\030\001 \002(\0132\016.TNumericValue\022\016\n\006"
  "domain\030\002 \002(\002\"\200\001\n\030TCurvePointInterpolatio"
  "n\0224\n\rinterpolation\030\001 \002(\0162\035.TCurvePointIn"
  "terpolationType\022.\n\rtangentVector\030\002 \001(\0132\027"
  ".TMultidimensionalPoint\"\252\001\n\013TCurvePoint\022"
  "&\n\005point\030\001 \002(\0132\027.TMultidimensionalPoint\022"
  "9\n\026incommingInterpolation\030\002 \001(\0132\031.TCurve"
  "PointInterpolation\0228\n\025outgoingInterpolat"
  "ion\030\003 \001(\0132\031.TCurvePointInterpolation\"W\n\020"
  "TCurveDefinition\022&\n\016curveValueType\030\001 \002(\016"
  "2\016.TENumericType\022\033\n\005point\030\002 \003(\0132\014.TCurve"
  "Point\"9\n\tTKeyFrame\022\r\n\005frame\030\001 \002(\005\022\035\n\005val"
  "ue\030\002 \001(\0132\016.TNumericValue\"\\\n\021TKeyFrameSeq"
  "uence\022\013\n\003fps\030\001 \001(\002\022\034\n\010keyFrame\030\002 \003(\0132\n.T"
  "KeyFrame\022\034\n\004type\030\003 \002(\0162\016.TENumericType*\340"
  "\002\n\rTENumericType\022\031\n\025TENumericType_intege"
  "r\020\001\022!\n\035TENumericType_unsignedInteger\020\002\022\027"
  "\n\023TENumericType_float\020\003\022\036\n\032TENumericType"
  "_floatVector2\020\004\022\036\n\032TENumericType_floatVe"
  "ctor3\020\005\022\036\n\032TENumericType_floatVector4\020\006\022"
  "\034\n\030TENumericType_intVector2\020\007\022\034\n\030TENumer"
  "icType_intVector3\020\010\022\034\n\030TENumericType_int"
  "Vector4\020\t\022\036\n\032TENumericType_floatMatrix3\020"
  "\n\022\036\n\032TENumericType_floatMatrix4\020\013*\230\001\n\034TC"
  "urvePointInterpolationType\022%\n!TCurvePoin"
  "tInterpolationType_Step\020\000\022\'\n#TCurvePoint"
  "InterpolationType_Linear\020\001\022(\n$TCurvePoin"
  "tInterpolationType_Hermite\020\002"
  ;
static ::_pbi::once_flag descriptor_table_Numeric_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Numeric_2eproto = {
    false, false, 2148, descriptor_table_protodef_Numeric_2eproto,
    "Numeric.proto",
    &descriptor_table_Numeric_2eproto_once, nullptr, 0, 16,
    schemas, file_default_instances, TableStruct_Numeric_2eproto::offsets,
    file_level_metadata_Numeric_2eproto, file_level_enum_descriptors_Numeric_2eproto,
    file_level_service_descriptors_Numeric_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Numeric_2eproto_getter() {
  return &descriptor_table_Numeric_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Numeric_2eproto(&descriptor_table_Numeric_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TENumericType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Numeric_2eproto);
  return file_level_enum_descriptors_Numeric_2eproto[0];
}
bool TENumericType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TCurvePointInterpolationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Numeric_2eproto);
  return file_level_enum_descriptors_Numeric_2eproto[1];
}
bool TCurvePointInterpolationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TVector2i::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector2i>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector2i, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TVector2i::TVector2i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector2i)
}
TVector2i::TVector2i(const TVector2i& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector2i* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:TVector2i)
}

inline void TVector2i::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

TVector2i::~TVector2i() {
  // @@protoc_insertion_point(destructor:TVector2i)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector2i::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector2i::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector2i::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector2i)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector2i::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector2i::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector2i)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector2i)
  return target;
}

size_t TVector2i::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector2i)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t TVector2i::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector2i)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector2i::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector2i::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector2i::GetClassData() const { return &_class_data_; }


void TVector2i::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector2i*>(&to_msg);
  auto& from = static_cast<const TVector2i&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector2i)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector2i::CopyFrom(const TVector2i& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector2i)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector2i::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector2i::InternalSwap(TVector2i* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector2i, _impl_.y_)
      + sizeof(TVector2i::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(TVector2i, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector2i::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[0]);
}

// ===================================================================

class TVector3i::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector3i>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector3i, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TVector3i::TVector3i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector3i)
}
TVector3i::TVector3i(const TVector3i& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector3i* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:TVector3i)
}

inline void TVector3i::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

TVector3i::~TVector3i() {
  // @@protoc_insertion_point(destructor:TVector3i)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector3i::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector3i::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector3i::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector3i)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector3i::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector3i::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector3i)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // required int32 z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector3i)
  return target;
}

size_t TVector3i::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector3i)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  if (_internal_has_z()) {
    // required int32 z = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());
  }

  return total_size;
}
size_t TVector3i::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector3i)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

    // required int32 z = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector3i::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector3i::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector3i::GetClassData() const { return &_class_data_; }


void TVector3i::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector3i*>(&to_msg);
  auto& from = static_cast<const TVector3i&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector3i)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector3i::CopyFrom(const TVector3i& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector3i)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector3i::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector3i::InternalSwap(TVector3i* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector3i, _impl_.z_)
      + sizeof(TVector3i::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(TVector3i, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector3i::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[1]);
}

// ===================================================================

class TVector4i::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector4i>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector4i, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TVector4i::TVector4i(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector4i)
}
TVector4i::TVector4i(const TVector4i& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector4i* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:TVector4i)
}

inline void TVector4i::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
  };
}

TVector4i::~TVector4i() {
  // @@protoc_insertion_point(destructor:TVector4i)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector4i::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector4i::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector4i::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector4i)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.w_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector4i::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_w(&has_bits);
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector4i::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector4i)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // required int32 z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_z(), target);
  }

  // required int32 w = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector4i)
  return target;
}

size_t TVector4i::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector4i)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  if (_internal_has_z()) {
    // required int32 z = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());
  }

  if (_internal_has_w()) {
    // required int32 w = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_w());
  }

  return total_size;
}
size_t TVector4i::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector4i)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

    // required int32 z = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());

    // required int32 w = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_w());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector4i::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector4i::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector4i::GetClassData() const { return &_class_data_; }


void TVector4i::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector4i*>(&to_msg);
  auto& from = static_cast<const TVector4i&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector4i)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.w_ = from._impl_.w_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector4i::CopyFrom(const TVector4i& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector4i)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector4i::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector4i::InternalSwap(TVector4i* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector4i, _impl_.w_)
      + sizeof(TVector4i::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(TVector4i, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector4i::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[2]);
}

// ===================================================================

class TVector2f::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector2f>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector2f, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TVector2f::TVector2f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector2f)
}
TVector2f::TVector2f(const TVector2f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector2f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:TVector2f)
}

inline void TVector2f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

TVector2f::~TVector2f() {
  // @@protoc_insertion_point(destructor:TVector2f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector2f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector2f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector2f::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector2f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector2f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector2f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector2f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector2f)
  return target;
}

size_t TVector2f::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector2f)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t TVector2f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector2f)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector2f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector2f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector2f::GetClassData() const { return &_class_data_; }


void TVector2f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector2f*>(&to_msg);
  auto& from = static_cast<const TVector2f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector2f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector2f::CopyFrom(const TVector2f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector2f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector2f::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector2f::InternalSwap(TVector2f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector2f, _impl_.y_)
      + sizeof(TVector2f::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(TVector2f, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector2f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[3]);
}

// ===================================================================

class TVector3f::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector3f>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector3f, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TVector3f::TVector3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector3f)
}
TVector3f::TVector3f(const TVector3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector3f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:TVector3f)
}

inline void TVector3f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

TVector3f::~TVector3f() {
  // @@protoc_insertion_point(destructor:TVector3f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector3f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector3f::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector3f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // required float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector3f)
  return target;
}

size_t TVector3f::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector3f)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t TVector3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector3f)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector3f::GetClassData() const { return &_class_data_; }


void TVector3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector3f*>(&to_msg);
  auto& from = static_cast<const TVector3f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector3f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector3f::CopyFrom(const TVector3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector3f::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector3f::InternalSwap(TVector3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector3f, _impl_.z_)
      + sizeof(TVector3f::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(TVector3f, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector3f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[4]);
}

// ===================================================================

class TVector4f::_Internal {
 public:
  using HasBits = decltype(std::declval<TVector4f>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TVector4f, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TVector4f::TVector4f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TVector4f)
}
TVector4f::TVector4f(const TVector4f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TVector4f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.w_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.w_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  // @@protoc_insertion_point(copy_constructor:TVector4f)
}

inline void TVector4f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.w_){0}
  };
}

TVector4f::~TVector4f() {
  // @@protoc_insertion_point(destructor:TVector4f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TVector4f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TVector4f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TVector4f::Clear() {
// @@protoc_insertion_point(message_clear_start:TVector4f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.w_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TVector4f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float w = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_w(&has_bits);
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TVector4f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TVector4f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // required float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // required float w = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TVector4f)
  return target;
}

size_t TVector4f::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TVector4f)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_w()) {
    // required float w = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t TVector4f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TVector4f)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

    // required float w = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TVector4f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TVector4f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TVector4f::GetClassData() const { return &_class_data_; }


void TVector4f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TVector4f*>(&to_msg);
  auto& from = static_cast<const TVector4f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TVector4f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.w_ = from._impl_.w_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TVector4f::CopyFrom(const TVector4f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TVector4f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TVector4f::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TVector4f::InternalSwap(TVector4f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TVector4f, _impl_.w_)
      + sizeof(TVector4f::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(TVector4f, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TVector4f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[5]);
}

// ===================================================================

class TMatrix3x3f::_Internal {
 public:
  using HasBits = decltype(std::declval<TMatrix3x3f>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMatrix3x3f, _impl_._has_bits_);
  static void set_has_m11(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m12(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m13(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m21(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m22(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m23(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_m31(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_m32(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_m33(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

TMatrix3x3f::TMatrix3x3f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TMatrix3x3f)
}
TMatrix3x3f::TMatrix3x3f(const TMatrix3x3f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMatrix3x3f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m11_){}
    , decltype(_impl_.m12_){}
    , decltype(_impl_.m13_){}
    , decltype(_impl_.m21_){}
    , decltype(_impl_.m22_){}
    , decltype(_impl_.m23_){}
    , decltype(_impl_.m31_){}
    , decltype(_impl_.m32_){}
    , decltype(_impl_.m33_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m11_, &from._impl_.m11_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m33_) -
    reinterpret_cast<char*>(&_impl_.m11_)) + sizeof(_impl_.m33_));
  // @@protoc_insertion_point(copy_constructor:TMatrix3x3f)
}

inline void TMatrix3x3f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m11_){0}
    , decltype(_impl_.m12_){0}
    , decltype(_impl_.m13_){0}
    , decltype(_impl_.m21_){0}
    , decltype(_impl_.m22_){0}
    , decltype(_impl_.m23_){0}
    , decltype(_impl_.m31_){0}
    , decltype(_impl_.m32_){0}
    , decltype(_impl_.m33_){0}
  };
}

TMatrix3x3f::~TMatrix3x3f() {
  // @@protoc_insertion_point(destructor:TMatrix3x3f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMatrix3x3f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TMatrix3x3f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMatrix3x3f::Clear() {
// @@protoc_insertion_point(message_clear_start:TMatrix3x3f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.m11_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m32_) -
        reinterpret_cast<char*>(&_impl_.m11_)) + sizeof(_impl_.m32_));
  }
  _impl_.m33_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMatrix3x3f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float m11 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_m11(&has_bits);
          _impl_.m11_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m12 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_m12(&has_bits);
          _impl_.m12_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m13 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_m13(&has_bits);
          _impl_.m13_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m21 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_m21(&has_bits);
          _impl_.m21_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m22 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_m22(&has_bits);
          _impl_.m22_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m23 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_m23(&has_bits);
          _impl_.m23_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m31 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_m31(&has_bits);
          _impl_.m31_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m32 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_m32(&has_bits);
          _impl_.m32_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m33 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_m33(&has_bits);
          _impl_.m33_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMatrix3x3f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TMatrix3x3f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float m11 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_m11(), target);
  }

  // optional float m12 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_m12(), target);
  }

  // optional float m13 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_m13(), target);
  }

  // optional float m21 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_m21(), target);
  }

  // optional float m22 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_m22(), target);
  }

  // optional float m23 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_m23(), target);
  }

  // optional float m31 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_m31(), target);
  }

  // optional float m32 = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_m32(), target);
  }

  // optional float m33 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_m33(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TMatrix3x3f)
  return target;
}

size_t TMatrix3x3f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TMatrix3x3f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float m11 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float m12 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float m13 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float m21 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float m22 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float m23 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float m31 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float m32 = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional float m33 = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMatrix3x3f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMatrix3x3f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMatrix3x3f::GetClassData() const { return &_class_data_; }


void TMatrix3x3f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMatrix3x3f*>(&to_msg);
  auto& from = static_cast<const TMatrix3x3f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TMatrix3x3f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m11_ = from._impl_.m11_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m12_ = from._impl_.m12_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m13_ = from._impl_.m13_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m21_ = from._impl_.m21_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m22_ = from._impl_.m22_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m23_ = from._impl_.m23_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.m31_ = from._impl_.m31_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.m32_ = from._impl_.m32_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_m33(from._internal_m33());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMatrix3x3f::CopyFrom(const TMatrix3x3f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TMatrix3x3f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMatrix3x3f::IsInitialized() const {
  return true;
}

void TMatrix3x3f::InternalSwap(TMatrix3x3f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMatrix3x3f, _impl_.m33_)
      + sizeof(TMatrix3x3f::_impl_.m33_)
      - PROTOBUF_FIELD_OFFSET(TMatrix3x3f, _impl_.m11_)>(
          reinterpret_cast<char*>(&_impl_.m11_),
          reinterpret_cast<char*>(&other->_impl_.m11_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMatrix3x3f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[6]);
}

// ===================================================================

class TMatrix4x4f::_Internal {
 public:
  using HasBits = decltype(std::declval<TMatrix4x4f>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMatrix4x4f, _impl_._has_bits_);
  static void set_has_m11(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m12(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m13(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m14(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m21(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m22(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_m23(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_m24(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_m31(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_m32(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_m33(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_m34(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_m41(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_m42(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_m43(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_m44(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

TMatrix4x4f::TMatrix4x4f(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TMatrix4x4f)
}
TMatrix4x4f::TMatrix4x4f(const TMatrix4x4f& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMatrix4x4f* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m11_){}
    , decltype(_impl_.m12_){}
    , decltype(_impl_.m13_){}
    , decltype(_impl_.m14_){}
    , decltype(_impl_.m21_){}
    , decltype(_impl_.m22_){}
    , decltype(_impl_.m23_){}
    , decltype(_impl_.m24_){}
    , decltype(_impl_.m31_){}
    , decltype(_impl_.m32_){}
    , decltype(_impl_.m33_){}
    , decltype(_impl_.m34_){}
    , decltype(_impl_.m41_){}
    , decltype(_impl_.m42_){}
    , decltype(_impl_.m43_){}
    , decltype(_impl_.m44_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m11_, &from._impl_.m11_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m44_) -
    reinterpret_cast<char*>(&_impl_.m11_)) + sizeof(_impl_.m44_));
  // @@protoc_insertion_point(copy_constructor:TMatrix4x4f)
}

inline void TMatrix4x4f::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m11_){0}
    , decltype(_impl_.m12_){0}
    , decltype(_impl_.m13_){0}
    , decltype(_impl_.m14_){0}
    , decltype(_impl_.m21_){0}
    , decltype(_impl_.m22_){0}
    , decltype(_impl_.m23_){0}
    , decltype(_impl_.m24_){0}
    , decltype(_impl_.m31_){0}
    , decltype(_impl_.m32_){0}
    , decltype(_impl_.m33_){0}
    , decltype(_impl_.m34_){0}
    , decltype(_impl_.m41_){0}
    , decltype(_impl_.m42_){0}
    , decltype(_impl_.m43_){0}
    , decltype(_impl_.m44_){0}
  };
}

TMatrix4x4f::~TMatrix4x4f() {
  // @@protoc_insertion_point(destructor:TMatrix4x4f)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMatrix4x4f::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TMatrix4x4f::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMatrix4x4f::Clear() {
// @@protoc_insertion_point(message_clear_start:TMatrix4x4f)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.m11_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m24_) -
        reinterpret_cast<char*>(&_impl_.m11_)) + sizeof(_impl_.m24_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.m31_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m44_) -
        reinterpret_cast<char*>(&_impl_.m31_)) + sizeof(_impl_.m44_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMatrix4x4f::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float m11 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_m11(&has_bits);
          _impl_.m11_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m12 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_m12(&has_bits);
          _impl_.m12_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m13 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_m13(&has_bits);
          _impl_.m13_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m14 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_m14(&has_bits);
          _impl_.m14_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m21 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_m21(&has_bits);
          _impl_.m21_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m22 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_m22(&has_bits);
          _impl_.m22_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m23 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_m23(&has_bits);
          _impl_.m23_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m24 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_m24(&has_bits);
          _impl_.m24_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m31 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_m31(&has_bits);
          _impl_.m31_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m32 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_m32(&has_bits);
          _impl_.m32_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m33 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_m33(&has_bits);
          _impl_.m33_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m34 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_m34(&has_bits);
          _impl_.m34_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m41 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_m41(&has_bits);
          _impl_.m41_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m42 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_m42(&has_bits);
          _impl_.m42_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m43 = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_m43(&has_bits);
          _impl_.m43_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float m44 = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_m44(&has_bits);
          _impl_.m44_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMatrix4x4f::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TMatrix4x4f)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float m11 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_m11(), target);
  }

  // optional float m12 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_m12(), target);
  }

  // optional float m13 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_m13(), target);
  }

  // optional float m14 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_m14(), target);
  }

  // optional float m21 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_m21(), target);
  }

  // optional float m22 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_m22(), target);
  }

  // optional float m23 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_m23(), target);
  }

  // optional float m24 = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_m24(), target);
  }

  // optional float m31 = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_m31(), target);
  }

  // optional float m32 = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_m32(), target);
  }

  // optional float m33 = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_m33(), target);
  }

  // optional float m34 = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_m34(), target);
  }

  // optional float m41 = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_m41(), target);
  }

  // optional float m42 = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_m42(), target);
  }

  // optional float m43 = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_m43(), target);
  }

  // optional float m44 = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_m44(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TMatrix4x4f)
  return target;
}

size_t TMatrix4x4f::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TMatrix4x4f)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float m11 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float m12 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float m13 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float m14 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float m21 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float m22 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float m23 = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float m24 = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float m31 = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float m32 = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float m33 = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float m34 = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float m41 = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float m42 = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float m43 = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float m44 = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMatrix4x4f::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMatrix4x4f::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMatrix4x4f::GetClassData() const { return &_class_data_; }


void TMatrix4x4f::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMatrix4x4f*>(&to_msg);
  auto& from = static_cast<const TMatrix4x4f&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TMatrix4x4f)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m11_ = from._impl_.m11_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m12_ = from._impl_.m12_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m13_ = from._impl_.m13_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m14_ = from._impl_.m14_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m21_ = from._impl_.m21_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m22_ = from._impl_.m22_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.m23_ = from._impl_.m23_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.m24_ = from._impl_.m24_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.m31_ = from._impl_.m31_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.m32_ = from._impl_.m32_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.m33_ = from._impl_.m33_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.m34_ = from._impl_.m34_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.m41_ = from._impl_.m41_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.m42_ = from._impl_.m42_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.m43_ = from._impl_.m43_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.m44_ = from._impl_.m44_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMatrix4x4f::CopyFrom(const TMatrix4x4f& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TMatrix4x4f)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMatrix4x4f::IsInitialized() const {
  return true;
}

void TMatrix4x4f::InternalSwap(TMatrix4x4f* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMatrix4x4f, _impl_.m44_)
      + sizeof(TMatrix4x4f::_impl_.m44_)
      - PROTOBUF_FIELD_OFFSET(TMatrix4x4f, _impl_.m11_)>(
          reinterpret_cast<char*>(&_impl_.m11_),
          reinterpret_cast<char*>(&other->_impl_.m11_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMatrix4x4f::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[7]);
}

// ===================================================================

class TAxisAlignedBoundingBox::_Internal {
 public:
  using HasBits = decltype(std::declval<TAxisAlignedBoundingBox>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TAxisAlignedBoundingBox, _impl_._has_bits_);
  static const ::TVector3f& min(const TAxisAlignedBoundingBox* msg);
  static void set_has_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TVector3f& max(const TAxisAlignedBoundingBox* msg);
  static void set_has_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TVector3f&
TAxisAlignedBoundingBox::_Internal::min(const TAxisAlignedBoundingBox* msg) {
  return *msg->_impl_.min_;
}
const ::TVector3f&
TAxisAlignedBoundingBox::_Internal::max(const TAxisAlignedBoundingBox* msg) {
  return *msg->_impl_.max_;
}
TAxisAlignedBoundingBox::TAxisAlignedBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TAxisAlignedBoundingBox)
}
TAxisAlignedBoundingBox::TAxisAlignedBoundingBox(const TAxisAlignedBoundingBox& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TAxisAlignedBoundingBox* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.min_){nullptr}
    , decltype(_impl_.max_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_min()) {
    _this->_impl_.min_ = new ::TVector3f(*from._impl_.min_);
  }
  if (from._internal_has_max()) {
    _this->_impl_.max_ = new ::TVector3f(*from._impl_.max_);
  }
  // @@protoc_insertion_point(copy_constructor:TAxisAlignedBoundingBox)
}

inline void TAxisAlignedBoundingBox::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.min_){nullptr}
    , decltype(_impl_.max_){nullptr}
  };
}

TAxisAlignedBoundingBox::~TAxisAlignedBoundingBox() {
  // @@protoc_insertion_point(destructor:TAxisAlignedBoundingBox)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TAxisAlignedBoundingBox::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.min_;
  if (this != internal_default_instance()) delete _impl_.max_;
}

void TAxisAlignedBoundingBox::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TAxisAlignedBoundingBox::Clear() {
// @@protoc_insertion_point(message_clear_start:TAxisAlignedBoundingBox)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.min_ != nullptr);
      _impl_.min_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.max_ != nullptr);
      _impl_.max_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TAxisAlignedBoundingBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TVector3f min = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_min(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TVector3f max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_max(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TAxisAlignedBoundingBox::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TAxisAlignedBoundingBox)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TVector3f min = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::min(this),
        _Internal::min(this).GetCachedSize(), target, stream);
  }

  // required .TVector3f max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::max(this),
        _Internal::max(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TAxisAlignedBoundingBox)
  return target;
}

size_t TAxisAlignedBoundingBox::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TAxisAlignedBoundingBox)
  size_t total_size = 0;

  if (_internal_has_min()) {
    // required .TVector3f min = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.min_);
  }

  if (_internal_has_max()) {
    // required .TVector3f max = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.max_);
  }

  return total_size;
}
size_t TAxisAlignedBoundingBox::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TAxisAlignedBoundingBox)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TVector3f min = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.min_);

    // required .TVector3f max = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.max_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TAxisAlignedBoundingBox::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TAxisAlignedBoundingBox::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TAxisAlignedBoundingBox::GetClassData() const { return &_class_data_; }


void TAxisAlignedBoundingBox::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TAxisAlignedBoundingBox*>(&to_msg);
  auto& from = static_cast<const TAxisAlignedBoundingBox&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TAxisAlignedBoundingBox)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_min()->::TVector3f::MergeFrom(
          from._internal_min());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_max()->::TVector3f::MergeFrom(
          from._internal_max());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TAxisAlignedBoundingBox::CopyFrom(const TAxisAlignedBoundingBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TAxisAlignedBoundingBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TAxisAlignedBoundingBox::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_min()) {
    if (!_impl_.min_->IsInitialized()) return false;
  }
  if (_internal_has_max()) {
    if (!_impl_.max_->IsInitialized()) return false;
  }
  return true;
}

void TAxisAlignedBoundingBox::InternalSwap(TAxisAlignedBoundingBox* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TAxisAlignedBoundingBox, _impl_.max_)
      + sizeof(TAxisAlignedBoundingBox::_impl_.max_)
      - PROTOBUF_FIELD_OFFSET(TAxisAlignedBoundingBox, _impl_.min_)>(
          reinterpret_cast<char*>(&_impl_.min_),
          reinterpret_cast<char*>(&other->_impl_.min_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TAxisAlignedBoundingBox::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[8]);
}

// ===================================================================

class TNumericValue::_Internal {
 public:
  using HasBits = decltype(std::declval<TNumericValue>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TNumericValue, _impl_._has_bits_);
  static void set_has_int_(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_uint(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_float_(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TVector2f& vec2f(const TNumericValue* msg);
  static void set_has_vec2f(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TVector3f& vec3f(const TNumericValue* msg);
  static void set_has_vec3f(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TVector4f& vec4f(const TNumericValue* msg);
  static void set_has_vec4f(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TVector2i& vec2i(const TNumericValue* msg);
  static void set_has_vec2i(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TVector3i& vec3i(const TNumericValue* msg);
  static void set_has_vec3i(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TVector4i& vec4i(const TNumericValue* msg);
  static void set_has_vec4i(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TMatrix3x3f& floatmatrix3(const TNumericValue* msg);
  static void set_has_floatmatrix3(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TMatrix4x4f& floatmatrix4(const TNumericValue* msg);
  static void set_has_floatmatrix4(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::TVector2f&
TNumericValue::_Internal::vec2f(const TNumericValue* msg) {
  return *msg->_impl_.vec2f_;
}
const ::TVector3f&
TNumericValue::_Internal::vec3f(const TNumericValue* msg) {
  return *msg->_impl_.vec3f_;
}
const ::TVector4f&
TNumericValue::_Internal::vec4f(const TNumericValue* msg) {
  return *msg->_impl_.vec4f_;
}
const ::TVector2i&
TNumericValue::_Internal::vec2i(const TNumericValue* msg) {
  return *msg->_impl_.vec2i_;
}
const ::TVector3i&
TNumericValue::_Internal::vec3i(const TNumericValue* msg) {
  return *msg->_impl_.vec3i_;
}
const ::TVector4i&
TNumericValue::_Internal::vec4i(const TNumericValue* msg) {
  return *msg->_impl_.vec4i_;
}
const ::TMatrix3x3f&
TNumericValue::_Internal::floatmatrix3(const TNumericValue* msg) {
  return *msg->_impl_.floatmatrix3_;
}
const ::TMatrix4x4f&
TNumericValue::_Internal::floatmatrix4(const TNumericValue* msg) {
  return *msg->_impl_.floatmatrix4_;
}
TNumericValue::TNumericValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TNumericValue)
}
TNumericValue::TNumericValue(const TNumericValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TNumericValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vec2f_){nullptr}
    , decltype(_impl_.vec3f_){nullptr}
    , decltype(_impl_.vec4f_){nullptr}
    , decltype(_impl_.vec2i_){nullptr}
    , decltype(_impl_.vec3i_){nullptr}
    , decltype(_impl_.vec4i_){nullptr}
    , decltype(_impl_.floatmatrix3_){nullptr}
    , decltype(_impl_.floatmatrix4_){nullptr}
    , decltype(_impl_.int__){}
    , decltype(_impl_.uint_){}
    , decltype(_impl_.float__){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_vec2f()) {
    _this->_impl_.vec2f_ = new ::TVector2f(*from._impl_.vec2f_);
  }
  if (from._internal_has_vec3f()) {
    _this->_impl_.vec3f_ = new ::TVector3f(*from._impl_.vec3f_);
  }
  if (from._internal_has_vec4f()) {
    _this->_impl_.vec4f_ = new ::TVector4f(*from._impl_.vec4f_);
  }
  if (from._internal_has_vec2i()) {
    _this->_impl_.vec2i_ = new ::TVector2i(*from._impl_.vec2i_);
  }
  if (from._internal_has_vec3i()) {
    _this->_impl_.vec3i_ = new ::TVector3i(*from._impl_.vec3i_);
  }
  if (from._internal_has_vec4i()) {
    _this->_impl_.vec4i_ = new ::TVector4i(*from._impl_.vec4i_);
  }
  if (from._internal_has_floatmatrix3()) {
    _this->_impl_.floatmatrix3_ = new ::TMatrix3x3f(*from._impl_.floatmatrix3_);
  }
  if (from._internal_has_floatmatrix4()) {
    _this->_impl_.floatmatrix4_ = new ::TMatrix4x4f(*from._impl_.floatmatrix4_);
  }
  ::memcpy(&_impl_.int__, &from._impl_.int__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.float__) -
    reinterpret_cast<char*>(&_impl_.int__)) + sizeof(_impl_.float__));
  // @@protoc_insertion_point(copy_constructor:TNumericValue)
}

inline void TNumericValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.vec2f_){nullptr}
    , decltype(_impl_.vec3f_){nullptr}
    , decltype(_impl_.vec4f_){nullptr}
    , decltype(_impl_.vec2i_){nullptr}
    , decltype(_impl_.vec3i_){nullptr}
    , decltype(_impl_.vec4i_){nullptr}
    , decltype(_impl_.floatmatrix3_){nullptr}
    , decltype(_impl_.floatmatrix4_){nullptr}
    , decltype(_impl_.int__){0}
    , decltype(_impl_.uint_){0u}
    , decltype(_impl_.float__){0}
  };
}

TNumericValue::~TNumericValue() {
  // @@protoc_insertion_point(destructor:TNumericValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TNumericValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.vec2f_;
  if (this != internal_default_instance()) delete _impl_.vec3f_;
  if (this != internal_default_instance()) delete _impl_.vec4f_;
  if (this != internal_default_instance()) delete _impl_.vec2i_;
  if (this != internal_default_instance()) delete _impl_.vec3i_;
  if (this != internal_default_instance()) delete _impl_.vec4i_;
  if (this != internal_default_instance()) delete _impl_.floatmatrix3_;
  if (this != internal_default_instance()) delete _impl_.floatmatrix4_;
}

void TNumericValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TNumericValue::Clear() {
// @@protoc_insertion_point(message_clear_start:TNumericValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.vec2f_ != nullptr);
      _impl_.vec2f_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.vec3f_ != nullptr);
      _impl_.vec3f_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.vec4f_ != nullptr);
      _impl_.vec4f_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.vec2i_ != nullptr);
      _impl_.vec2i_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.vec3i_ != nullptr);
      _impl_.vec3i_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.vec4i_ != nullptr);
      _impl_.vec4i_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.floatmatrix3_ != nullptr);
      _impl_.floatmatrix3_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.floatmatrix4_ != nullptr);
      _impl_.floatmatrix4_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.int__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.float__) -
        reinterpret_cast<char*>(&_impl_.int__)) + sizeof(_impl_.float__));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TNumericValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 Int = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_int_(&has_bits);
          _impl_.int__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 UInt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_uint(&has_bits);
          _impl_.uint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float Float = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_float_(&has_bits);
          _impl_.float__ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector2f Vec2f = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec2f(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3f Vec3f = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec3f(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector4f Vec4f = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec4f(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector2i Vec2i = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec2i(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3i Vec3i = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec3i(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector4i Vec4i = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_vec4i(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TMatrix3x3f FloatMatrix3 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_floatmatrix3(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TMatrix4x4f FloatMatrix4 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_floatmatrix4(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TNumericValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TNumericValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 Int = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_int_(), target);
  }

  // optional uint32 UInt = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_uint(), target);
  }

  // optional float Float = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_float_(), target);
  }

  // optional .TVector2f Vec2f = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::vec2f(this),
        _Internal::vec2f(this).GetCachedSize(), target, stream);
  }

  // optional .TVector3f Vec3f = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::vec3f(this),
        _Internal::vec3f(this).GetCachedSize(), target, stream);
  }

  // optional .TVector4f Vec4f = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::vec4f(this),
        _Internal::vec4f(this).GetCachedSize(), target, stream);
  }

  // optional .TVector2i Vec2i = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::vec2i(this),
        _Internal::vec2i(this).GetCachedSize(), target, stream);
  }

  // optional .TVector3i Vec3i = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::vec3i(this),
        _Internal::vec3i(this).GetCachedSize(), target, stream);
  }

  // optional .TVector4i Vec4i = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::vec4i(this),
        _Internal::vec4i(this).GetCachedSize(), target, stream);
  }

  // optional .TMatrix3x3f FloatMatrix3 = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::floatmatrix3(this),
        _Internal::floatmatrix3(this).GetCachedSize(), target, stream);
  }

  // optional .TMatrix4x4f FloatMatrix4 = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::floatmatrix4(this),
        _Internal::floatmatrix4(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TNumericValue)
  return target;
}

size_t TNumericValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TNumericValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TVector2f Vec2f = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec2f_);
    }

    // optional .TVector3f Vec3f = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec3f_);
    }

    // optional .TVector4f Vec4f = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec4f_);
    }

    // optional .TVector2i Vec2i = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec2i_);
    }

    // optional .TVector3i Vec3i = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec3i_);
    }

    // optional .TVector4i Vec4i = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vec4i_);
    }

    // optional .TMatrix3x3f FloatMatrix3 = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.floatmatrix3_);
    }

    // optional .TMatrix4x4f FloatMatrix4 = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.floatmatrix4_);
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 Int = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_int_());
    }

    // optional uint32 UInt = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uint());
    }

    // optional float Float = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TNumericValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TNumericValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TNumericValue::GetClassData() const { return &_class_data_; }


void TNumericValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TNumericValue*>(&to_msg);
  auto& from = static_cast<const TNumericValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TNumericValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_vec2f()->::TVector2f::MergeFrom(
          from._internal_vec2f());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vec3f()->::TVector3f::MergeFrom(
          from._internal_vec3f());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_vec4f()->::TVector4f::MergeFrom(
          from._internal_vec4f());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_vec2i()->::TVector2i::MergeFrom(
          from._internal_vec2i());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_vec3i()->::TVector3i::MergeFrom(
          from._internal_vec3i());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_vec4i()->::TVector4i::MergeFrom(
          from._internal_vec4i());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_floatmatrix3()->::TMatrix3x3f::MergeFrom(
          from._internal_floatmatrix3());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_floatmatrix4()->::TMatrix4x4f::MergeFrom(
          from._internal_floatmatrix4());
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.int__ = from._impl_.int__;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.uint_ = from._impl_.uint_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.float__ = from._impl_.float__;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TNumericValue::CopyFrom(const TNumericValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TNumericValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TNumericValue::IsInitialized() const {
  if (_internal_has_vec2f()) {
    if (!_impl_.vec2f_->IsInitialized()) return false;
  }
  if (_internal_has_vec3f()) {
    if (!_impl_.vec3f_->IsInitialized()) return false;
  }
  if (_internal_has_vec4f()) {
    if (!_impl_.vec4f_->IsInitialized()) return false;
  }
  if (_internal_has_vec2i()) {
    if (!_impl_.vec2i_->IsInitialized()) return false;
  }
  if (_internal_has_vec3i()) {
    if (!_impl_.vec3i_->IsInitialized()) return false;
  }
  if (_internal_has_vec4i()) {
    if (!_impl_.vec4i_->IsInitialized()) return false;
  }
  return true;
}

void TNumericValue::InternalSwap(TNumericValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TNumericValue, _impl_.float__)
      + sizeof(TNumericValue::_impl_.float__)
      - PROTOBUF_FIELD_OFFSET(TNumericValue, _impl_.vec2f_)>(
          reinterpret_cast<char*>(&_impl_.vec2f_),
          reinterpret_cast<char*>(&other->_impl_.vec2f_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TNumericValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[9]);
}

// ===================================================================

class TMultidimensionalPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TMultidimensionalPoint>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMultidimensionalPoint, _impl_._has_bits_);
  static const ::TNumericValue& value(const TMultidimensionalPoint* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_domain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TNumericValue&
TMultidimensionalPoint::_Internal::value(const TMultidimensionalPoint* msg) {
  return *msg->_impl_.value_;
}
TMultidimensionalPoint::TMultidimensionalPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TMultidimensionalPoint)
}
TMultidimensionalPoint::TMultidimensionalPoint(const TMultidimensionalPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMultidimensionalPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.domain_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::TNumericValue(*from._impl_.value_);
  }
  _this->_impl_.domain_ = from._impl_.domain_;
  // @@protoc_insertion_point(copy_constructor:TMultidimensionalPoint)
}

inline void TMultidimensionalPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.domain_){0}
  };
}

TMultidimensionalPoint::~TMultidimensionalPoint() {
  // @@protoc_insertion_point(destructor:TMultidimensionalPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMultidimensionalPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.value_;
}

void TMultidimensionalPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMultidimensionalPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:TMultidimensionalPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.value_ != nullptr);
    _impl_.value_->Clear();
  }
  _impl_.domain_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMultidimensionalPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TNumericValue value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float domain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_domain(&has_bits);
          _impl_.domain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMultidimensionalPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TMultidimensionalPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TNumericValue value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // required float domain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_domain(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TMultidimensionalPoint)
  return target;
}

size_t TMultidimensionalPoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TMultidimensionalPoint)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required .TNumericValue value = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  if (_internal_has_domain()) {
    // required float domain = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t TMultidimensionalPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TMultidimensionalPoint)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TNumericValue value = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);

    // required float domain = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMultidimensionalPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMultidimensionalPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMultidimensionalPoint::GetClassData() const { return &_class_data_; }


void TMultidimensionalPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMultidimensionalPoint*>(&to_msg);
  auto& from = static_cast<const TMultidimensionalPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TMultidimensionalPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_value()->::TNumericValue::MergeFrom(
          from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.domain_ = from._impl_.domain_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMultidimensionalPoint::CopyFrom(const TMultidimensionalPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TMultidimensionalPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMultidimensionalPoint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_value()) {
    if (!_impl_.value_->IsInitialized()) return false;
  }
  return true;
}

void TMultidimensionalPoint::InternalSwap(TMultidimensionalPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMultidimensionalPoint, _impl_.domain_)
      + sizeof(TMultidimensionalPoint::_impl_.domain_)
      - PROTOBUF_FIELD_OFFSET(TMultidimensionalPoint, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMultidimensionalPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[10]);
}

// ===================================================================

class TCurvePointInterpolation::_Internal {
 public:
  using HasBits = decltype(std::declval<TCurvePointInterpolation>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TCurvePointInterpolation, _impl_._has_bits_);
  static void set_has_interpolation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TMultidimensionalPoint& tangentvector(const TCurvePointInterpolation* msg);
  static void set_has_tangentvector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TMultidimensionalPoint&
TCurvePointInterpolation::_Internal::tangentvector(const TCurvePointInterpolation* msg) {
  return *msg->_impl_.tangentvector_;
}
TCurvePointInterpolation::TCurvePointInterpolation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TCurvePointInterpolation)
}
TCurvePointInterpolation::TCurvePointInterpolation(const TCurvePointInterpolation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TCurvePointInterpolation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tangentvector_){nullptr}
    , decltype(_impl_.interpolation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tangentvector()) {
    _this->_impl_.tangentvector_ = new ::TMultidimensionalPoint(*from._impl_.tangentvector_);
  }
  _this->_impl_.interpolation_ = from._impl_.interpolation_;
  // @@protoc_insertion_point(copy_constructor:TCurvePointInterpolation)
}

inline void TCurvePointInterpolation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tangentvector_){nullptr}
    , decltype(_impl_.interpolation_){0}
  };
}

TCurvePointInterpolation::~TCurvePointInterpolation() {
  // @@protoc_insertion_point(destructor:TCurvePointInterpolation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TCurvePointInterpolation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tangentvector_;
}

void TCurvePointInterpolation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TCurvePointInterpolation::Clear() {
// @@protoc_insertion_point(message_clear_start:TCurvePointInterpolation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tangentvector_ != nullptr);
    _impl_.tangentvector_->Clear();
  }
  _impl_.interpolation_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TCurvePointInterpolation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TCurvePointInterpolationType interpolation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TCurvePointInterpolationType_IsValid(val))) {
            _internal_set_interpolation(static_cast<::TCurvePointInterpolationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TMultidimensionalPoint tangentVector = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tangentvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TCurvePointInterpolation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TCurvePointInterpolation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TCurvePointInterpolationType interpolation = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_interpolation(), target);
  }

  // optional .TMultidimensionalPoint tangentVector = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tangentvector(this),
        _Internal::tangentvector(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TCurvePointInterpolation)
  return target;
}

size_t TCurvePointInterpolation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TCurvePointInterpolation)
  size_t total_size = 0;

  // required .TCurvePointInterpolationType interpolation = 1;
  if (_internal_has_interpolation()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_interpolation());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TMultidimensionalPoint tangentVector = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tangentvector_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TCurvePointInterpolation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TCurvePointInterpolation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TCurvePointInterpolation::GetClassData() const { return &_class_data_; }


void TCurvePointInterpolation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TCurvePointInterpolation*>(&to_msg);
  auto& from = static_cast<const TCurvePointInterpolation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TCurvePointInterpolation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tangentvector()->::TMultidimensionalPoint::MergeFrom(
          from._internal_tangentvector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.interpolation_ = from._impl_.interpolation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TCurvePointInterpolation::CopyFrom(const TCurvePointInterpolation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TCurvePointInterpolation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCurvePointInterpolation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_tangentvector()) {
    if (!_impl_.tangentvector_->IsInitialized()) return false;
  }
  return true;
}

void TCurvePointInterpolation::InternalSwap(TCurvePointInterpolation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TCurvePointInterpolation, _impl_.interpolation_)
      + sizeof(TCurvePointInterpolation::_impl_.interpolation_)
      - PROTOBUF_FIELD_OFFSET(TCurvePointInterpolation, _impl_.tangentvector_)>(
          reinterpret_cast<char*>(&_impl_.tangentvector_),
          reinterpret_cast<char*>(&other->_impl_.tangentvector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TCurvePointInterpolation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[11]);
}

// ===================================================================

class TCurvePoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TCurvePoint>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TCurvePoint, _impl_._has_bits_);
  static const ::TMultidimensionalPoint& point(const TCurvePoint* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TCurvePointInterpolation& incomminginterpolation(const TCurvePoint* msg);
  static void set_has_incomminginterpolation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TCurvePointInterpolation& outgoinginterpolation(const TCurvePoint* msg);
  static void set_has_outgoinginterpolation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TMultidimensionalPoint&
TCurvePoint::_Internal::point(const TCurvePoint* msg) {
  return *msg->_impl_.point_;
}
const ::TCurvePointInterpolation&
TCurvePoint::_Internal::incomminginterpolation(const TCurvePoint* msg) {
  return *msg->_impl_.incomminginterpolation_;
}
const ::TCurvePointInterpolation&
TCurvePoint::_Internal::outgoinginterpolation(const TCurvePoint* msg) {
  return *msg->_impl_.outgoinginterpolation_;
}
TCurvePoint::TCurvePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TCurvePoint)
}
TCurvePoint::TCurvePoint(const TCurvePoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TCurvePoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.incomminginterpolation_){nullptr}
    , decltype(_impl_.outgoinginterpolation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    _this->_impl_.point_ = new ::TMultidimensionalPoint(*from._impl_.point_);
  }
  if (from._internal_has_incomminginterpolation()) {
    _this->_impl_.incomminginterpolation_ = new ::TCurvePointInterpolation(*from._impl_.incomminginterpolation_);
  }
  if (from._internal_has_outgoinginterpolation()) {
    _this->_impl_.outgoinginterpolation_ = new ::TCurvePointInterpolation(*from._impl_.outgoinginterpolation_);
  }
  // @@protoc_insertion_point(copy_constructor:TCurvePoint)
}

inline void TCurvePoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.incomminginterpolation_){nullptr}
    , decltype(_impl_.outgoinginterpolation_){nullptr}
  };
}

TCurvePoint::~TCurvePoint() {
  // @@protoc_insertion_point(destructor:TCurvePoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TCurvePoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.incomminginterpolation_;
  if (this != internal_default_instance()) delete _impl_.outgoinginterpolation_;
}

void TCurvePoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TCurvePoint::Clear() {
// @@protoc_insertion_point(message_clear_start:TCurvePoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.incomminginterpolation_ != nullptr);
      _impl_.incomminginterpolation_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.outgoinginterpolation_ != nullptr);
      _impl_.outgoinginterpolation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TCurvePoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TMultidimensionalPoint point = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TCurvePointInterpolation incommingInterpolation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_incomminginterpolation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TCurvePointInterpolation outgoingInterpolation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_outgoinginterpolation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TCurvePoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TCurvePoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TMultidimensionalPoint point = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .TCurvePointInterpolation incommingInterpolation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::incomminginterpolation(this),
        _Internal::incomminginterpolation(this).GetCachedSize(), target, stream);
  }

  // optional .TCurvePointInterpolation outgoingInterpolation = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::outgoinginterpolation(this),
        _Internal::outgoinginterpolation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TCurvePoint)
  return target;
}

size_t TCurvePoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TCurvePoint)
  size_t total_size = 0;

  // required .TMultidimensionalPoint point = 1;
  if (_internal_has_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.point_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TCurvePointInterpolation incommingInterpolation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.incomminginterpolation_);
    }

    // optional .TCurvePointInterpolation outgoingInterpolation = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.outgoinginterpolation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TCurvePoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TCurvePoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TCurvePoint::GetClassData() const { return &_class_data_; }


void TCurvePoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TCurvePoint*>(&to_msg);
  auto& from = static_cast<const TCurvePoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TCurvePoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::TMultidimensionalPoint::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_incomminginterpolation()->::TCurvePointInterpolation::MergeFrom(
          from._internal_incomminginterpolation());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_outgoinginterpolation()->::TCurvePointInterpolation::MergeFrom(
          from._internal_outgoinginterpolation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TCurvePoint::CopyFrom(const TCurvePoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TCurvePoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCurvePoint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_point()) {
    if (!_impl_.point_->IsInitialized()) return false;
  }
  if (_internal_has_incomminginterpolation()) {
    if (!_impl_.incomminginterpolation_->IsInitialized()) return false;
  }
  if (_internal_has_outgoinginterpolation()) {
    if (!_impl_.outgoinginterpolation_->IsInitialized()) return false;
  }
  return true;
}

void TCurvePoint::InternalSwap(TCurvePoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TCurvePoint, _impl_.outgoinginterpolation_)
      + sizeof(TCurvePoint::_impl_.outgoinginterpolation_)
      - PROTOBUF_FIELD_OFFSET(TCurvePoint, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TCurvePoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[12]);
}

// ===================================================================

class TCurveDefinition::_Internal {
 public:
  using HasBits = decltype(std::declval<TCurveDefinition>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TCurveDefinition, _impl_._has_bits_);
  static void set_has_curvevaluetype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TCurveDefinition::TCurveDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TCurveDefinition)
}
TCurveDefinition::TCurveDefinition(const TCurveDefinition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TCurveDefinition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){from._impl_.point_}
    , decltype(_impl_.curvevaluetype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.curvevaluetype_ = from._impl_.curvevaluetype_;
  // @@protoc_insertion_point(copy_constructor:TCurveDefinition)
}

inline void TCurveDefinition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){arena}
    , decltype(_impl_.curvevaluetype_){1}
  };
}

TCurveDefinition::~TCurveDefinition() {
  // @@protoc_insertion_point(destructor:TCurveDefinition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TCurveDefinition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.point_.~RepeatedPtrField();
}

void TCurveDefinition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TCurveDefinition::Clear() {
// @@protoc_insertion_point(message_clear_start:TCurveDefinition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.point_.Clear();
  _impl_.curvevaluetype_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TCurveDefinition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TENumericType curveValueType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TENumericType_IsValid(val))) {
            _internal_set_curvevaluetype(static_cast<::TENumericType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TCurvePoint point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_point(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TCurveDefinition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TCurveDefinition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TENumericType curveValueType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_curvevaluetype(), target);
  }

  // repeated .TCurvePoint point = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_point_size()); i < n; i++) {
    const auto& repfield = this->_internal_point(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TCurveDefinition)
  return target;
}

size_t TCurveDefinition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TCurveDefinition)
  size_t total_size = 0;

  // required .TENumericType curveValueType = 1;
  if (_internal_has_curvevaluetype()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_curvevaluetype());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TCurvePoint point = 2;
  total_size += 1UL * this->_internal_point_size();
  for (const auto& msg : this->_impl_.point_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TCurveDefinition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TCurveDefinition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TCurveDefinition::GetClassData() const { return &_class_data_; }


void TCurveDefinition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TCurveDefinition*>(&to_msg);
  auto& from = static_cast<const TCurveDefinition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TCurveDefinition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.point_.MergeFrom(from._impl_.point_);
  if (from._internal_has_curvevaluetype()) {
    _this->_internal_set_curvevaluetype(from._internal_curvevaluetype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TCurveDefinition::CopyFrom(const TCurveDefinition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TCurveDefinition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCurveDefinition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.point_))
    return false;
  return true;
}

void TCurveDefinition::InternalSwap(TCurveDefinition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.point_.InternalSwap(&other->_impl_.point_);
  swap(_impl_.curvevaluetype_, other->_impl_.curvevaluetype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TCurveDefinition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[13]);
}

// ===================================================================

class TKeyFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<TKeyFrame>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TKeyFrame, _impl_._has_bits_);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TNumericValue& value(const TKeyFrame* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TNumericValue&
TKeyFrame::_Internal::value(const TKeyFrame* msg) {
  return *msg->_impl_.value_;
}
TKeyFrame::TKeyFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TKeyFrame)
}
TKeyFrame::TKeyFrame(const TKeyFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TKeyFrame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.frame_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::TNumericValue(*from._impl_.value_);
  }
  _this->_impl_.frame_ = from._impl_.frame_;
  // @@protoc_insertion_point(copy_constructor:TKeyFrame)
}

inline void TKeyFrame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.frame_){0}
  };
}

TKeyFrame::~TKeyFrame() {
  // @@protoc_insertion_point(destructor:TKeyFrame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TKeyFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.value_;
}

void TKeyFrame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TKeyFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:TKeyFrame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.value_ != nullptr);
    _impl_.value_->Clear();
  }
  _impl_.frame_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TKeyFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_frame(&has_bits);
          _impl_.frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TNumericValue value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TKeyFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TKeyFrame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 frame = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_frame(), target);
  }

  // optional .TNumericValue value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TKeyFrame)
  return target;
}

size_t TKeyFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TKeyFrame)
  size_t total_size = 0;

  // required int32 frame = 1;
  if (_internal_has_frame()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TNumericValue value = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TKeyFrame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TKeyFrame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TKeyFrame::GetClassData() const { return &_class_data_; }


void TKeyFrame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TKeyFrame*>(&to_msg);
  auto& from = static_cast<const TKeyFrame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TKeyFrame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_value()->::TNumericValue::MergeFrom(
          from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.frame_ = from._impl_.frame_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TKeyFrame::CopyFrom(const TKeyFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TKeyFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TKeyFrame::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_value()) {
    if (!_impl_.value_->IsInitialized()) return false;
  }
  return true;
}

void TKeyFrame::InternalSwap(TKeyFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TKeyFrame, _impl_.frame_)
      + sizeof(TKeyFrame::_impl_.frame_)
      - PROTOBUF_FIELD_OFFSET(TKeyFrame, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TKeyFrame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[14]);
}

// ===================================================================

class TKeyFrameSequence::_Internal {
 public:
  using HasBits = decltype(std::declval<TKeyFrameSequence>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TKeyFrameSequence, _impl_._has_bits_);
  static void set_has_fps(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

TKeyFrameSequence::TKeyFrameSequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TKeyFrameSequence)
}
TKeyFrameSequence::TKeyFrameSequence(const TKeyFrameSequence& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TKeyFrameSequence* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keyframe_){from._impl_.keyframe_}
    , decltype(_impl_.fps_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.fps_, &from._impl_.fps_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.fps_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:TKeyFrameSequence)
}

inline void TKeyFrameSequence::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keyframe_){arena}
    , decltype(_impl_.fps_){0}
    , decltype(_impl_.type_){1}
  };
}

TKeyFrameSequence::~TKeyFrameSequence() {
  // @@protoc_insertion_point(destructor:TKeyFrameSequence)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TKeyFrameSequence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keyframe_.~RepeatedPtrField();
}

void TKeyFrameSequence::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TKeyFrameSequence::Clear() {
// @@protoc_insertion_point(message_clear_start:TKeyFrameSequence)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keyframe_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.fps_ = 0;
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TKeyFrameSequence::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float fps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_fps(&has_bits);
          _impl_.fps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .TKeyFrame keyFrame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keyframe(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .TENumericType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TENumericType_IsValid(val))) {
            _internal_set_type(static_cast<::TENumericType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TKeyFrameSequence::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TKeyFrameSequence)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float fps = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_fps(), target);
  }

  // repeated .TKeyFrame keyFrame = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keyframe_size()); i < n; i++) {
    const auto& repfield = this->_internal_keyframe(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .TENumericType type = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TKeyFrameSequence)
  return target;
}

size_t TKeyFrameSequence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TKeyFrameSequence)
  size_t total_size = 0;

  // required .TENumericType type = 3;
  if (_internal_has_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TKeyFrame keyFrame = 2;
  total_size += 1UL * this->_internal_keyframe_size();
  for (const auto& msg : this->_impl_.keyframe_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional float fps = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TKeyFrameSequence::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TKeyFrameSequence::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TKeyFrameSequence::GetClassData() const { return &_class_data_; }


void TKeyFrameSequence::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TKeyFrameSequence*>(&to_msg);
  auto& from = static_cast<const TKeyFrameSequence&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TKeyFrameSequence)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keyframe_.MergeFrom(from._impl_.keyframe_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.fps_ = from._impl_.fps_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TKeyFrameSequence::CopyFrom(const TKeyFrameSequence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TKeyFrameSequence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TKeyFrameSequence::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.keyframe_))
    return false;
  return true;
}

void TKeyFrameSequence::InternalSwap(TKeyFrameSequence* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.keyframe_.InternalSwap(&other->_impl_.keyframe_);
  swap(_impl_.fps_, other->_impl_.fps_);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TKeyFrameSequence::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Numeric_2eproto_getter, &descriptor_table_Numeric_2eproto_once,
      file_level_metadata_Numeric_2eproto[15]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TVector2i*
Arena::CreateMaybeMessage< ::TVector2i >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector2i >(arena);
}
template<> PROTOBUF_NOINLINE ::TVector3i*
Arena::CreateMaybeMessage< ::TVector3i >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector3i >(arena);
}
template<> PROTOBUF_NOINLINE ::TVector4i*
Arena::CreateMaybeMessage< ::TVector4i >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector4i >(arena);
}
template<> PROTOBUF_NOINLINE ::TVector2f*
Arena::CreateMaybeMessage< ::TVector2f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector2f >(arena);
}
template<> PROTOBUF_NOINLINE ::TVector3f*
Arena::CreateMaybeMessage< ::TVector3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector3f >(arena);
}
template<> PROTOBUF_NOINLINE ::TVector4f*
Arena::CreateMaybeMessage< ::TVector4f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TVector4f >(arena);
}
template<> PROTOBUF_NOINLINE ::TMatrix3x3f*
Arena::CreateMaybeMessage< ::TMatrix3x3f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TMatrix3x3f >(arena);
}
template<> PROTOBUF_NOINLINE ::TMatrix4x4f*
Arena::CreateMaybeMessage< ::TMatrix4x4f >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TMatrix4x4f >(arena);
}
template<> PROTOBUF_NOINLINE ::TAxisAlignedBoundingBox*
Arena::CreateMaybeMessage< ::TAxisAlignedBoundingBox >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TAxisAlignedBoundingBox >(arena);
}
template<> PROTOBUF_NOINLINE ::TNumericValue*
Arena::CreateMaybeMessage< ::TNumericValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TNumericValue >(arena);
}
template<> PROTOBUF_NOINLINE ::TMultidimensionalPoint*
Arena::CreateMaybeMessage< ::TMultidimensionalPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TMultidimensionalPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::TCurvePointInterpolation*
Arena::CreateMaybeMessage< ::TCurvePointInterpolation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TCurvePointInterpolation >(arena);
}
template<> PROTOBUF_NOINLINE ::TCurvePoint*
Arena::CreateMaybeMessage< ::TCurvePoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TCurvePoint >(arena);
}
template<> PROTOBUF_NOINLINE ::TCurveDefinition*
Arena::CreateMaybeMessage< ::TCurveDefinition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TCurveDefinition >(arena);
}
template<> PROTOBUF_NOINLINE ::TKeyFrame*
Arena::CreateMaybeMessage< ::TKeyFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TKeyFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::TKeyFrameSequence*
Arena::CreateMaybeMessage< ::TKeyFrameSequence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TKeyFrameSequence >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
