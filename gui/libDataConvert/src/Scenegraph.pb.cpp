// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Scenegraph.proto

#include "proto/Scenegraph.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace HmiScenegraph {
PROTOBUF_CONSTEXPR TResourceCacheId::TResourceCacheId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.low_)*/uint64_t{0u}
  , /*decltype(_impl_.high_)*/uint64_t{0u}} {}
struct TResourceCacheIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TResourceCacheIdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TResourceCacheIdDefaultTypeInternal() {}
  union {
    TResourceCacheId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TResourceCacheIdDefaultTypeInternal _TResourceCacheId_default_instance_;
PROTOBUF_CONSTEXPR TUniform::TUniform(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.type_)*/1} {}
struct TUniformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TUniformDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TUniformDefaultTypeInternal() {}
  union {
    TUniform _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TUniformDefaultTypeInternal _TUniform_default_instance_;
PROTOBUF_CONSTEXPR TCamera::TCamera(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.projectionmatrix_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.translation_)*/nullptr
  , /*decltype(_impl_.viewport_)*/nullptr
  , /*decltype(_impl_.horizontalfov_)*/0
  , /*decltype(_impl_.aspectratio_)*/0
  , /*decltype(_impl_.nearplane_)*/0
  , /*decltype(_impl_.farplane_)*/0
  , /*decltype(_impl_.rightplane_)*/0
  , /*decltype(_impl_.leftplane_)*/0
  , /*decltype(_impl_.topplane_)*/0
  , /*decltype(_impl_.bottomplane_)*/0
  , /*decltype(_impl_.projectiontype_)*/0
  , /*decltype(_impl_.horizontalfocallength_)*/0
  , /*decltype(_impl_.scope_)*/3} {}
struct TCameraDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TCameraDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TCameraDefaultTypeInternal() {}
  union {
    TCamera _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TCameraDefaultTypeInternal _TCamera_default_instance_;
PROTOBUF_CONSTEXPR TBlendMode::TBlendMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blendoperationcolor_)*/1
  , /*decltype(_impl_.blendoperationalpha_)*/1
  , /*decltype(_impl_.sourcecolorfactor_)*/1
  , /*decltype(_impl_.sourcealphafactor_)*/1
  , /*decltype(_impl_.destinationcolorfactor_)*/1
  , /*decltype(_impl_.destinationalphafactor_)*/1} {}
struct TBlendModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBlendModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBlendModeDefaultTypeInternal() {}
  union {
    TBlendMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBlendModeDefaultTypeInternal _TBlendMode_default_instance_;
PROTOBUF_CONSTEXPR TStencilMode::TStencilMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.referencevalue_)*/0
  , /*decltype(_impl_.mask_)*/0u
  , /*decltype(_impl_.operation_)*/1
  , /*decltype(_impl_.stencilfail_)*/1
  , /*decltype(_impl_.depthfail_)*/1
  , /*decltype(_impl_.pass_)*/1} {}
struct TStencilModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TStencilModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TStencilModeDefaultTypeInternal() {}
  union {
    TStencilMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TStencilModeDefaultTypeInternal _TStencilMode_default_instance_;
PROTOBUF_CONSTEXPR TScissorTest::TScissorTest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.width_)*/0} {}
struct TScissorTestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TScissorTestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TScissorTestDefaultTypeInternal() {}
  union {
    TScissorTest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TScissorTestDefaultTypeInternal _TScissorTest_default_instance_;
PROTOBUF_CONSTEXPR TRenderMode_TColorWrite::TRenderMode_TColorWrite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.red_)*/true
  , /*decltype(_impl_.green_)*/true
  , /*decltype(_impl_.blue_)*/true
  , /*decltype(_impl_.alpha_)*/true} {}
struct TRenderMode_TColorWriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderMode_TColorWriteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderMode_TColorWriteDefaultTypeInternal() {}
  union {
    TRenderMode_TColorWrite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderMode_TColorWriteDefaultTypeInternal _TRenderMode_TColorWrite_default_instance_;
PROTOBUF_CONSTEXPR TRenderMode::TRenderMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blending_)*/nullptr
  , /*decltype(_impl_.stencilfrontface_)*/nullptr
  , /*decltype(_impl_.stencilbackface_)*/nullptr
  , /*decltype(_impl_.scissortest_)*/nullptr
  , /*decltype(_impl_.colorwrite_)*/nullptr
  , /*decltype(_impl_.blendcolor_)*/0u
  , /*decltype(_impl_.depthwrite_)*/false
  , /*decltype(_impl_.depthcompare_)*/1
  , /*decltype(_impl_.winding_)*/1
  , /*decltype(_impl_.culling_)*/1} {}
struct TRenderModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderModeDefaultTypeInternal() {}
  union {
    TRenderMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderModeDefaultTypeInternal _TRenderMode_default_instance_;
PROTOBUF_CONSTEXPR TAttributeMapping::TAttributeMapping(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attributename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.usage_)*/0
  , /*decltype(_impl_.index_)*/0u} {}
struct TAttributeMappingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TAttributeMappingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TAttributeMappingDefaultTypeInternal() {}
  union {
    TAttributeMapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TAttributeMappingDefaultTypeInternal _TAttributeMapping_default_instance_;
PROTOBUF_CONSTEXPR TShader::TShader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mapping_)*/{}
  , /*decltype(_impl_.compilerdefine_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vertexshader_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fragmentshader_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cacheid_)*/nullptr
  , /*decltype(_impl_.scope_)*/1} {}
struct TShaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TShaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TShaderDefaultTypeInternal() {}
  union {
    TShader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TShaderDefaultTypeInternal _TShader_default_instance_;
PROTOBUF_CONSTEXPR TBitmap_TCubeMapResource::TBitmap_TCubeMapResource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mipmap_)*/{}
  , /*decltype(_impl_.resource_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct TBitmap_TCubeMapResourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBitmap_TCubeMapResourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBitmap_TCubeMapResourceDefaultTypeInternal() {}
  union {
    TBitmap_TCubeMapResource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBitmap_TCubeMapResourceDefaultTypeInternal _TBitmap_TCubeMapResource_default_instance_;
PROTOBUF_CONSTEXPR TBitmap_TCubeMap::TBitmap_TCubeMap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.combined_)*/nullptr
  , /*decltype(_impl_.positive_x_)*/nullptr
  , /*decltype(_impl_.negative_x_)*/nullptr
  , /*decltype(_impl_.positive_y_)*/nullptr
  , /*decltype(_impl_.negative_y_)*/nullptr
  , /*decltype(_impl_.positive_z_)*/nullptr
  , /*decltype(_impl_.negative_z_)*/nullptr} {}
struct TBitmap_TCubeMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBitmap_TCubeMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBitmap_TCubeMapDefaultTypeInternal() {}
  union {
    TBitmap_TCubeMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBitmap_TCubeMapDefaultTypeInternal _TBitmap_TCubeMap_default_instance_;
PROTOBUF_CONSTEXPR TBitmap::TBitmap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mipmap_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resource_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cubemap_)*/nullptr
  , /*decltype(_impl_.cacheid_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.depth_)*/0u
  , /*decltype(_impl_.samples_)*/0u
  , /*decltype(_impl_.pixelformat_)*/0
  , /*decltype(_impl_.generatemipmaps_)*/false
  , /*decltype(_impl_.semanticwidth_)*/0
  , /*decltype(_impl_.semanticheight_)*/0
  , /*decltype(_impl_.semanticdepth_)*/0
  , /*decltype(_impl_.resolutionmultiplier_)*/0
  , /*decltype(_impl_.renderbufferaccessmode_)*/0
  , /*decltype(_impl_.scope_)*/1} {}
struct TBitmapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBitmapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBitmapDefaultTypeInternal() {}
  union {
    TBitmap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBitmapDefaultTypeInternal _TBitmap_default_instance_;
PROTOBUF_CONSTEXPR TTexture::TTexture(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bitmapreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uniformname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.anisotropicsamples_)*/0
  , /*decltype(_impl_.minfilter_)*/1
  , /*decltype(_impl_.magfilter_)*/1
  , /*decltype(_impl_.wrapmodeu_)*/1
  , /*decltype(_impl_.wrapmodev_)*/1} {}
struct TTextureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TTextureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TTextureDefaultTypeInternal() {}
  union {
    TTexture _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TTextureDefaultTypeInternal _TTexture_default_instance_;
PROTOBUF_CONSTEXPR TMaterial::TMaterial(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.texture_)*/{}
  , /*decltype(_impl_.uniform_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.shaderreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rendermode_)*/nullptr
  , /*decltype(_impl_.scope_)*/1} {}
struct TMaterialDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMaterialDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMaterialDefaultTypeInternal() {}
  union {
    TMaterial _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMaterialDefaultTypeInternal _TMaterial_default_instance_;
PROTOBUF_CONSTEXPR TMesh_TAttributeParamteter::TMesh_TAttributeParamteter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.precision_)*/0
  , /*decltype(_impl_.size_)*/1} {}
struct TMesh_TAttributeParamteterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMesh_TAttributeParamteterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMesh_TAttributeParamteterDefaultTypeInternal() {}
  union {
    TMesh_TAttributeParamteter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMesh_TAttributeParamteterDefaultTypeInternal _TMesh_TAttributeParamteter_default_instance_;
PROTOBUF_CONSTEXPR TMesh::TMesh(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uniform_)*/{}
  , /*decltype(_impl_.attributeparameter_)*/{}
  , /*decltype(_impl_.renderpassdependency_)*/{}
  , /*decltype(_impl_.texture_)*/{}
  , /*decltype(_impl_.meshresource_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.materialreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.meshreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.basenode_)*/nullptr} {}
struct TMeshDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMeshDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMeshDefaultTypeInternal() {}
  union {
    TMesh _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMeshDefaultTypeInternal _TMesh_default_instance_;
PROTOBUF_CONSTEXPR TRenderLayer::TRenderLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uniform_)*/{}
  , /*decltype(_impl_.child_)*/{}
  , /*decltype(_impl_.materialreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.boundingboxrootname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.basenode_)*/nullptr
  , /*decltype(_impl_.renderpass_)*/nullptr
  , /*decltype(_impl_.rendertargetscale_)*/0
  , /*decltype(_impl_.bordersize_)*/0} {}
struct TRenderLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderLayerDefaultTypeInternal() {}
  union {
    TRenderLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderLayerDefaultTypeInternal _TRenderLayer_default_instance_;
PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingBox::TBoundingVolume_TBoundingBox(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minbound_)*/nullptr
  , /*decltype(_impl_.maxbound_)*/nullptr} {}
struct TBoundingVolume_TBoundingBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingBoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBoundingVolume_TBoundingBoxDefaultTypeInternal() {}
  union {
    TBoundingVolume_TBoundingBox _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBoundingVolume_TBoundingBoxDefaultTypeInternal _TBoundingVolume_TBoundingBox_default_instance_;
PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingSphere::TBoundingVolume_TBoundingSphere(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.centerposition_)*/nullptr
  , /*decltype(_impl_.radius_)*/0} {}
struct TBoundingVolume_TBoundingSphereDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBoundingVolume_TBoundingSphereDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBoundingVolume_TBoundingSphereDefaultTypeInternal() {}
  union {
    TBoundingVolume_TBoundingSphere _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBoundingVolume_TBoundingSphereDefaultTypeInternal _TBoundingVolume_TBoundingSphere_default_instance_;
PROTOBUF_CONSTEXPR TBoundingVolume::TBoundingVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.boundingbox_)*/nullptr
  , /*decltype(_impl_.boundingsphere_)*/nullptr} {}
struct TBoundingVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBoundingVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBoundingVolumeDefaultTypeInternal() {}
  union {
    TBoundingVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBoundingVolumeDefaultTypeInternal _TBoundingVolume_default_instance_;
PROTOBUF_CONSTEXPR TNode_TRenderPassName::TNode_TRenderPassName(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.enabled_)*/false} {}
struct TNode_TRenderPassNameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TNode_TRenderPassNameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TNode_TRenderPassNameDefaultTypeInternal() {}
  union {
    TNode_TRenderPassName _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TNode_TRenderPassNameDefaultTypeInternal _TNode_TRenderPassName_default_instance_;
PROTOBUF_CONSTEXPR TNode::TNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.child_)*/{}
  , /*decltype(_impl_.mesh_)*/{}
  , /*decltype(_impl_.renderlayer_)*/{}
  , /*decltype(_impl_.renderpassnameext_)*/{}
  , /*decltype(_impl_.renderpass_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lookattargetname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.renderpassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.scale_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.translation_)*/nullptr
  , /*decltype(_impl_.transformation_)*/nullptr
  , /*decltype(_impl_.camera_)*/nullptr
  , /*decltype(_impl_.lookatupvector_)*/nullptr
  , /*decltype(_impl_.renderorderbin_)*/nullptr
  , /*decltype(_impl_.boundingvolume_)*/nullptr
  , /*decltype(_impl_.renderorder_)*/0
  , /*decltype(_impl_.childsortorderrank_)*/0
  , /*decltype(_impl_.lookatupaxis_)*/0
  , /*decltype(_impl_.lookatforwardaxis_)*/0
  , /*decltype(_impl_.lookataligntotargetaxis_)*/0
  , /*decltype(_impl_.renderpassenabled_)*/false} {}
struct TNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TNodeDefaultTypeInternal() {}
  union {
    TNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TNodeDefaultTypeInternal _TNode_default_instance_;
PROTOBUF_CONSTEXPR TRenderOrder::TRenderOrder(
    ::_pbi::ConstantInitialized) {}
struct TRenderOrderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderOrderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderOrderDefaultTypeInternal() {}
  union {
    TRenderOrder _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderOrderDefaultTypeInternal _TRenderOrder_default_instance_;
PROTOBUF_CONSTEXPR TRenderOrderBin::TRenderOrderBin(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/nullptr
  , /*decltype(_impl_.renderorderrank_)*/0
  , /*decltype(_impl_.sortorder_)*/0} {}
struct TRenderOrderBinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderOrderBinDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderOrderBinDefaultTypeInternal() {}
  union {
    TRenderOrderBin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderOrderBinDefaultTypeInternal _TRenderOrderBin_default_instance_;
PROTOBUF_CONSTEXPR TRenderTarget::TRenderTarget(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.colorbuffer_)*/{}
  , /*decltype(_impl_.depthbuffer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stencilbuffer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.discardframebuffer_)*/nullptr
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.samples_)*/0
  , /*decltype(_impl_.semanticwidth_)*/0
  , /*decltype(_impl_.semanticheight_)*/0
  , /*decltype(_impl_.semanticdepth_)*/0
  , /*decltype(_impl_.resolutionmultiplier_)*/0
  , /*decltype(_impl_.scope_)*/1} {}
struct TRenderTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderTargetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderTargetDefaultTypeInternal() {}
  union {
    TRenderTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderTargetDefaultTypeInternal _TRenderTarget_default_instance_;
PROTOBUF_CONSTEXPR TClearMode::TClearMode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.clearcolor_)*/0u
  , /*decltype(_impl_.cleardepth_)*/0
  , /*decltype(_impl_.clearstencil_)*/0u} {}
struct TClearModeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TClearModeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TClearModeDefaultTypeInternal() {}
  union {
    TClearMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TClearModeDefaultTypeInternal _TClearMode_default_instance_;
PROTOBUF_CONSTEXPR TDiscardFramebuffer::TDiscardFramebuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/false
  , /*decltype(_impl_.depth_)*/false
  , /*decltype(_impl_.stencil_)*/false} {}
struct TDiscardFramebufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TDiscardFramebufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TDiscardFramebufferDefaultTypeInternal() {}
  union {
    TDiscardFramebuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TDiscardFramebufferDefaultTypeInternal _TDiscardFramebuffer_default_instance_;
PROTOBUF_CONSTEXPR TRenderPass::TRenderPass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.renderorderbin_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cameraname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rendertargetreference_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.renderorder_)*/nullptr
  , /*decltype(_impl_.rendertarget_)*/nullptr
  , /*decltype(_impl_.clearmode_)*/nullptr
  , /*decltype(_impl_.viewport_)*/nullptr
  , /*decltype(_impl_.rank_)*/0u
  , /*decltype(_impl_.viewfrustumcullingenabled_)*/false
  , /*decltype(_impl_.scopemask_)*/0u
  , /*decltype(_impl_.scope_)*/1} {}
struct TRenderPassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TRenderPassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TRenderPassDefaultTypeInternal() {}
  union {
    TRenderPass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TRenderPassDefaultTypeInternal _TRenderPass_default_instance_;
PROTOBUF_CONSTEXPR TBlitPass::TBlitPass(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourcerenderbuffer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.destinationrenderbuffer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rank_)*/0u
  , /*decltype(_impl_.regionwidth_)*/0u
  , /*decltype(_impl_.regionheight_)*/0u
  , /*decltype(_impl_.regionsourcex_)*/0u
  , /*decltype(_impl_.regionsourcey_)*/0u
  , /*decltype(_impl_.regiondestinationx_)*/0u
  , /*decltype(_impl_.regiondestinationy_)*/0u} {}
struct TBlitPassDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TBlitPassDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TBlitPassDefaultTypeInternal() {}
  union {
    TBlitPass _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TBlitPassDefaultTypeInternal _TBlitPass_default_instance_;
PROTOBUF_CONSTEXPR TGeometry_TAttributeParamteter::TGeometry_TAttributeParamteter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cacheid_)*/nullptr
  , /*decltype(_impl_.precision_)*/0
  , /*decltype(_impl_.usageindex_)*/0u
  , /*decltype(_impl_.size_)*/1
  , /*decltype(_impl_.semantic_)*/1} {}
struct TGeometry_TAttributeParamteterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TGeometry_TAttributeParamteterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TGeometry_TAttributeParamteterDefaultTypeInternal() {}
  union {
    TGeometry_TAttributeParamteter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TGeometry_TAttributeParamteterDefaultTypeInternal _TGeometry_TAttributeParamteter_default_instance_;
PROTOBUF_CONSTEXPR TGeometry::TGeometry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attributeparameter_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.resource_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.indexdatacacheid_)*/nullptr
  , /*decltype(_impl_.vertexcount_)*/0u
  , /*decltype(_impl_.primitivecount_)*/0u
  , /*decltype(_impl_.primitivetype_)*/4} {}
struct TGeometryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TGeometryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TGeometryDefaultTypeInternal() {}
  union {
    TGeometry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TGeometryDefaultTypeInternal _TGeometry_default_instance_;
PROTOBUF_CONSTEXPR TMaterialLib::TMaterialLib(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.material_)*/{}
  , /*decltype(_impl_.shader_)*/{}
  , /*decltype(_impl_.bitmap_)*/{}
  , /*decltype(_impl_.geometry_)*/{}
  , /*decltype(_impl_.rendertarget_)*/{}
  , /*decltype(_impl_.renderpass_)*/{}
  , /*decltype(_impl_.resourcecache_)*/{}
  , /*decltype(_impl_.blitpass_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TMaterialLibDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TMaterialLibDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TMaterialLibDefaultTypeInternal() {}
  union {
    TMaterialLib _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TMaterialLibDefaultTypeInternal _TMaterialLib_default_instance_;
PROTOBUF_CONSTEXPR TScene::TScene(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.renderpass_)*/{}
  , /*decltype(_impl_.root_)*/nullptr
  , /*decltype(_impl_.materiallibrary_)*/nullptr} {}
struct TSceneDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TSceneDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TSceneDefaultTypeInternal() {}
  union {
    TScene _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TSceneDefaultTypeInternal _TScene_default_instance_;
}  // namespace HmiScenegraph
static ::_pb::Metadata file_level_metadata_Scenegraph_2eproto[34];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Scenegraph_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Scenegraph_2eproto = nullptr;

const uint32_t TableStruct_Scenegraph_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TResourceCacheId, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TResourceCacheId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TResourceCacheId, _impl_.low_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TResourceCacheId, _impl_.high_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TUniform, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TUniform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TUniform, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TUniform, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TUniform, _impl_.type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.projectiontype_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.projectionmatrix_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.translation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.horizontalfov_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.aspectratio_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.horizontalfocallength_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.viewport_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.nearplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.farplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.rightplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.leftplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.topplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.bottomplane_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TCamera, _impl_.scope_),
  12,
  0,
  1,
  2,
  4,
  5,
  13,
  3,
  6,
  7,
  8,
  9,
  10,
  11,
  14,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.blendoperationcolor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.blendoperationalpha_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.sourcecolorfactor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.sourcealphafactor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.destinationcolorfactor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlendMode, _impl_.destinationalphafactor_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.operation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.referencevalue_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.stencilfail_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.depthfail_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TStencilMode, _impl_.pass_),
  2,
  0,
  1,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScissorTest, _impl_.width_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _impl_.red_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _impl_.green_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _impl_.blue_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode_TColorWrite, _impl_.alpha_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.winding_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.culling_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.blending_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.blendcolor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.depthcompare_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.depthwrite_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.colorwrite_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.stencilfrontface_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.stencilbackface_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderMode, _impl_.scissortest_),
  8,
  9,
  0,
  5,
  7,
  6,
  4,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TAttributeMapping, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TAttributeMapping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TAttributeMapping, _impl_.usage_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TAttributeMapping, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TAttributeMapping, _impl_.attributename_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.cacheid_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.vertexshader_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.fragmentshader_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.mapping_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.compilerdefine_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TShader, _impl_.scope_),
  0,
  3,
  1,
  2,
  ~0u,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMapResource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMapResource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMapResource, _impl_.resource_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMapResource, _impl_.mipmap_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.combined_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.positive_x_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.negative_x_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.positive_y_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.negative_y_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.positive_z_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap_TCubeMap, _impl_.negative_z_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.resource_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.cacheid_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.samples_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.pixelformat_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.renderbufferaccessmode_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.semanticwidth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.semanticheight_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.semanticdepth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.resolutionmultiplier_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.generatemipmaps_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.mipmap_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.cubemap_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBitmap, _impl_.scope_),
  0,
  1,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  15,
  11,
  12,
  13,
  14,
  10,
  ~0u,
  2,
  16,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.bitmapreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.minfilter_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.magfilter_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.anisotropicsamples_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.wrapmodeu_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.wrapmodev_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TTexture, _impl_.uniformname_),
  0,
  1,
  4,
  5,
  3,
  6,
  7,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.rendermode_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.shaderreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.texture_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.scope_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterial, _impl_.uniform_),
  0,
  2,
  1,
  ~0u,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh_TAttributeParamteter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh_TAttributeParamteter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh_TAttributeParamteter, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh_TAttributeParamteter, _impl_.precision_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh_TAttributeParamteter, _impl_.size_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.basenode_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.meshresource_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.meshreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.materialreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.uniform_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.texture_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.attributeparameter_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMesh, _impl_.renderpassdependency_),
  3,
  0,
  2,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.basenode_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.materialreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.uniform_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.renderpass_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.rendertargetscale_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.boundingboxrootname_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.bordersize_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderLayer, _impl_.child_),
  2,
  0,
  ~0u,
  3,
  4,
  1,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingBox, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingBox, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingBox, _impl_.minbound_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingBox, _impl_.maxbound_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingSphere, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingSphere, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingSphere, _impl_.centerposition_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume_TBoundingSphere, _impl_.radius_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume, _impl_.boundingbox_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBoundingVolume, _impl_.boundingsphere_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode_TRenderPassName, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode_TRenderPassName, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode_TRenderPassName, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode_TRenderPassName, _impl_.enabled_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderorder_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.childsortorderrank_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.translation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.transformation_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.camera_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.child_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.mesh_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderlayer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.lookattargetname_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.lookatupvector_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.lookatupaxis_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.lookatforwardaxis_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.lookataligntotargetaxis_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderpassname_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderpassenabled_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderpassnameext_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.boundingvolume_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderorderbin_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TNode, _impl_.renderpass_),
  0,
  11,
  12,
  3,
  4,
  5,
  6,
  7,
  ~0u,
  ~0u,
  ~0u,
  1,
  8,
  13,
  14,
  15,
  2,
  16,
  ~0u,
  10,
  9,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrder, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrderBin, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrderBin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrderBin, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrderBin, _impl_.renderorderrank_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderOrderBin, _impl_.sortorder_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.samples_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.semanticwidth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.semanticheight_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.semanticdepth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.resolutionmultiplier_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.colorbuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.depthbuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.stencilbuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.discardframebuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderTarget, _impl_.scope_),
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  ~0u,
  0,
  1,
  3,
  11,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TClearMode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TClearMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TClearMode, _impl_.clearcolor_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TClearMode, _impl_.cleardepth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TClearMode, _impl_.clearstencil_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TDiscardFramebuffer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TDiscardFramebuffer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TDiscardFramebuffer, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TDiscardFramebuffer, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TDiscardFramebuffer, _impl_.stencil_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.rank_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.renderorder_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.renderorderbin_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.rendertarget_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.rendertargetreference_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.clearmode_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.cameraname_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.viewport_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.viewfrustumcullingenabled_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.scopemask_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TRenderPass, _impl_.scope_),
  0,
  7,
  3,
  ~0u,
  4,
  2,
  5,
  1,
  6,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.rank_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.sourcerenderbuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.destinationrenderbuffer_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regionwidth_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regionheight_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regionsourcex_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regionsourcey_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regiondestinationx_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TBlitPass, _impl_.regiondestinationy_),
  0,
  3,
  1,
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.precision_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.semantic_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.usageindex_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry_TAttributeParamteter, _impl_.cacheid_),
  0,
  2,
  4,
  5,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.resource_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.vertexcount_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.primitivecount_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.primitivetype_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.indexdatacacheid_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TGeometry, _impl_.attributeparameter_),
  0,
  1,
  3,
  4,
  5,
  2,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.material_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.shader_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.bitmap_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.rendertarget_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.renderpass_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.blitpass_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TMaterialLib, _impl_.resourcecache_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScene, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScene, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScene, _impl_.root_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScene, _impl_.materiallibrary_),
  PROTOBUF_FIELD_OFFSET(::HmiScenegraph::TScene, _impl_.renderpass_),
  0,
  1,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::HmiScenegraph::TResourceCacheId)},
  { 10, 19, -1, sizeof(::HmiScenegraph::TUniform)},
  { 22, 43, -1, sizeof(::HmiScenegraph::TCamera)},
  { 58, 70, -1, sizeof(::HmiScenegraph::TBlendMode)},
  { 76, 88, -1, sizeof(::HmiScenegraph::TStencilMode)},
  { 94, 104, -1, sizeof(::HmiScenegraph::TScissorTest)},
  { 108, 118, -1, sizeof(::HmiScenegraph::TRenderMode_TColorWrite)},
  { 122, 138, -1, sizeof(::HmiScenegraph::TRenderMode)},
  { 148, 157, -1, sizeof(::HmiScenegraph::TAttributeMapping)},
  { 160, 173, -1, sizeof(::HmiScenegraph::TShader)},
  { 180, 188, -1, sizeof(::HmiScenegraph::TBitmap_TCubeMapResource)},
  { 190, 203, -1, sizeof(::HmiScenegraph::TBitmap_TCubeMap)},
  { 210, 234, -1, sizeof(::HmiScenegraph::TBitmap)},
  { 252, 266, -1, sizeof(::HmiScenegraph::TTexture)},
  { 274, 286, -1, sizeof(::HmiScenegraph::TMaterial)},
  { 292, 301, -1, sizeof(::HmiScenegraph::TMesh_TAttributeParamteter)},
  { 304, 318, -1, sizeof(::HmiScenegraph::TMesh)},
  { 326, 340, -1, sizeof(::HmiScenegraph::TRenderLayer)},
  { 348, 356, -1, sizeof(::HmiScenegraph::TBoundingVolume_TBoundingBox)},
  { 358, 366, -1, sizeof(::HmiScenegraph::TBoundingVolume_TBoundingSphere)},
  { 368, 376, -1, sizeof(::HmiScenegraph::TBoundingVolume)},
  { 378, 386, -1, sizeof(::HmiScenegraph::TNode_TRenderPassName)},
  { 388, 416, -1, sizeof(::HmiScenegraph::TNode)},
  { 438, -1, -1, sizeof(::HmiScenegraph::TRenderOrder)},
  { 444, 453, -1, sizeof(::HmiScenegraph::TRenderOrderBin)},
  { 456, 475, -1, sizeof(::HmiScenegraph::TRenderTarget)},
  { 488, 497, -1, sizeof(::HmiScenegraph::TClearMode)},
  { 500, 509, -1, sizeof(::HmiScenegraph::TDiscardFramebuffer)},
  { 512, 530, -1, sizeof(::HmiScenegraph::TRenderPass)},
  { 542, 558, -1, sizeof(::HmiScenegraph::TBlitPass)},
  { 568, 580, -1, sizeof(::HmiScenegraph::TGeometry_TAttributeParamteter)},
  { 586, 599, -1, sizeof(::HmiScenegraph::TGeometry)},
  { 606, -1, -1, sizeof(::HmiScenegraph::TMaterialLib)},
  { 620, 629, -1, sizeof(::HmiScenegraph::TScene)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::HmiScenegraph::_TResourceCacheId_default_instance_._instance,
  &::HmiScenegraph::_TUniform_default_instance_._instance,
  &::HmiScenegraph::_TCamera_default_instance_._instance,
  &::HmiScenegraph::_TBlendMode_default_instance_._instance,
  &::HmiScenegraph::_TStencilMode_default_instance_._instance,
  &::HmiScenegraph::_TScissorTest_default_instance_._instance,
  &::HmiScenegraph::_TRenderMode_TColorWrite_default_instance_._instance,
  &::HmiScenegraph::_TRenderMode_default_instance_._instance,
  &::HmiScenegraph::_TAttributeMapping_default_instance_._instance,
  &::HmiScenegraph::_TShader_default_instance_._instance,
  &::HmiScenegraph::_TBitmap_TCubeMapResource_default_instance_._instance,
  &::HmiScenegraph::_TBitmap_TCubeMap_default_instance_._instance,
  &::HmiScenegraph::_TBitmap_default_instance_._instance,
  &::HmiScenegraph::_TTexture_default_instance_._instance,
  &::HmiScenegraph::_TMaterial_default_instance_._instance,
  &::HmiScenegraph::_TMesh_TAttributeParamteter_default_instance_._instance,
  &::HmiScenegraph::_TMesh_default_instance_._instance,
  &::HmiScenegraph::_TRenderLayer_default_instance_._instance,
  &::HmiScenegraph::_TBoundingVolume_TBoundingBox_default_instance_._instance,
  &::HmiScenegraph::_TBoundingVolume_TBoundingSphere_default_instance_._instance,
  &::HmiScenegraph::_TBoundingVolume_default_instance_._instance,
  &::HmiScenegraph::_TNode_TRenderPassName_default_instance_._instance,
  &::HmiScenegraph::_TNode_default_instance_._instance,
  &::HmiScenegraph::_TRenderOrder_default_instance_._instance,
  &::HmiScenegraph::_TRenderOrderBin_default_instance_._instance,
  &::HmiScenegraph::_TRenderTarget_default_instance_._instance,
  &::HmiScenegraph::_TClearMode_default_instance_._instance,
  &::HmiScenegraph::_TDiscardFramebuffer_default_instance_._instance,
  &::HmiScenegraph::_TRenderPass_default_instance_._instance,
  &::HmiScenegraph::_TBlitPass_default_instance_._instance,
  &::HmiScenegraph::_TGeometry_TAttributeParamteter_default_instance_._instance,
  &::HmiScenegraph::_TGeometry_default_instance_._instance,
  &::HmiScenegraph::_TMaterialLib_default_instance_._instance,
  &::HmiScenegraph::_TScene_default_instance_._instance,
};

const char descriptor_table_protodef_Scenegraph_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020Scenegraph.proto\022\rHmiScenegraph\032\rNumer"
  "ic.proto\032\014Common.proto\"-\n\020TResourceCache"
  "Id\022\013\n\003low\030\001 \001(\004\022\014\n\004high\030\002 \001(\004\"U\n\010TUnifor"
  "m\022\014\n\004name\030\001 \002(\t\022\035\n\005value\030\002 \002(\0132\016.TNumeri"
  "cValue\022\034\n\004type\030\003 \002(\0162\016.TENumericType\"\263\003\n"
  "\007TCamera\022=\n\016projectionType\030\016 \001(\0162%.HmiSc"
  "enegraph.TECameraProjectionType\022&\n\020proje"
  "ctionMatrix\030\003 \001(\0132\014.TMatrix4x4f\022\034\n\010rotat"
  "ion\030\004 \001(\0132\n.TVector3f\022\037\n\013translation\030\005 \001"
  "(\0132\n.TVector3f\022\025\n\rhorizontalFOV\030\006 \001(\002\022\023\n"
  "\013aspectRatio\030\007 \001(\002\022\035\n\025horizontalFocalLen"
  "gth\030\017 \001(\002\022\034\n\010viewport\030\020 \001(\0132\n.TVector4f\022"
  "\021\n\tnearPlane\030\010 \001(\002\022\020\n\010farPlane\030\t \001(\002\022\022\n\n"
  "rightPlane\030\n \001(\002\022\021\n\tleftPlane\030\013 \001(\002\022\020\n\010t"
  "opPlane\030\014 \001(\002\022\023\n\013bottomPlane\030\r \001(\002\022&\n\005sc"
  "ope\030\021 \001(\0162\010.TEScope:\rTEScope_Scene\"\242\002\n\nT"
  "BlendMode\022.\n\023blendOperationColor\030\001 \002(\0162\021"
  ".TEBlendOperation\022.\n\023blendOperationAlpha"
  "\030\002 \002(\0162\021.TEBlendOperation\022)\n\021sourceColor"
  "Factor\030\003 \001(\0162\016.TEBlendFactor\022)\n\021sourceAl"
  "phaFactor\030\004 \001(\0162\016.TEBlendFactor\022.\n\026desti"
  "nationColorFactor\030\005 \001(\0162\016.TEBlendFactor\022"
  ".\n\026destinationAlphaFactor\030\006 \001(\0162\016.TEBlen"
  "dFactor\"\321\001\n\014TStencilMode\022&\n\toperation\030\001 "
  "\002(\0162\023.TEStencilOperation\022\026\n\016referenceVal"
  "ue\030\002 \002(\005\022\014\n\004mask\030\003 \002(\007\022(\n\013stencilFail\030\004 "
  "\002(\0162\023.TEStencilOperation\022&\n\tdepthFail\030\005 "
  "\002(\0162\023.TEStencilOperation\022!\n\004pass\030\006 \002(\0162\023"
  ".TEStencilOperation\"C\n\014TScissorTest\022\t\n\001x"
  "\030\001 \002(\005\022\t\n\001y\030\002 \002(\005\022\016\n\006height\030\003 \002(\005\022\r\n\005wid"
  "th\030\004 \002(\005\"\376\003\n\013TRenderMode\022\033\n\007winding\030\001 \002("
  "\0162\n.TEWinding\022\030\n\007culling\030\002 \002(\0162\007.TEFace\022"
  "+\n\010blending\030\003 \002(\0132\031.HmiScenegraph.TBlend"
  "Mode\022\022\n\nblendColor\030\004 \001(\007\022(\n\014depthCompare"
  "\030\005 \002(\0162\022.TECompareFunction\022\022\n\ndepthWrite"
  "\030\006 \001(\010\022:\n\ncolorWrite\030\n \001(\0132&.HmiScenegra"
  "ph.TRenderMode.TColorWrite\0225\n\020stencilFro"
  "ntFace\030\007 \001(\0132\033.HmiScenegraph.TStencilMod"
  "e\0224\n\017stencilBackFace\030\010 \001(\0132\033.HmiScenegra"
  "ph.TStencilMode\0220\n\013scissorTest\030\t \001(\0132\033.H"
  "miScenegraph.TScissorTest\032^\n\013TColorWrite"
  "\022\021\n\003red\030\001 \001(\010:\004true\022\023\n\005green\030\002 \001(\010:\004true"
  "\022\022\n\004blue\030\003 \001(\010:\004true\022\023\n\005alpha\030\004 \001(\010:\004tru"
  "e\"i\n\021TAttributeMapping\022.\n\005usage\030\001 \002(\0162\037."
  "HmiScenegraph.TEAttributeUsage\022\r\n\005index\030"
  "\002 \001(\r\022\025\n\rattributeName\030\003 \002(\t\"\333\001\n\007TShader"
  "\022\014\n\004name\030\001 \002(\t\0220\n\007cacheId\030\007 \001(\0132\037.HmiSce"
  "negraph.TResourceCacheId\022\024\n\014vertexShader"
  "\030\002 \002(\t\022\026\n\016fragmentShader\030\003 \002(\t\0221\n\007mappin"
  "g\030\004 \003(\0132 .HmiScenegraph.TAttributeMappin"
  "g\022\026\n\016compilerDefine\030\005 \003(\t\022\027\n\005scope\030\006 \001(\016"
  "2\010.TEScope\"\225\t\n\007TBitmap\022\014\n\004name\030\001 \002(\t\022\020\n\010"
  "resource\030\002 \001(\t\0220\n\007cacheId\030\021 \001(\0132\037.HmiSce"
  "negraph.TResourceCacheId\022@\n\004type\030\003 \001(\0162\033"
  ".HmiScenegraph.TEBitmapType:\025TEBitmapTyp"
  "e_Resource\022\r\n\005width\030\004 \001(\r\022\016\n\006height\030\005 \001("
  "\r\022\r\n\005depth\030\006 \001(\r\022\022\n\007samples\030\007 \001(\r:\0010\022#\n\013"
  "pixelFormat\030\010 \001(\0162\016.TEPixelFormat\022k\n\026ren"
  "derBufferAccessMode\030\022 \001(\0162\'.HmiScenegrap"
  "h.TERenderBufferAccessMode:\"TERenderBuff"
  "erAccessMode_WriteOnly\0225\n\rsemanticWidth\030"
  "\014 \001(\0162\036.HmiScenegraph.TESemanticValue\0226\n"
  "\016semanticHeight\030\r \001(\0162\036.HmiScenegraph.TE"
  "SemanticValue\0225\n\rsemanticDepth\030\016 \001(\0162\036.H"
  "miScenegraph.TESemanticValue\022\034\n\024resoluti"
  "onMultiplier\030\017 \001(\002\022\027\n\017generateMipmaps\030\t "
  "\001(\010\022\016\n\006mipmap\030\n \003(\t\0220\n\007cubemap\030\013 \001(\0132\037.H"
  "miScenegraph.TBitmap.TCubeMap\022\027\n\005scope\030\020"
  " \001(\0162\010.TEScope\0324\n\020TCubeMapResource\022\020\n\010re"
  "source\030\001 \001(\t\022\016\n\006mipmap\030\002 \003(\t\032\263\003\n\010TCubeMa"
  "p\0229\n\010combined\030\001 \001(\0132\'.HmiScenegraph.TBit"
  "map.TCubeMapResource\022;\n\npositive_x\030\002 \001(\013"
  "2\'.HmiScenegraph.TBitmap.TCubeMapResourc"
  "e\022;\n\nnegative_x\030\003 \001(\0132\'.HmiScenegraph.TB"
  "itmap.TCubeMapResource\022;\n\npositive_y\030\004 \001"
  "(\0132\'.HmiScenegraph.TBitmap.TCubeMapResou"
  "rce\022;\n\nnegative_y\030\005 \001(\0132\'.HmiScenegraph."
  "TBitmap.TCubeMapResource\022;\n\npositive_z\030\006"
  " \001(\0132\'.HmiScenegraph.TBitmap.TCubeMapRes"
  "ource\022;\n\nnegative_z\030\007 \001(\0132\'.HmiScenegrap"
  "h.TBitmap.TCubeMapResource\"\376\001\n\010TTexture\022"
  "\020\n\004name\030\001 \002(\tB\002\030\001\022\027\n\017bitmapReference\030\002 \002"
  "(\t\022#\n\tminFilter\030\003 \001(\0162\020.TETextureFilter\022"
  "#\n\tmagFilter\030\004 \001(\0162\020.TETextureFilter\022\032\n\022"
  "anisotropicSamples\030\006 \001(\002\022%\n\twrapModeU\030\007 "
  "\001(\0162\022.TETextureWrapMode\022%\n\twrapModeV\030\010 \001"
  "(\0162\022.TETextureWrapMode\022\023\n\013uniformName\030\t "
  "\001(\t\"\317\001\n\tTMaterial\022\014\n\004name\030\001 \002(\t\022.\n\nrende"
  "rMode\030\002 \002(\0132\032.HmiScenegraph.TRenderMode\022"
  "\027\n\017shaderReference\030\003 \002(\t\022(\n\007texture\030\004 \003("
  "\0132\027.HmiScenegraph.TTexture\022\027\n\005scope\030\005 \001("
  "\0162\010.TEScope\022(\n\007uniform\030\006 \003(\0132\027.HmiSceneg"
  "raph.TUniform\"\305\003\n\005TMesh\022&\n\010baseNode\030\001 \002("
  "\0132\024.HmiScenegraph.TNode\022\030\n\014meshResource\030"
  "\002 \002(\tB\002\030\001\022\025\n\rmeshReference\030\007 \001(\t\022\031\n\021mate"
  "rialReference\030\003 \002(\t\022(\n\007uniform\030\004 \003(\0132\027.H"
  "miScenegraph.TUniform\022(\n\007texture\030\010 \003(\0132\027"
  ".HmiScenegraph.TTexture\022I\n\022attributePara"
  "meter\030\005 \003(\0132).HmiScenegraph.TMesh.TAttri"
  "buteParamteterB\002\030\001\022\034\n\024renderPassDependen"
  "cy\030\006 \003(\t\032\212\001\n\024TAttributeParamteter\022\014\n\004nam"
  "e\030\001 \002(\t\0226\n\tprecision\030\002 \001(\0162#.HmiScenegra"
  "ph.TEAttributePrecision\022,\n\004size\030\003 \001(\0162\036."
  "HmiScenegraph.TEAttributeSize\"\242\002\n\014TRende"
  "rLayer\022&\n\010baseNode\030\001 \002(\0132\024.HmiScenegraph"
  ".TNode\022\031\n\021materialReference\030\002 \001(\t\022(\n\007uni"
  "form\030\003 \003(\0132\027.HmiScenegraph.TUniform\022.\n\nr"
  "enderPass\030\004 \001(\0132\032.HmiScenegraph.TRenderP"
  "ass\022\034\n\021renderTargetScale\030\005 \001(\002:\0010\022\033\n\023bou"
  "ndingBoxRootName\030\006 \001(\t\022\025\n\nborderSize\030\007 \001"
  "(\005:\0010\022#\n\005child\030\010 \003(\0132\024.HmiScenegraph.TNo"
  "de\"\256\002\n\017TBoundingVolume\022@\n\013boundingBox\030\001 "
  "\001(\0132+.HmiScenegraph.TBoundingVolume.TBou"
  "ndingBox\022F\n\016boundingSphere\030\002 \001(\0132..HmiSc"
  "enegraph.TBoundingVolume.TBoundingSphere"
  "\032J\n\014TBoundingBox\022\034\n\010minBound\030\001 \001(\0132\n.TVe"
  "ctor3f\022\034\n\010maxBound\030\002 \001(\0132\n.TVector3f\032E\n\017"
  "TBoundingSphere\022\"\n\016centerPosition\030\001 \001(\0132"
  "\n.TVector3f\022\016\n\006radius\030\002 \001(\002\"\240\007\n\005TNode\022\014\n"
  "\004name\030\001 \001(\t\022\023\n\013renderOrder\030\002 \001(\005\022\032\n\022chil"
  "dSortOrderRank\030\003 \001(\005\022\031\n\005scale\030\004 \002(\0132\n.TV"
  "ector3f\022\034\n\010rotation\030\005 \002(\0132\n.TVector3f\022\037\n"
  "\013translation\030\006 \002(\0132\n.TVector3f\022(\n\016transf"
  "ormation\030\007 \001(\0132\014.TMatrix4x4fB\002\030\001\022&\n\006came"
  "ra\030\014 \001(\0132\026.HmiScenegraph.TCamera\022#\n\005chil"
  "d\030\n \003(\0132\024.HmiScenegraph.TNode\022\"\n\004mesh\030\013 "
  "\003(\0132\024.HmiScenegraph.TMesh\0220\n\013renderLayer"
  "\030\r \003(\0132\033.HmiScenegraph.TRenderLayer\022\034\n\020l"
  "ookAtTargetName\030\016 \001(\tB\002\030\001\022&\n\016lookAtUpVec"
  "tor\030\017 \001(\0132\n.TVector3fB\002\030\001\022/\n\014lookAtUpAxi"
  "s\030\020 \001(\0162\025.HmiScenegraph.TEAxisB\002\030\001\0224\n\021lo"
  "okAtForwardAxis\030\021 \001(\0162\025.HmiScenegraph.TE"
  "AxisB\002\030\001\022:\n\027lookAtAlignToTargetAxis\030\022 \001("
  "\0162\025.HmiScenegraph.TEAxisB\002\030\001\022\032\n\016renderPa"
  "ssName\030\023 \001(\tB\002\030\001\022$\n\021renderPassEnabled\030\024 "
  "\001(\010:\005falseB\002\030\001\022\?\n\021renderPassNameEXT\030\025 \003("
  "\0132$.HmiScenegraph.TNode.TRenderPassName\022"
  "6\n\016boundingVolume\030\027 \001(\0132\036.HmiScenegraph."
  "TBoundingVolume\022$\n\016renderOrderBin\030\026 \001(\0132"
  "\014.TIdentifier\022.\n\nrenderPass\030\030 \003(\0132\032.HmiS"
  "cenegraph.TRenderPass\0327\n\017TRenderPassName"
  "\022\014\n\004name\030\001 \001(\t\022\026\n\007enabled\030\002 \001(\010:\005false\"\016"
  "\n\014TRenderOrder\"\246\001\n\017TRenderOrderBin\022\032\n\004na"
  "me\030\001 \001(\0132\014.TIdentifier\022\032\n\017renderOrderRan"
  "k\030\002 \001(\005:\0010\022[\n\tsortOrder\030\003 \001(\0162#.HmiScene"
  "graph.TERenderBinSortOrder:#TERenderBinS"
  "ortOrder_ChildSortOrder\"\256\003\n\rTRenderTarge"
  "t\022\014\n\004name\030\014 \001(\t\022\r\n\005width\030\001 \001(\r\022\016\n\006height"
  "\030\002 \001(\r\022\022\n\007samples\030\003 \001(\005:\0010\0225\n\rsemanticWi"
  "dth\030\010 \001(\0162\036.HmiScenegraph.TESemanticValu"
  "e\0226\n\016semanticHeight\030\t \001(\0162\036.HmiScenegrap"
  "h.TESemanticValue\0225\n\rsemanticDepth\030\n \001(\016"
  "2\036.HmiScenegraph.TESemanticValue\022\034\n\024reso"
  "lutionMultiplier\030\013 \001(\002\022\023\n\013colorBuffer\030\004 "
  "\003(\t\022\023\n\013depthBuffer\030\005 \001(\t\022\025\n\rstencilBuffe"
  "r\030\006 \001(\t\022>\n\022discardFramebuffer\030\007 \001(\0132\".Hm"
  "iScenegraph.TDiscardFramebuffer\022\027\n\005scope"
  "\030\016 \001(\0162\010.TEScope\"J\n\nTClearMode\022\022\n\nclearC"
  "olor\030\001 \001(\007\022\022\n\nclearDepth\030\002 \001(\002\022\024\n\014clearS"
  "tencil\030\003 \001(\007\"D\n\023TDiscardFramebuffer\022\r\n\005c"
  "olor\030\001 \001(\010\022\r\n\005depth\030\002 \001(\010\022\017\n\007stencil\030\003 \001"
  "(\010\"\244\003\n\013TRenderPass\022\014\n\004name\030\001 \002(\t\022\014\n\004rank"
  "\030\002 \001(\r\0224\n\013renderOrder\030\003 \001(\0132\033.HmiScenegr"
  "aph.TRenderOrderB\002\030\001\0226\n\016renderOrderBin\030\014"
  " \003(\0132\036.HmiScenegraph.TRenderOrderBin\0222\n\014"
  "renderTarget\030\004 \001(\0132\034.HmiScenegraph.TRend"
  "erTarget\022\035\n\025renderTargetReference\030\013 \001(\t\022"
  ",\n\tclearMode\030\005 \001(\0132\031.HmiScenegraph.TClea"
  "rMode\022\022\n\ncameraName\030\006 \001(\t\022\034\n\010viewport\030\007 "
  "\001(\0132\n.TVector4f\022(\n\031viewFrustumCullingEna"
  "bled\030\010 \001(\010:\005false\022\025\n\tscopeMask\030\t \001(\007B\002\030\001"
  "\022\027\n\005scope\030\n \001(\0162\010.TEScope\"\201\002\n\tTBlitPass\022"
  "\014\n\004name\030\001 \002(\t\022\014\n\004rank\030\002 \001(\r\022\032\n\022sourceRen"
  "derBuffer\030\003 \001(\t\022\037\n\027destinationRenderBuff"
  "er\030\004 \001(\t\022\023\n\013regionWidth\030\005 \001(\r\022\024\n\014regionH"
  "eight\030\006 \001(\r\022\030\n\rregionSourceX\030\007 \001(\r:\0010\022\030\n"
  "\rregionSourceY\030\010 \001(\r:\0010\022\035\n\022regionDestina"
  "tionX\030\t \001(\r:\0010\022\035\n\022regionDestinationY\030\n \001"
  "(\r:\0010\"\271\004\n\tTGeometry\022\014\n\004name\030\001 \002(\t\022\020\n\010res"
  "ource\030\002 \001(\t\022\023\n\013vertexCount\030\004 \001(\r\022\026\n\016prim"
  "itiveCount\030\005 \001(\r\022P\n\rprimitiveType\030\006 \001(\0162"
  "\036.HmiScenegraph.TEPrimitiveType:\031TEPrimi"
  "tiveType_Triangles\0229\n\020indexDataCacheId\030\010"
  " \001(\0132\037.HmiScenegraph.TResourceCacheId\022I\n"
  "\022attributeParameter\030\003 \003(\0132-.HmiScenegrap"
  "h.TGeometry.TAttributeParamteter\032\206\002\n\024TAt"
  "tributeParamteter\022\014\n\004name\030\001 \002(\t\0226\n\tpreci"
  "sion\030\002 \001(\0162#.HmiScenegraph.TEAttributePr"
  "ecision\022,\n\004size\030\003 \001(\0162\036.HmiScenegraph.TE"
  "AttributeSize\0224\n\010semantic\030\004 \001(\0162\".HmiSce"
  "negraph.TEAttributeSemantic\022\022\n\nusageInde"
  "x\030\005 \001(\r\0220\n\007cacheId\030\006 \001(\0132\037.HmiScenegraph"
  ".TResourceCacheId\"\335\002\n\014TMaterialLib\022*\n\010ma"
  "terial\030\001 \003(\0132\030.HmiScenegraph.TMaterial\022&"
  "\n\006shader\030\002 \003(\0132\026.HmiScenegraph.TShader\022&"
  "\n\006bitmap\030\003 \003(\0132\026.HmiScenegraph.TBitmap\022*"
  "\n\010geometry\030\004 \003(\0132\030.HmiScenegraph.TGeomet"
  "ry\0222\n\014renderTarget\030\005 \003(\0132\034.HmiScenegraph"
  ".TRenderTarget\022.\n\nrenderPass\030\006 \003(\0132\032.Hmi"
  "Scenegraph.TRenderPass\022*\n\010blitPass\030\010 \003(\013"
  "2\030.HmiScenegraph.TBlitPass\022\025\n\rresourceCa"
  "che\030\007 \003(\t\"\226\001\n\006TScene\022\"\n\004root\030\001 \002(\0132\024.Hmi"
  "Scenegraph.TNode\0224\n\017materialLibrary\030\003 \001("
  "\0132\033.HmiScenegraph.TMaterialLib\0222\n\nrender"
  "Pass\030\004 \003(\0132\032.HmiScenegraph.TRenderPassB\002"
  "\030\001*\247\001\n\026TECameraProjectionType\022!\n\035TECamer"
  "aProjectionType_Matrix\020\000\022\036\n\032TECameraProj"
  "ectionType_FOV\020\001\022&\n\"TECameraProjectionTy"
  "pe_FocalLength\020\002\022\"\n\036TECameraProjectionTy"
  "pe_Frustum\020\003*\210\001\n\020TEAttributeUsage\022\033\n\027TEA"
  "ttributeUsage_Vertex\020\000\022\035\n\031TEAttributeUsa"
  "ge_TexCoord\020\001\022\033\n\027TEAttributeUsage_Normal"
  "\020\002\022\033\n\027TEAttributeUsage_Custom\020\003*b\n\014TEBit"
  "mapType\022\031\n\025TEBitmapType_Resource\020\000\022\030\n\024TE"
  "BitmapType_Texture\020\001\022\035\n\031TEBitmapType_Ren"
  "derBuffer\020\002*\241\001\n\017TESemanticValue\022\037\n\033TESem"
  "anticValue_ScreenWidth\020\000\022 \n\034TESemanticVa"
  "lue_ScreenHeight\020\001\022$\n TESemanticValue_Sp"
  "litscreenWidth\020\002\022%\n!TESemanticValue_Spli"
  "tscreenHeight\020\003*j\n\030TERenderBufferAccessM"
  "ode\022&\n\"TERenderBufferAccessMode_WriteOnl"
  "y\020\000\022&\n\"TERenderBufferAccessMode_ReadWrit"
  "e\020\001*\350\001\n\017TEPrimitiveType\022\032\n\026TEPrimitiveTy"
  "pe_Points\020\000\022\031\n\025TEPrimitiveType_Lines\020\001\022\035"
  "\n\031TEPrimitiveType_LineStrip\020\002\022\034\n\030TEPrimi"
  "tiveType_LineLoop\020\003\022\035\n\031TEPrimitiveType_T"
  "riangles\020\004\022!\n\035TEPrimitiveType_TriangleSt"
  "rip\020\005\022\037\n\033TEPrimitiveType_TriangleFan\020\006*\200"
  "\001\n\017TEIndexDataType\022\031\n\025TEIndexDataType_UI"
  "nt8\020\000\022\032\n\026TEIndexDataType_UInt16\020\001\022\032\n\026TEI"
  "ndexDataType_UInt32\020\002\022\032\n\026TEIndexDataType"
  "_UInt64\020\003*t\n\024TEAttributePrecision\022\034\n\030TEA"
  "ttributePrecision_low\020\000\022\037\n\033TEAttributePr"
  "ecision_medium\020\001\022\035\n\031TEAttributePrecision"
  "_high\020\002*{\n\017TEAttributeSize\022\032\n\026TEAttribut"
  "eSize_scalar\020\001\022\030\n\024TEAttributeSize_vec2\020\002"
  "\022\030\n\024TEAttributeSize_vec3\020\003\022\030\n\024TEAttribut"
  "eSize_vec4\020\004*\246\002\n\023TEAttributeSemantic\022\037\n\033"
  "TEAttributeSemantic_Invalid\020\001\022 \n\034TEAttri"
  "buteSemantic_Position\020\002\022\035\n\031TEAttributeSe"
  "mantic_Color\020\003\022)\n%TEAttributeSemantic_Te"
  "xtureCoordinate\020\004\022\036\n\032TEAttributeSemantic"
  "_Normal\020\005\022\037\n\033TEAttributeSemantic_Tangent"
  "\020\006\022!\n\035TEAttributeSemantic_Bitangent\020\007\022\036\n"
  "\032TEAttributeSemantic_Custom\020\010*e\n\006TEAxis\022"
  "\014\n\010TEAxis_X\020\000\022\014\n\010TEAxis_Y\020\001\022\014\n\010TEAxis_Z\020"
  "\002\022\017\n\013TEAxis_NegX\020\003\022\017\n\013TEAxis_NegY\020\004\022\017\n\013T"
  "EAxis_NegZ\020\005*\356\001\n\024TERenderBinSortOrder\022\'\n"
  "#TERenderBinSortOrder_ChildSortOrder\020\000\022."
  "\n*TERenderBinSortOrder_InverseChildSortO"
  "rder\020\001\022(\n$TERenderBinSortOrder_RenderOrd"
  "erRank\020\002\022/\n+TERenderBinSortOrder_Inverse"
  "RenderOrderRank\020\003\022\"\n\036TERenderBinSortOrde"
  "r_Undefined\020\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_Scenegraph_2eproto_deps[2] = {
  &::descriptor_table_Common_2eproto,
  &::descriptor_table_Numeric_2eproto,
};
static ::_pbi::once_flag descriptor_table_Scenegraph_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Scenegraph_2eproto = {
    false, false, 10133, descriptor_table_protodef_Scenegraph_2eproto,
    "Scenegraph.proto",
    &descriptor_table_Scenegraph_2eproto_once, descriptor_table_Scenegraph_2eproto_deps, 2, 34,
    schemas, file_default_instances, TableStruct_Scenegraph_2eproto::offsets,
    file_level_metadata_Scenegraph_2eproto, file_level_enum_descriptors_Scenegraph_2eproto,
    file_level_service_descriptors_Scenegraph_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Scenegraph_2eproto_getter() {
  return &descriptor_table_Scenegraph_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Scenegraph_2eproto(&descriptor_table_Scenegraph_2eproto);
namespace HmiScenegraph {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TECameraProjectionType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[0];
}
bool TECameraProjectionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeUsage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[1];
}
bool TEAttributeUsage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEBitmapType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[2];
}
bool TEBitmapType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TESemanticValue_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[3];
}
bool TESemanticValue_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TERenderBufferAccessMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[4];
}
bool TERenderBufferAccessMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEPrimitiveType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[5];
}
bool TEPrimitiveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEIndexDataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[6];
}
bool TEIndexDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributePrecision_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[7];
}
bool TEAttributePrecision_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeSize_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[8];
}
bool TEAttributeSize_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAttributeSemantic_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[9];
}
bool TEAttributeSemantic_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TEAxis_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[10];
}
bool TEAxis_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TERenderBinSortOrder_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Scenegraph_2eproto);
  return file_level_enum_descriptors_Scenegraph_2eproto[11];
}
bool TERenderBinSortOrder_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TResourceCacheId::_Internal {
 public:
  using HasBits = decltype(std::declval<TResourceCacheId>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TResourceCacheId, _impl_._has_bits_);
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TResourceCacheId::TResourceCacheId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TResourceCacheId)
}
TResourceCacheId::TResourceCacheId(const TResourceCacheId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TResourceCacheId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){}
    , decltype(_impl_.high_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.low_, &from._impl_.low_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.high_) -
    reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TResourceCacheId)
}

inline void TResourceCacheId::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.low_){uint64_t{0u}}
    , decltype(_impl_.high_){uint64_t{0u}}
  };
}

TResourceCacheId::~TResourceCacheId() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TResourceCacheId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TResourceCacheId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TResourceCacheId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TResourceCacheId::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TResourceCacheId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.low_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_) -
        reinterpret_cast<char*>(&_impl_.low_)) + sizeof(_impl_.high_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TResourceCacheId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 low = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_low(&has_bits);
          _impl_.low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 high = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_high(&has_bits);
          _impl_.high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TResourceCacheId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TResourceCacheId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 low = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_low(), target);
  }

  // optional uint64 high = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_high(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TResourceCacheId)
  return target;
}

size_t TResourceCacheId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TResourceCacheId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 low = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_low());
    }

    // optional uint64 high = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_high());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TResourceCacheId::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TResourceCacheId::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TResourceCacheId::GetClassData() const { return &_class_data_; }


void TResourceCacheId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TResourceCacheId*>(&to_msg);
  auto& from = static_cast<const TResourceCacheId&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TResourceCacheId)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.low_ = from._impl_.low_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.high_ = from._impl_.high_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TResourceCacheId::CopyFrom(const TResourceCacheId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TResourceCacheId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TResourceCacheId::IsInitialized() const {
  return true;
}

void TResourceCacheId::InternalSwap(TResourceCacheId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TResourceCacheId, _impl_.high_)
      + sizeof(TResourceCacheId::_impl_.high_)
      - PROTOBUF_FIELD_OFFSET(TResourceCacheId, _impl_.low_)>(
          reinterpret_cast<char*>(&_impl_.low_),
          reinterpret_cast<char*>(&other->_impl_.low_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TResourceCacheId::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[0]);
}

// ===================================================================

class TUniform::_Internal {
 public:
  using HasBits = decltype(std::declval<TUniform>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TUniform, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TNumericValue& value(const TUniform* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TNumericValue&
TUniform::_Internal::value(const TUniform* msg) {
  return *msg->_impl_.value_;
}
void TUniform::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TUniform::TUniform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TUniform)
}
TUniform::TUniform(const TUniform& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TUniform* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::TNumericValue(*from._impl_.value_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TUniform)
}

inline void TUniform::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.type_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TUniform::~TUniform() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TUniform)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TUniform::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.value_;
}

void TUniform::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TUniform::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TUniform)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.value_ != nullptr);
      _impl_.value_->Clear();
    }
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TUniform::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TUniform.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .TNumericValue value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TENumericType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TENumericType_IsValid(val))) {
            _internal_set_type(static_cast<::TENumericType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TUniform::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TUniform)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TUniform.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required .TNumericValue value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // required .TENumericType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TUniform)
  return target;
}

size_t TUniform::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TUniform)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_value()) {
    // required .TNumericValue value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  if (_internal_has_type()) {
    // required .TENumericType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TUniform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TUniform)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required .TNumericValue value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);

    // required .TENumericType type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TUniform::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TUniform::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TUniform::GetClassData() const { return &_class_data_; }


void TUniform::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TUniform*>(&to_msg);
  auto& from = static_cast<const TUniform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TUniform)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_value()->::TNumericValue::MergeFrom(
          from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TUniform::CopyFrom(const TUniform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TUniform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TUniform::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_value()) {
    if (!_impl_.value_->IsInitialized()) return false;
  }
  return true;
}

void TUniform::InternalSwap(TUniform* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.value_, other->_impl_.value_);
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TUniform::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[1]);
}

// ===================================================================

class TCamera::_Internal {
 public:
  using HasBits = decltype(std::declval<TCamera>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TCamera, _impl_._has_bits_);
  static void set_has_projectiontype(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TMatrix4x4f& projectionmatrix(const TCamera* msg);
  static void set_has_projectionmatrix(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TVector3f& rotation(const TCamera* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TVector3f& translation(const TCamera* msg);
  static void set_has_translation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_horizontalfov(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_aspectratio(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_horizontalfocallength(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TVector4f& viewport(const TCamera* msg);
  static void set_has_viewport(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nearplane(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_farplane(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_rightplane(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_leftplane(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_topplane(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_bottomplane(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::TMatrix4x4f&
TCamera::_Internal::projectionmatrix(const TCamera* msg) {
  return *msg->_impl_.projectionmatrix_;
}
const ::TVector3f&
TCamera::_Internal::rotation(const TCamera* msg) {
  return *msg->_impl_.rotation_;
}
const ::TVector3f&
TCamera::_Internal::translation(const TCamera* msg) {
  return *msg->_impl_.translation_;
}
const ::TVector4f&
TCamera::_Internal::viewport(const TCamera* msg) {
  return *msg->_impl_.viewport_;
}
void TCamera::clear_projectionmatrix() {
  if (_impl_.projectionmatrix_ != nullptr) _impl_.projectionmatrix_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TCamera::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TCamera::clear_translation() {
  if (_impl_.translation_ != nullptr) _impl_.translation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TCamera::clear_viewport() {
  if (_impl_.viewport_ != nullptr) _impl_.viewport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
TCamera::TCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TCamera)
}
TCamera::TCamera(const TCamera& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TCamera* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.projectionmatrix_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , decltype(_impl_.viewport_){nullptr}
    , decltype(_impl_.horizontalfov_){}
    , decltype(_impl_.aspectratio_){}
    , decltype(_impl_.nearplane_){}
    , decltype(_impl_.farplane_){}
    , decltype(_impl_.rightplane_){}
    , decltype(_impl_.leftplane_){}
    , decltype(_impl_.topplane_){}
    , decltype(_impl_.bottomplane_){}
    , decltype(_impl_.projectiontype_){}
    , decltype(_impl_.horizontalfocallength_){}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_projectionmatrix()) {
    _this->_impl_.projectionmatrix_ = new ::TMatrix4x4f(*from._impl_.projectionmatrix_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::TVector3f(*from._impl_.rotation_);
  }
  if (from._internal_has_translation()) {
    _this->_impl_.translation_ = new ::TVector3f(*from._impl_.translation_);
  }
  if (from._internal_has_viewport()) {
    _this->_impl_.viewport_ = new ::TVector4f(*from._impl_.viewport_);
  }
  ::memcpy(&_impl_.horizontalfov_, &from._impl_.horizontalfov_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scope_) -
    reinterpret_cast<char*>(&_impl_.horizontalfov_)) + sizeof(_impl_.scope_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TCamera)
}

inline void TCamera::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.projectionmatrix_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , decltype(_impl_.viewport_){nullptr}
    , decltype(_impl_.horizontalfov_){0}
    , decltype(_impl_.aspectratio_){0}
    , decltype(_impl_.nearplane_){0}
    , decltype(_impl_.farplane_){0}
    , decltype(_impl_.rightplane_){0}
    , decltype(_impl_.leftplane_){0}
    , decltype(_impl_.topplane_){0}
    , decltype(_impl_.bottomplane_){0}
    , decltype(_impl_.projectiontype_){0}
    , decltype(_impl_.horizontalfocallength_){0}
    , decltype(_impl_.scope_){3}
  };
}

TCamera::~TCamera() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TCamera)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TCamera::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.projectionmatrix_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.translation_;
  if (this != internal_default_instance()) delete _impl_.viewport_;
}

void TCamera::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TCamera::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TCamera)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.projectionmatrix_ != nullptr);
      _impl_.projectionmatrix_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.translation_ != nullptr);
      _impl_.translation_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.viewport_ != nullptr);
      _impl_.viewport_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.horizontalfov_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.farplane_) -
        reinterpret_cast<char*>(&_impl_.horizontalfov_)) + sizeof(_impl_.farplane_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.rightplane_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.horizontalfocallength_) -
        reinterpret_cast<char*>(&_impl_.rightplane_)) + sizeof(_impl_.horizontalfocallength_));
    _impl_.scope_ = 3;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TCamera::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TMatrix4x4f projectionMatrix = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_projectionmatrix(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3f rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3f translation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_translation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float horizontalFOV = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_horizontalfov(&has_bits);
          _impl_.horizontalfov_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float aspectRatio = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_aspectratio(&has_bits);
          _impl_.aspectratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float nearPlane = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_nearplane(&has_bits);
          _impl_.nearplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float farPlane = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_farplane(&has_bits);
          _impl_.farplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float rightPlane = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_rightplane(&has_bits);
          _impl_.rightplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float leftPlane = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_leftplane(&has_bits);
          _impl_.leftplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float topPlane = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_topplane(&has_bits);
          _impl_.topplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float bottomPlane = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_bottomplane(&has_bits);
          _impl_.bottomplane_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TECameraProjectionType projectionType = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TECameraProjectionType_IsValid(val))) {
            _internal_set_projectiontype(static_cast<::HmiScenegraph::TECameraProjectionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float horizontalFocalLength = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_horizontalfocallength(&has_bits);
          _impl_.horizontalfocallength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector4f viewport = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewport(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 17 [default = TEScope_Scene];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TCamera::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TCamera)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TMatrix4x4f projectionMatrix = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::projectionmatrix(this),
        _Internal::projectionmatrix(this).GetCachedSize(), target, stream);
  }

  // optional .TVector3f rotation = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // optional .TVector3f translation = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::translation(this),
        _Internal::translation(this).GetCachedSize(), target, stream);
  }

  // optional float horizontalFOV = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_horizontalfov(), target);
  }

  // optional float aspectRatio = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_aspectratio(), target);
  }

  // optional float nearPlane = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_nearplane(), target);
  }

  // optional float farPlane = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_farplane(), target);
  }

  // optional float rightPlane = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_rightplane(), target);
  }

  // optional float leftPlane = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_leftplane(), target);
  }

  // optional float topPlane = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_topplane(), target);
  }

  // optional float bottomPlane = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_bottomplane(), target);
  }

  // optional .HmiScenegraph.TECameraProjectionType projectionType = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_projectiontype(), target);
  }

  // optional float horizontalFocalLength = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_horizontalfocallength(), target);
  }

  // optional .TVector4f viewport = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::viewport(this),
        _Internal::viewport(this).GetCachedSize(), target, stream);
  }

  // optional .TEScope scope = 17 [default = TEScope_Scene];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_scope(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TCamera)
  return target;
}

size_t TCamera::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TCamera)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TMatrix4x4f projectionMatrix = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.projectionmatrix_);
    }

    // optional .TVector3f rotation = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

    // optional .TVector3f translation = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.translation_);
    }

    // optional .TVector4f viewport = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewport_);
    }

    // optional float horizontalFOV = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float aspectRatio = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float nearPlane = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float farPlane = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional float rightPlane = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float leftPlane = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float topPlane = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float bottomPlane = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional .HmiScenegraph.TECameraProjectionType projectionType = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_projectiontype());
    }

    // optional float horizontalFocalLength = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional .TEScope scope = 17 [default = TEScope_Scene];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TCamera::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TCamera::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TCamera::GetClassData() const { return &_class_data_; }


void TCamera::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TCamera*>(&to_msg);
  auto& from = static_cast<const TCamera&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TCamera)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_projectionmatrix()->::TMatrix4x4f::MergeFrom(
          from._internal_projectionmatrix());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rotation()->::TVector3f::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_translation()->::TVector3f::MergeFrom(
          from._internal_translation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_viewport()->::TVector4f::MergeFrom(
          from._internal_viewport());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.horizontalfov_ = from._impl_.horizontalfov_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.aspectratio_ = from._impl_.aspectratio_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.nearplane_ = from._impl_.nearplane_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.farplane_ = from._impl_.farplane_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.rightplane_ = from._impl_.rightplane_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.leftplane_ = from._impl_.leftplane_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.topplane_ = from._impl_.topplane_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.bottomplane_ = from._impl_.bottomplane_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.projectiontype_ = from._impl_.projectiontype_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.horizontalfocallength_ = from._impl_.horizontalfocallength_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TCamera::CopyFrom(const TCamera& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TCamera)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCamera::IsInitialized() const {
  if (_internal_has_rotation()) {
    if (!_impl_.rotation_->IsInitialized()) return false;
  }
  if (_internal_has_translation()) {
    if (!_impl_.translation_->IsInitialized()) return false;
  }
  if (_internal_has_viewport()) {
    if (!_impl_.viewport_->IsInitialized()) return false;
  }
  return true;
}

void TCamera::InternalSwap(TCamera* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TCamera, _impl_.horizontalfocallength_)
      + sizeof(TCamera::_impl_.horizontalfocallength_)
      - PROTOBUF_FIELD_OFFSET(TCamera, _impl_.projectionmatrix_)>(
          reinterpret_cast<char*>(&_impl_.projectionmatrix_),
          reinterpret_cast<char*>(&other->_impl_.projectionmatrix_));
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TCamera::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[2]);
}

// ===================================================================

class TBlendMode::_Internal {
 public:
  using HasBits = decltype(std::declval<TBlendMode>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBlendMode, _impl_._has_bits_);
  static void set_has_blendoperationcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blendoperationalpha(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sourcecolorfactor(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sourcealphafactor(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_destinationcolorfactor(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_destinationalphafactor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TBlendMode::TBlendMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBlendMode)
}
TBlendMode::TBlendMode(const TBlendMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBlendMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blendoperationcolor_){}
    , decltype(_impl_.blendoperationalpha_){}
    , decltype(_impl_.sourcecolorfactor_){}
    , decltype(_impl_.sourcealphafactor_){}
    , decltype(_impl_.destinationcolorfactor_){}
    , decltype(_impl_.destinationalphafactor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.blendoperationcolor_, &from._impl_.blendoperationcolor_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.destinationalphafactor_) -
    reinterpret_cast<char*>(&_impl_.blendoperationcolor_)) + sizeof(_impl_.destinationalphafactor_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBlendMode)
}

inline void TBlendMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blendoperationcolor_){1}
    , decltype(_impl_.blendoperationalpha_){1}
    , decltype(_impl_.sourcecolorfactor_){1}
    , decltype(_impl_.sourcealphafactor_){1}
    , decltype(_impl_.destinationcolorfactor_){1}
    , decltype(_impl_.destinationalphafactor_){1}
  };
}

TBlendMode::~TBlendMode() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBlendMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBlendMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TBlendMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBlendMode::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBlendMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    _impl_.blendoperationcolor_ = 1;
    _impl_.blendoperationalpha_ = 1;
    _impl_.sourcecolorfactor_ = 1;
    _impl_.sourcealphafactor_ = 1;
    _impl_.destinationcolorfactor_ = 1;
    _impl_.destinationalphafactor_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBlendMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TEBlendOperation blendOperationColor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendOperation_IsValid(val))) {
            _internal_set_blendoperationcolor(static_cast<::TEBlendOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TEBlendOperation blendOperationAlpha = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendOperation_IsValid(val))) {
            _internal_set_blendoperationalpha(static_cast<::TEBlendOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TEBlendFactor sourceColorFactor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendFactor_IsValid(val))) {
            _internal_set_sourcecolorfactor(static_cast<::TEBlendFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TEBlendFactor sourceAlphaFactor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendFactor_IsValid(val))) {
            _internal_set_sourcealphafactor(static_cast<::TEBlendFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TEBlendFactor destinationColorFactor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendFactor_IsValid(val))) {
            _internal_set_destinationcolorfactor(static_cast<::TEBlendFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TEBlendFactor destinationAlphaFactor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEBlendFactor_IsValid(val))) {
            _internal_set_destinationalphafactor(static_cast<::TEBlendFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBlendMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBlendMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TEBlendOperation blendOperationColor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_blendoperationcolor(), target);
  }

  // required .TEBlendOperation blendOperationAlpha = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_blendoperationalpha(), target);
  }

  // optional .TEBlendFactor sourceColorFactor = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_sourcecolorfactor(), target);
  }

  // optional .TEBlendFactor sourceAlphaFactor = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_sourcealphafactor(), target);
  }

  // optional .TEBlendFactor destinationColorFactor = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_destinationcolorfactor(), target);
  }

  // optional .TEBlendFactor destinationAlphaFactor = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_destinationalphafactor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBlendMode)
  return target;
}

size_t TBlendMode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TBlendMode)
  size_t total_size = 0;

  if (_internal_has_blendoperationcolor()) {
    // required .TEBlendOperation blendOperationColor = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_blendoperationcolor());
  }

  if (_internal_has_blendoperationalpha()) {
    // required .TEBlendOperation blendOperationAlpha = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_blendoperationalpha());
  }

  return total_size;
}
size_t TBlendMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBlendMode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TEBlendOperation blendOperationColor = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_blendoperationcolor());

    // required .TEBlendOperation blendOperationAlpha = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_blendoperationalpha());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional .TEBlendFactor sourceColorFactor = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sourcecolorfactor());
    }

    // optional .TEBlendFactor sourceAlphaFactor = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sourcealphafactor());
    }

    // optional .TEBlendFactor destinationColorFactor = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_destinationcolorfactor());
    }

    // optional .TEBlendFactor destinationAlphaFactor = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_destinationalphafactor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBlendMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBlendMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBlendMode::GetClassData() const { return &_class_data_; }


void TBlendMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBlendMode*>(&to_msg);
  auto& from = static_cast<const TBlendMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBlendMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.blendoperationcolor_ = from._impl_.blendoperationcolor_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.blendoperationalpha_ = from._impl_.blendoperationalpha_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sourcecolorfactor_ = from._impl_.sourcecolorfactor_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sourcealphafactor_ = from._impl_.sourcealphafactor_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.destinationcolorfactor_ = from._impl_.destinationcolorfactor_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.destinationalphafactor_ = from._impl_.destinationalphafactor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBlendMode::CopyFrom(const TBlendMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBlendMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBlendMode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TBlendMode::InternalSwap(TBlendMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.blendoperationcolor_, other->_impl_.blendoperationcolor_);
  swap(_impl_.blendoperationalpha_, other->_impl_.blendoperationalpha_);
  swap(_impl_.sourcecolorfactor_, other->_impl_.sourcecolorfactor_);
  swap(_impl_.sourcealphafactor_, other->_impl_.sourcealphafactor_);
  swap(_impl_.destinationcolorfactor_, other->_impl_.destinationcolorfactor_);
  swap(_impl_.destinationalphafactor_, other->_impl_.destinationalphafactor_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TBlendMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[3]);
}

// ===================================================================

class TStencilMode::_Internal {
 public:
  using HasBits = decltype(std::declval<TStencilMode>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TStencilMode, _impl_._has_bits_);
  static void set_has_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_referencevalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stencilfail(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_depthfail(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_pass(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

TStencilMode::TStencilMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TStencilMode)
}
TStencilMode::TStencilMode(const TStencilMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TStencilMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referencevalue_){}
    , decltype(_impl_.mask_){}
    , decltype(_impl_.operation_){}
    , decltype(_impl_.stencilfail_){}
    , decltype(_impl_.depthfail_){}
    , decltype(_impl_.pass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.referencevalue_, &from._impl_.referencevalue_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pass_) -
    reinterpret_cast<char*>(&_impl_.referencevalue_)) + sizeof(_impl_.pass_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TStencilMode)
}

inline void TStencilMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referencevalue_){0}
    , decltype(_impl_.mask_){0u}
    , decltype(_impl_.operation_){1}
    , decltype(_impl_.stencilfail_){1}
    , decltype(_impl_.depthfail_){1}
    , decltype(_impl_.pass_){1}
  };
}

TStencilMode::~TStencilMode() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TStencilMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TStencilMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TStencilMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TStencilMode::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TStencilMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.referencevalue_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mask_) -
        reinterpret_cast<char*>(&_impl_.referencevalue_)) + sizeof(_impl_.mask_));
    _impl_.operation_ = 1;
    _impl_.stencilfail_ = 1;
    _impl_.depthfail_ = 1;
    _impl_.pass_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TStencilMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TEStencilOperation operation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEStencilOperation_IsValid(val))) {
            _internal_set_operation(static_cast<::TEStencilOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 referenceValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_referencevalue(&has_bits);
          _impl_.referencevalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required fixed32 mask = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_mask(&has_bits);
          _impl_.mask_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // required .TEStencilOperation stencilFail = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEStencilOperation_IsValid(val))) {
            _internal_set_stencilfail(static_cast<::TEStencilOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TEStencilOperation depthFail = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEStencilOperation_IsValid(val))) {
            _internal_set_depthfail(static_cast<::TEStencilOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TEStencilOperation pass = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEStencilOperation_IsValid(val))) {
            _internal_set_pass(static_cast<::TEStencilOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TStencilMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TStencilMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TEStencilOperation operation = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_operation(), target);
  }

  // required int32 referenceValue = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_referencevalue(), target);
  }

  // required fixed32 mask = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_mask(), target);
  }

  // required .TEStencilOperation stencilFail = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_stencilfail(), target);
  }

  // required .TEStencilOperation depthFail = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_depthfail(), target);
  }

  // required .TEStencilOperation pass = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_pass(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TStencilMode)
  return target;
}

size_t TStencilMode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TStencilMode)
  size_t total_size = 0;

  if (_internal_has_referencevalue()) {
    // required int32 referenceValue = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_referencevalue());
  }

  if (_internal_has_mask()) {
    // required fixed32 mask = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_operation()) {
    // required .TEStencilOperation operation = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_operation());
  }

  if (_internal_has_stencilfail()) {
    // required .TEStencilOperation stencilFail = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_stencilfail());
  }

  if (_internal_has_depthfail()) {
    // required .TEStencilOperation depthFail = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_depthfail());
  }

  if (_internal_has_pass()) {
    // required .TEStencilOperation pass = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pass());
  }

  return total_size;
}
size_t TStencilMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TStencilMode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required int32 referenceValue = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_referencevalue());

    // required fixed32 mask = 3;
    total_size += 1 + 4;

    // required .TEStencilOperation operation = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_operation());

    // required .TEStencilOperation stencilFail = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_stencilfail());

    // required .TEStencilOperation depthFail = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_depthfail());

    // required .TEStencilOperation pass = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pass());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TStencilMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TStencilMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TStencilMode::GetClassData() const { return &_class_data_; }


void TStencilMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TStencilMode*>(&to_msg);
  auto& from = static_cast<const TStencilMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TStencilMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.referencevalue_ = from._impl_.referencevalue_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mask_ = from._impl_.mask_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.operation_ = from._impl_.operation_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stencilfail_ = from._impl_.stencilfail_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.depthfail_ = from._impl_.depthfail_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pass_ = from._impl_.pass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TStencilMode::CopyFrom(const TStencilMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TStencilMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TStencilMode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TStencilMode::InternalSwap(TStencilMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TStencilMode, _impl_.mask_)
      + sizeof(TStencilMode::_impl_.mask_)
      - PROTOBUF_FIELD_OFFSET(TStencilMode, _impl_.referencevalue_)>(
          reinterpret_cast<char*>(&_impl_.referencevalue_),
          reinterpret_cast<char*>(&other->_impl_.referencevalue_));
  swap(_impl_.operation_, other->_impl_.operation_);
  swap(_impl_.stencilfail_, other->_impl_.stencilfail_);
  swap(_impl_.depthfail_, other->_impl_.depthfail_);
  swap(_impl_.pass_, other->_impl_.pass_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TStencilMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[4]);
}

// ===================================================================

class TScissorTest::_Internal {
 public:
  using HasBits = decltype(std::declval<TScissorTest>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TScissorTest, _impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TScissorTest::TScissorTest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TScissorTest)
}
TScissorTest::TScissorTest(const TScissorTest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TScissorTest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.width_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.width_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.width_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TScissorTest)
}

inline void TScissorTest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.width_){0}
  };
}

TScissorTest::~TScissorTest() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TScissorTest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TScissorTest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TScissorTest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TScissorTest::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TScissorTest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.width_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.width_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TScissorTest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TScissorTest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TScissorTest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // required int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // required int32 height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_height(), target);
  }

  // required int32 width = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TScissorTest)
  return target;
}

size_t TScissorTest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TScissorTest)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  if (_internal_has_height()) {
    // required int32 height = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
  }

  if (_internal_has_width()) {
    // required int32 width = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  return total_size;
}
size_t TScissorTest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TScissorTest)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 x = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

    // required int32 height = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());

    // required int32 width = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TScissorTest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TScissorTest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TScissorTest::GetClassData() const { return &_class_data_; }


void TScissorTest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TScissorTest*>(&to_msg);
  auto& from = static_cast<const TScissorTest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TScissorTest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TScissorTest::CopyFrom(const TScissorTest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TScissorTest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TScissorTest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TScissorTest::InternalSwap(TScissorTest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TScissorTest, _impl_.width_)
      + sizeof(TScissorTest::_impl_.width_)
      - PROTOBUF_FIELD_OFFSET(TScissorTest, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TScissorTest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[5]);
}

// ===================================================================

class TRenderMode_TColorWrite::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderMode_TColorWrite>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderMode_TColorWrite, _impl_._has_bits_);
  static void set_has_red(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_green(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_alpha(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TRenderMode_TColorWrite::TRenderMode_TColorWrite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderMode.TColorWrite)
}
TRenderMode_TColorWrite::TRenderMode_TColorWrite(const TRenderMode_TColorWrite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderMode_TColorWrite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){}
    , decltype(_impl_.green_){}
    , decltype(_impl_.blue_){}
    , decltype(_impl_.alpha_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.red_, &from._impl_.red_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alpha_) -
    reinterpret_cast<char*>(&_impl_.red_)) + sizeof(_impl_.alpha_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderMode.TColorWrite)
}

inline void TRenderMode_TColorWrite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.red_){true}
    , decltype(_impl_.green_){true}
    , decltype(_impl_.blue_){true}
    , decltype(_impl_.alpha_){true}
  };
}

TRenderMode_TColorWrite::~TRenderMode_TColorWrite() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderMode.TColorWrite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderMode_TColorWrite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TRenderMode_TColorWrite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderMode_TColorWrite::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderMode.TColorWrite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    _impl_.red_ = true;
    _impl_.green_ = true;
    _impl_.blue_ = true;
    _impl_.alpha_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderMode_TColorWrite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool red = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_red(&has_bits);
          _impl_.red_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool green = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_green(&has_bits);
          _impl_.green_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool blue = 3 [default = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_blue(&has_bits);
          _impl_.blue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool alpha = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_alpha(&has_bits);
          _impl_.alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderMode_TColorWrite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderMode.TColorWrite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool red = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_red(), target);
  }

  // optional bool green = 2 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_green(), target);
  }

  // optional bool blue = 3 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_blue(), target);
  }

  // optional bool alpha = 4 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_alpha(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderMode.TColorWrite)
  return target;
}

size_t TRenderMode_TColorWrite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderMode.TColorWrite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool red = 1 [default = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool green = 2 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool blue = 3 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool alpha = 4 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderMode_TColorWrite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderMode_TColorWrite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderMode_TColorWrite::GetClassData() const { return &_class_data_; }


void TRenderMode_TColorWrite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderMode_TColorWrite*>(&to_msg);
  auto& from = static_cast<const TRenderMode_TColorWrite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderMode.TColorWrite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.red_ = from._impl_.red_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.green_ = from._impl_.green_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.blue_ = from._impl_.blue_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.alpha_ = from._impl_.alpha_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderMode_TColorWrite::CopyFrom(const TRenderMode_TColorWrite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderMode.TColorWrite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderMode_TColorWrite::IsInitialized() const {
  return true;
}

void TRenderMode_TColorWrite::InternalSwap(TRenderMode_TColorWrite* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.red_, other->_impl_.red_);
  swap(_impl_.green_, other->_impl_.green_);
  swap(_impl_.blue_, other->_impl_.blue_);
  swap(_impl_.alpha_, other->_impl_.alpha_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderMode_TColorWrite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[6]);
}

// ===================================================================

class TRenderMode::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderMode>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderMode, _impl_._has_bits_);
  static void set_has_winding(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_culling(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::HmiScenegraph::TBlendMode& blending(const TRenderMode* msg);
  static void set_has_blending(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blendcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_depthcompare(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_depthwrite(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::HmiScenegraph::TRenderMode_TColorWrite& colorwrite(const TRenderMode* msg);
  static void set_has_colorwrite(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::HmiScenegraph::TStencilMode& stencilfrontface(const TRenderMode* msg);
  static void set_has_stencilfrontface(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::HmiScenegraph::TStencilMode& stencilbackface(const TRenderMode* msg);
  static void set_has_stencilbackface(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::HmiScenegraph::TScissorTest& scissortest(const TRenderMode* msg);
  static void set_has_scissortest(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000381) ^ 0x00000381) != 0;
  }
};

const ::HmiScenegraph::TBlendMode&
TRenderMode::_Internal::blending(const TRenderMode* msg) {
  return *msg->_impl_.blending_;
}
const ::HmiScenegraph::TRenderMode_TColorWrite&
TRenderMode::_Internal::colorwrite(const TRenderMode* msg) {
  return *msg->_impl_.colorwrite_;
}
const ::HmiScenegraph::TStencilMode&
TRenderMode::_Internal::stencilfrontface(const TRenderMode* msg) {
  return *msg->_impl_.stencilfrontface_;
}
const ::HmiScenegraph::TStencilMode&
TRenderMode::_Internal::stencilbackface(const TRenderMode* msg) {
  return *msg->_impl_.stencilbackface_;
}
const ::HmiScenegraph::TScissorTest&
TRenderMode::_Internal::scissortest(const TRenderMode* msg) {
  return *msg->_impl_.scissortest_;
}
TRenderMode::TRenderMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderMode)
}
TRenderMode::TRenderMode(const TRenderMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blending_){nullptr}
    , decltype(_impl_.stencilfrontface_){nullptr}
    , decltype(_impl_.stencilbackface_){nullptr}
    , decltype(_impl_.scissortest_){nullptr}
    , decltype(_impl_.colorwrite_){nullptr}
    , decltype(_impl_.blendcolor_){}
    , decltype(_impl_.depthwrite_){}
    , decltype(_impl_.depthcompare_){}
    , decltype(_impl_.winding_){}
    , decltype(_impl_.culling_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_blending()) {
    _this->_impl_.blending_ = new ::HmiScenegraph::TBlendMode(*from._impl_.blending_);
  }
  if (from._internal_has_stencilfrontface()) {
    _this->_impl_.stencilfrontface_ = new ::HmiScenegraph::TStencilMode(*from._impl_.stencilfrontface_);
  }
  if (from._internal_has_stencilbackface()) {
    _this->_impl_.stencilbackface_ = new ::HmiScenegraph::TStencilMode(*from._impl_.stencilbackface_);
  }
  if (from._internal_has_scissortest()) {
    _this->_impl_.scissortest_ = new ::HmiScenegraph::TScissorTest(*from._impl_.scissortest_);
  }
  if (from._internal_has_colorwrite()) {
    _this->_impl_.colorwrite_ = new ::HmiScenegraph::TRenderMode_TColorWrite(*from._impl_.colorwrite_);
  }
  ::memcpy(&_impl_.blendcolor_, &from._impl_.blendcolor_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.culling_) -
    reinterpret_cast<char*>(&_impl_.blendcolor_)) + sizeof(_impl_.culling_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderMode)
}

inline void TRenderMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blending_){nullptr}
    , decltype(_impl_.stencilfrontface_){nullptr}
    , decltype(_impl_.stencilbackface_){nullptr}
    , decltype(_impl_.scissortest_){nullptr}
    , decltype(_impl_.colorwrite_){nullptr}
    , decltype(_impl_.blendcolor_){0u}
    , decltype(_impl_.depthwrite_){false}
    , decltype(_impl_.depthcompare_){1}
    , decltype(_impl_.winding_){1}
    , decltype(_impl_.culling_){1}
  };
}

TRenderMode::~TRenderMode() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.blending_;
  if (this != internal_default_instance()) delete _impl_.stencilfrontface_;
  if (this != internal_default_instance()) delete _impl_.stencilbackface_;
  if (this != internal_default_instance()) delete _impl_.scissortest_;
  if (this != internal_default_instance()) delete _impl_.colorwrite_;
}

void TRenderMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderMode::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.blending_ != nullptr);
      _impl_.blending_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stencilfrontface_ != nullptr);
      _impl_.stencilfrontface_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.stencilbackface_ != nullptr);
      _impl_.stencilbackface_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.scissortest_ != nullptr);
      _impl_.scissortest_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.colorwrite_ != nullptr);
      _impl_.colorwrite_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.blendcolor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.depthwrite_) -
        reinterpret_cast<char*>(&_impl_.blendcolor_)) + sizeof(_impl_.depthwrite_));
    _impl_.depthcompare_ = 1;
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.winding_ = 1;
    _impl_.culling_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TEWinding winding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEWinding_IsValid(val))) {
            _internal_set_winding(static_cast<::TEWinding>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TEFace culling = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEFace_IsValid(val))) {
            _internal_set_culling(static_cast<::TEFace>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .HmiScenegraph.TBlendMode blending = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_blending(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 blendColor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_blendcolor(&has_bits);
          _impl_.blendcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // required .TECompareFunction depthCompare = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TECompareFunction_IsValid(val))) {
            _internal_set_depthcompare(static_cast<::TECompareFunction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool depthWrite = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_depthwrite(&has_bits);
          _impl_.depthwrite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TStencilMode stencilFrontFace = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_stencilfrontface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TStencilMode stencilBackFace = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_stencilbackface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TScissorTest scissorTest = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_scissortest(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TRenderMode.TColorWrite colorWrite = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_colorwrite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TEWinding winding = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_winding(), target);
  }

  // required .TEFace culling = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_culling(), target);
  }

  // required .HmiScenegraph.TBlendMode blending = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::blending(this),
        _Internal::blending(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 blendColor = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_blendcolor(), target);
  }

  // required .TECompareFunction depthCompare = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_depthcompare(), target);
  }

  // optional bool depthWrite = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_depthwrite(), target);
  }

  // optional .HmiScenegraph.TStencilMode stencilFrontFace = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::stencilfrontface(this),
        _Internal::stencilfrontface(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TStencilMode stencilBackFace = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::stencilbackface(this),
        _Internal::stencilbackface(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TScissorTest scissorTest = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::scissortest(this),
        _Internal::scissortest(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TRenderMode.TColorWrite colorWrite = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::colorwrite(this),
        _Internal::colorwrite(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderMode)
  return target;
}

size_t TRenderMode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TRenderMode)
  size_t total_size = 0;

  if (_internal_has_blending()) {
    // required .HmiScenegraph.TBlendMode blending = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.blending_);
  }

  if (_internal_has_depthcompare()) {
    // required .TECompareFunction depthCompare = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_depthcompare());
  }

  if (_internal_has_winding()) {
    // required .TEWinding winding = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_winding());
  }

  if (_internal_has_culling()) {
    // required .TEFace culling = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_culling());
  }

  return total_size;
}
size_t TRenderMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderMode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000381) ^ 0x00000381) == 0) {  // All required fields are present.
    // required .HmiScenegraph.TBlendMode blending = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.blending_);

    // required .TECompareFunction depthCompare = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_depthcompare());

    // required .TEWinding winding = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_winding());

    // required .TEFace culling = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_culling());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional .HmiScenegraph.TStencilMode stencilFrontFace = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stencilfrontface_);
    }

    // optional .HmiScenegraph.TStencilMode stencilBackFace = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stencilbackface_);
    }

    // optional .HmiScenegraph.TScissorTest scissorTest = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scissortest_);
    }

    // optional .HmiScenegraph.TRenderMode.TColorWrite colorWrite = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.colorwrite_);
    }

    // optional fixed32 blendColor = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional bool depthWrite = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderMode::GetClassData() const { return &_class_data_; }


void TRenderMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderMode*>(&to_msg);
  auto& from = static_cast<const TRenderMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_blending()->::HmiScenegraph::TBlendMode::MergeFrom(
          from._internal_blending());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stencilfrontface()->::HmiScenegraph::TStencilMode::MergeFrom(
          from._internal_stencilfrontface());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_stencilbackface()->::HmiScenegraph::TStencilMode::MergeFrom(
          from._internal_stencilbackface());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_scissortest()->::HmiScenegraph::TScissorTest::MergeFrom(
          from._internal_scissortest());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_colorwrite()->::HmiScenegraph::TRenderMode_TColorWrite::MergeFrom(
          from._internal_colorwrite());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.blendcolor_ = from._impl_.blendcolor_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.depthwrite_ = from._impl_.depthwrite_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.depthcompare_ = from._impl_.depthcompare_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.winding_ = from._impl_.winding_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.culling_ = from._impl_.culling_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderMode::CopyFrom(const TRenderMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderMode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_blending()) {
    if (!_impl_.blending_->IsInitialized()) return false;
  }
  if (_internal_has_stencilfrontface()) {
    if (!_impl_.stencilfrontface_->IsInitialized()) return false;
  }
  if (_internal_has_stencilbackface()) {
    if (!_impl_.stencilbackface_->IsInitialized()) return false;
  }
  if (_internal_has_scissortest()) {
    if (!_impl_.scissortest_->IsInitialized()) return false;
  }
  return true;
}

void TRenderMode::InternalSwap(TRenderMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TRenderMode, _impl_.depthwrite_)
      + sizeof(TRenderMode::_impl_.depthwrite_)
      - PROTOBUF_FIELD_OFFSET(TRenderMode, _impl_.blending_)>(
          reinterpret_cast<char*>(&_impl_.blending_),
          reinterpret_cast<char*>(&other->_impl_.blending_));
  swap(_impl_.depthcompare_, other->_impl_.depthcompare_);
  swap(_impl_.winding_, other->_impl_.winding_);
  swap(_impl_.culling_, other->_impl_.culling_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[7]);
}

// ===================================================================

class TAttributeMapping::_Internal {
 public:
  using HasBits = decltype(std::declval<TAttributeMapping>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TAttributeMapping, _impl_._has_bits_);
  static void set_has_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attributename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TAttributeMapping::TAttributeMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TAttributeMapping)
}
TAttributeMapping::TAttributeMapping(const TAttributeMapping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TAttributeMapping* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributename_){}
    , decltype(_impl_.usage_){}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.attributename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attributename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attributename()) {
    _this->_impl_.attributename_.Set(from._internal_attributename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.usage_, &from._impl_.usage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.index_) -
    reinterpret_cast<char*>(&_impl_.usage_)) + sizeof(_impl_.index_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TAttributeMapping)
}

inline void TAttributeMapping::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributename_){}
    , decltype(_impl_.usage_){0}
    , decltype(_impl_.index_){0u}
  };
  _impl_.attributename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attributename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TAttributeMapping::~TAttributeMapping() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TAttributeMapping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TAttributeMapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attributename_.Destroy();
}

void TAttributeMapping::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TAttributeMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TAttributeMapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attributename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.usage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.usage_)) + sizeof(_impl_.index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TAttributeMapping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .HmiScenegraph.TEAttributeUsage usage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributeUsage_IsValid(val))) {
            _internal_set_usage(static_cast<::HmiScenegraph::TEAttributeUsage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string attributeName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_attributename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TAttributeMapping.attributeName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TAttributeMapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TAttributeMapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .HmiScenegraph.TEAttributeUsage usage = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_usage(), target);
  }

  // optional uint32 index = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // required string attributeName = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_attributename().data(), static_cast<int>(this->_internal_attributename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TAttributeMapping.attributeName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_attributename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TAttributeMapping)
  return target;
}

size_t TAttributeMapping::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TAttributeMapping)
  size_t total_size = 0;

  if (_internal_has_attributename()) {
    // required string attributeName = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_attributename());
  }

  if (_internal_has_usage()) {
    // required .HmiScenegraph.TEAttributeUsage usage = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_usage());
  }

  return total_size;
}
size_t TAttributeMapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TAttributeMapping)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string attributeName = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_attributename());

    // required .HmiScenegraph.TEAttributeUsage usage = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_usage());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 index = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TAttributeMapping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TAttributeMapping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TAttributeMapping::GetClassData() const { return &_class_data_; }


void TAttributeMapping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TAttributeMapping*>(&to_msg);
  auto& from = static_cast<const TAttributeMapping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TAttributeMapping)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attributename(from._internal_attributename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.usage_ = from._impl_.usage_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TAttributeMapping::CopyFrom(const TAttributeMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TAttributeMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TAttributeMapping::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TAttributeMapping::InternalSwap(TAttributeMapping* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attributename_, lhs_arena,
      &other->_impl_.attributename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TAttributeMapping, _impl_.index_)
      + sizeof(TAttributeMapping::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(TAttributeMapping, _impl_.usage_)>(
          reinterpret_cast<char*>(&_impl_.usage_),
          reinterpret_cast<char*>(&other->_impl_.usage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TAttributeMapping::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[8]);
}

// ===================================================================

class TShader::_Internal {
 public:
  using HasBits = decltype(std::declval<TShader>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TShader, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TResourceCacheId& cacheid(const TShader* msg);
  static void set_has_cacheid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_vertexshader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fragmentshader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::HmiScenegraph::TResourceCacheId&
TShader::_Internal::cacheid(const TShader* msg) {
  return *msg->_impl_.cacheid_;
}
TShader::TShader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TShader)
}
TShader::TShader(const TShader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TShader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapping_){from._impl_.mapping_}
    , decltype(_impl_.compilerdefine_){from._impl_.compilerdefine_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.vertexshader_){}
    , decltype(_impl_.fragmentshader_){}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vertexshader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vertexshader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vertexshader()) {
    _this->_impl_.vertexshader_.Set(from._internal_vertexshader(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fragmentshader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fragmentshader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fragmentshader()) {
    _this->_impl_.fragmentshader_.Set(from._internal_fragmentshader(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cacheid()) {
    _this->_impl_.cacheid_ = new ::HmiScenegraph::TResourceCacheId(*from._impl_.cacheid_);
  }
  _this->_impl_.scope_ = from._impl_.scope_;
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TShader)
}

inline void TShader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapping_){arena}
    , decltype(_impl_.compilerdefine_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.vertexshader_){}
    , decltype(_impl_.fragmentshader_){}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.scope_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vertexshader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vertexshader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fragmentshader_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fragmentshader_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TShader::~TShader() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TShader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TShader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mapping_.~RepeatedPtrField();
  _impl_.compilerdefine_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.vertexshader_.Destroy();
  _impl_.fragmentshader_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cacheid_;
}

void TShader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TShader::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TShader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mapping_.Clear();
  _impl_.compilerdefine_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vertexshader_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.fragmentshader_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cacheid_ != nullptr);
      _impl_.cacheid_->Clear();
    }
    _impl_.scope_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TShader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TShader.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string vertexShader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vertexshader();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TShader.vertexShader");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string fragmentShader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_fragmentshader();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TShader.fragmentShader");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TAttributeMapping mapping = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mapping(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string compilerDefine = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_compilerdefine();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TShader.compilerDefine");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TResourceCacheId cacheId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_cacheid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TShader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TShader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TShader.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string vertexShader = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vertexshader().data(), static_cast<int>(this->_internal_vertexshader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TShader.vertexShader");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_vertexshader(), target);
  }

  // required string fragmentShader = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fragmentshader().data(), static_cast<int>(this->_internal_fragmentshader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TShader.fragmentShader");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_fragmentshader(), target);
  }

  // repeated .HmiScenegraph.TAttributeMapping mapping = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mapping_size()); i < n; i++) {
    const auto& repfield = this->_internal_mapping(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string compilerDefine = 5;
  for (int i = 0, n = this->_internal_compilerdefine_size(); i < n; i++) {
    const auto& s = this->_internal_compilerdefine(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TShader.compilerDefine");
    target = stream->WriteString(5, s, target);
  }

  // optional .TEScope scope = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_scope(), target);
  }

  // optional .HmiScenegraph.TResourceCacheId cacheId = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::cacheid(this),
        _Internal::cacheid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TShader)
  return target;
}

size_t TShader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TShader)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_vertexshader()) {
    // required string vertexShader = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vertexshader());
  }

  if (_internal_has_fragmentshader()) {
    // required string fragmentShader = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fragmentshader());
  }

  return total_size;
}
size_t TShader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TShader)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string vertexShader = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vertexshader());

    // required string fragmentShader = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fragmentshader());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TAttributeMapping mapping = 4;
  total_size += 1UL * this->_internal_mapping_size();
  for (const auto& msg : this->_impl_.mapping_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string compilerDefine = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.compilerdefine_.size());
  for (int i = 0, n = _impl_.compilerdefine_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.compilerdefine_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional .HmiScenegraph.TResourceCacheId cacheId = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cacheid_);
    }

    // optional .TEScope scope = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TShader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TShader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TShader::GetClassData() const { return &_class_data_; }


void TShader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TShader*>(&to_msg);
  auto& from = static_cast<const TShader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TShader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mapping_.MergeFrom(from._impl_.mapping_);
  _this->_impl_.compilerdefine_.MergeFrom(from._impl_.compilerdefine_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vertexshader(from._internal_vertexshader());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_fragmentshader(from._internal_fragmentshader());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cacheid()->::HmiScenegraph::TResourceCacheId::MergeFrom(
          from._internal_cacheid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TShader::CopyFrom(const TShader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TShader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TShader::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.mapping_))
    return false;
  return true;
}

void TShader::InternalSwap(TShader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mapping_.InternalSwap(&other->_impl_.mapping_);
  _impl_.compilerdefine_.InternalSwap(&other->_impl_.compilerdefine_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vertexshader_, lhs_arena,
      &other->_impl_.vertexshader_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fragmentshader_, lhs_arena,
      &other->_impl_.fragmentshader_, rhs_arena
  );
  swap(_impl_.cacheid_, other->_impl_.cacheid_);
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TShader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[9]);
}

// ===================================================================

class TBitmap_TCubeMapResource::_Internal {
 public:
  using HasBits = decltype(std::declval<TBitmap_TCubeMapResource>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBitmap_TCubeMapResource, _impl_._has_bits_);
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TBitmap_TCubeMapResource::TBitmap_TCubeMapResource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBitmap.TCubeMapResource)
}
TBitmap_TCubeMapResource::TBitmap_TCubeMapResource(const TBitmap_TCubeMapResource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBitmap_TCubeMapResource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mipmap_){from._impl_.mipmap_}
    , decltype(_impl_.resource_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resource()) {
    _this->_impl_.resource_.Set(from._internal_resource(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBitmap.TCubeMapResource)
}

inline void TBitmap_TCubeMapResource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mipmap_){arena}
    , decltype(_impl_.resource_){}
  };
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TBitmap_TCubeMapResource::~TBitmap_TCubeMapResource() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBitmap.TCubeMapResource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBitmap_TCubeMapResource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mipmap_.~RepeatedPtrField();
  _impl_.resource_.Destroy();
}

void TBitmap_TCubeMapResource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBitmap_TCubeMapResource::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBitmap.TCubeMapResource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mipmap_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.resource_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBitmap_TCubeMapResource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string resource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_resource();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBitmap.TCubeMapResource.resource");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string mipmap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mipmap();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBitmap.TCubeMapResource.mipmap");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBitmap_TCubeMapResource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBitmap.TCubeMapResource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string resource = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBitmap.TCubeMapResource.resource");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_resource(), target);
  }

  // repeated string mipmap = 2;
  for (int i = 0, n = this->_internal_mipmap_size(); i < n; i++) {
    const auto& s = this->_internal_mipmap(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBitmap.TCubeMapResource.mipmap");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBitmap.TCubeMapResource)
  return target;
}

size_t TBitmap_TCubeMapResource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBitmap.TCubeMapResource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string mipmap = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mipmap_.size());
  for (int i = 0, n = _impl_.mipmap_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.mipmap_.Get(i));
  }

  // optional string resource = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBitmap_TCubeMapResource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBitmap_TCubeMapResource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBitmap_TCubeMapResource::GetClassData() const { return &_class_data_; }


void TBitmap_TCubeMapResource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBitmap_TCubeMapResource*>(&to_msg);
  auto& from = static_cast<const TBitmap_TCubeMapResource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBitmap.TCubeMapResource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mipmap_.MergeFrom(from._impl_.mipmap_);
  if (from._internal_has_resource()) {
    _this->_internal_set_resource(from._internal_resource());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBitmap_TCubeMapResource::CopyFrom(const TBitmap_TCubeMapResource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBitmap.TCubeMapResource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBitmap_TCubeMapResource::IsInitialized() const {
  return true;
}

void TBitmap_TCubeMapResource::InternalSwap(TBitmap_TCubeMapResource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mipmap_.InternalSwap(&other->_impl_.mipmap_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resource_, lhs_arena,
      &other->_impl_.resource_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TBitmap_TCubeMapResource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[10]);
}

// ===================================================================

class TBitmap_TCubeMap::_Internal {
 public:
  using HasBits = decltype(std::declval<TBitmap_TCubeMap>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBitmap_TCubeMap, _impl_._has_bits_);
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& combined(const TBitmap_TCubeMap* msg);
  static void set_has_combined(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_x(const TBitmap_TCubeMap* msg);
  static void set_has_positive_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_x(const TBitmap_TCubeMap* msg);
  static void set_has_negative_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_y(const TBitmap_TCubeMap* msg);
  static void set_has_positive_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_y(const TBitmap_TCubeMap* msg);
  static void set_has_negative_y(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& positive_z(const TBitmap_TCubeMap* msg);
  static void set_has_positive_z(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMapResource& negative_z(const TBitmap_TCubeMap* msg);
  static void set_has_negative_z(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::combined(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.combined_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::positive_x(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.positive_x_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::negative_x(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.negative_x_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::positive_y(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.positive_y_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::negative_y(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.negative_y_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::positive_z(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.positive_z_;
}
const ::HmiScenegraph::TBitmap_TCubeMapResource&
TBitmap_TCubeMap::_Internal::negative_z(const TBitmap_TCubeMap* msg) {
  return *msg->_impl_.negative_z_;
}
TBitmap_TCubeMap::TBitmap_TCubeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBitmap.TCubeMap)
}
TBitmap_TCubeMap::TBitmap_TCubeMap(const TBitmap_TCubeMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBitmap_TCubeMap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.combined_){nullptr}
    , decltype(_impl_.positive_x_){nullptr}
    , decltype(_impl_.negative_x_){nullptr}
    , decltype(_impl_.positive_y_){nullptr}
    , decltype(_impl_.negative_y_){nullptr}
    , decltype(_impl_.positive_z_){nullptr}
    , decltype(_impl_.negative_z_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_combined()) {
    _this->_impl_.combined_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.combined_);
  }
  if (from._internal_has_positive_x()) {
    _this->_impl_.positive_x_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.positive_x_);
  }
  if (from._internal_has_negative_x()) {
    _this->_impl_.negative_x_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.negative_x_);
  }
  if (from._internal_has_positive_y()) {
    _this->_impl_.positive_y_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.positive_y_);
  }
  if (from._internal_has_negative_y()) {
    _this->_impl_.negative_y_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.negative_y_);
  }
  if (from._internal_has_positive_z()) {
    _this->_impl_.positive_z_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.positive_z_);
  }
  if (from._internal_has_negative_z()) {
    _this->_impl_.negative_z_ = new ::HmiScenegraph::TBitmap_TCubeMapResource(*from._impl_.negative_z_);
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBitmap.TCubeMap)
}

inline void TBitmap_TCubeMap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.combined_){nullptr}
    , decltype(_impl_.positive_x_){nullptr}
    , decltype(_impl_.negative_x_){nullptr}
    , decltype(_impl_.positive_y_){nullptr}
    , decltype(_impl_.negative_y_){nullptr}
    , decltype(_impl_.positive_z_){nullptr}
    , decltype(_impl_.negative_z_){nullptr}
  };
}

TBitmap_TCubeMap::~TBitmap_TCubeMap() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBitmap.TCubeMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBitmap_TCubeMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.combined_;
  if (this != internal_default_instance()) delete _impl_.positive_x_;
  if (this != internal_default_instance()) delete _impl_.negative_x_;
  if (this != internal_default_instance()) delete _impl_.positive_y_;
  if (this != internal_default_instance()) delete _impl_.negative_y_;
  if (this != internal_default_instance()) delete _impl_.positive_z_;
  if (this != internal_default_instance()) delete _impl_.negative_z_;
}

void TBitmap_TCubeMap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBitmap_TCubeMap::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBitmap.TCubeMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.combined_ != nullptr);
      _impl_.combined_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.positive_x_ != nullptr);
      _impl_.positive_x_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.negative_x_ != nullptr);
      _impl_.negative_x_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.positive_y_ != nullptr);
      _impl_.positive_y_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.negative_y_ != nullptr);
      _impl_.negative_y_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.positive_z_ != nullptr);
      _impl_.positive_z_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.negative_z_ != nullptr);
      _impl_.negative_z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBitmap_TCubeMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .HmiScenegraph.TBitmap.TCubeMapResource combined = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_combined(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_positive_x(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_x(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_positive_y(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_y(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_z = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_positive_z(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_z = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_z(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBitmap_TCubeMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBitmap.TCubeMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .HmiScenegraph.TBitmap.TCubeMapResource combined = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::combined(this),
        _Internal::combined(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::positive_x(this),
        _Internal::positive_x(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_x = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::negative_x(this),
        _Internal::negative_x(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_y = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::positive_y(this),
        _Internal::positive_y(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_y = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::negative_y(this),
        _Internal::negative_y(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_z = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::positive_z(this),
        _Internal::positive_z(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_z = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::negative_z(this),
        _Internal::negative_z(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBitmap.TCubeMap)
  return target;
}

size_t TBitmap_TCubeMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBitmap.TCubeMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .HmiScenegraph.TBitmap.TCubeMapResource combined = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.combined_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.positive_x_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_x = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.negative_x_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_y = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.positive_y_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_y = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.negative_y_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource positive_z = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.positive_z_);
    }

    // optional .HmiScenegraph.TBitmap.TCubeMapResource negative_z = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.negative_z_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBitmap_TCubeMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBitmap_TCubeMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBitmap_TCubeMap::GetClassData() const { return &_class_data_; }


void TBitmap_TCubeMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBitmap_TCubeMap*>(&to_msg);
  auto& from = static_cast<const TBitmap_TCubeMap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBitmap.TCubeMap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_combined()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_combined());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_positive_x()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_positive_x());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_negative_x()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_negative_x());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_positive_y()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_positive_y());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_negative_y()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_negative_y());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_positive_z()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_positive_z());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_negative_z()->::HmiScenegraph::TBitmap_TCubeMapResource::MergeFrom(
          from._internal_negative_z());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBitmap_TCubeMap::CopyFrom(const TBitmap_TCubeMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBitmap.TCubeMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBitmap_TCubeMap::IsInitialized() const {
  return true;
}

void TBitmap_TCubeMap::InternalSwap(TBitmap_TCubeMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBitmap_TCubeMap, _impl_.negative_z_)
      + sizeof(TBitmap_TCubeMap::_impl_.negative_z_)
      - PROTOBUF_FIELD_OFFSET(TBitmap_TCubeMap, _impl_.combined_)>(
          reinterpret_cast<char*>(&_impl_.combined_),
          reinterpret_cast<char*>(&other->_impl_.combined_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TBitmap_TCubeMap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[11]);
}

// ===================================================================

class TBitmap::_Internal {
 public:
  using HasBits = decltype(std::declval<TBitmap>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBitmap, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::HmiScenegraph::TResourceCacheId& cacheid(const TBitmap* msg);
  static void set_has_cacheid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_pixelformat(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_renderbufferaccessmode(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_semanticwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_semanticheight(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_semanticdepth(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_resolutionmultiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_generatemipmaps(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::HmiScenegraph::TBitmap_TCubeMap& cubemap(const TBitmap* msg);
  static void set_has_cubemap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::HmiScenegraph::TResourceCacheId&
TBitmap::_Internal::cacheid(const TBitmap* msg) {
  return *msg->_impl_.cacheid_;
}
const ::HmiScenegraph::TBitmap_TCubeMap&
TBitmap::_Internal::cubemap(const TBitmap* msg) {
  return *msg->_impl_.cubemap_;
}
TBitmap::TBitmap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBitmap)
}
TBitmap::TBitmap(const TBitmap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBitmap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mipmap_){from._impl_.mipmap_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.cubemap_){nullptr}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.samples_){}
    , decltype(_impl_.pixelformat_){}
    , decltype(_impl_.generatemipmaps_){}
    , decltype(_impl_.semanticwidth_){}
    , decltype(_impl_.semanticheight_){}
    , decltype(_impl_.semanticdepth_){}
    , decltype(_impl_.resolutionmultiplier_){}
    , decltype(_impl_.renderbufferaccessmode_){}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resource()) {
    _this->_impl_.resource_.Set(from._internal_resource(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cubemap()) {
    _this->_impl_.cubemap_ = new ::HmiScenegraph::TBitmap_TCubeMap(*from._impl_.cubemap_);
  }
  if (from._internal_has_cacheid()) {
    _this->_impl_.cacheid_ = new ::HmiScenegraph::TResourceCacheId(*from._impl_.cacheid_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scope_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.scope_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBitmap)
}

inline void TBitmap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mipmap_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.cubemap_){nullptr}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.depth_){0u}
    , decltype(_impl_.samples_){0u}
    , decltype(_impl_.pixelformat_){0}
    , decltype(_impl_.generatemipmaps_){false}
    , decltype(_impl_.semanticwidth_){0}
    , decltype(_impl_.semanticheight_){0}
    , decltype(_impl_.semanticdepth_){0}
    , decltype(_impl_.resolutionmultiplier_){0}
    , decltype(_impl_.renderbufferaccessmode_){0}
    , decltype(_impl_.scope_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TBitmap::~TBitmap() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBitmap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBitmap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mipmap_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.resource_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cubemap_;
  if (this != internal_default_instance()) delete _impl_.cacheid_;
}

void TBitmap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBitmap::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBitmap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mipmap_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.resource_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cubemap_ != nullptr);
      _impl_.cubemap_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cacheid_ != nullptr);
      _impl_.cacheid_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.depth_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.depth_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.samples_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.renderbufferaccessmode_) -
        reinterpret_cast<char*>(&_impl_.samples_)) + sizeof(_impl_.renderbufferaccessmode_));
  }
  _impl_.scope_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBitmap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBitmap.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string resource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resource();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBitmap.resource");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEBitmapType type = 3 [default = TEBitmapType_Resource];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEBitmapType_IsValid(val))) {
            _internal_set_type(static_cast<::HmiScenegraph::TEBitmapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 depth = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_depth(&has_bits);
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 samples = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_samples(&has_bits);
          _impl_.samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TEPixelFormat pixelFormat = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEPixelFormat_IsValid(val))) {
            _internal_set_pixelformat(static_cast<::TEPixelFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool generateMipmaps = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_generatemipmaps(&has_bits);
          _impl_.generatemipmaps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string mipmap = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mipmap();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBitmap.mipmap");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBitmap.TCubeMap cubemap = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_cubemap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticWidth = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticwidth(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticHeight = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticheight(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticDepth = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticdepth(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float resolutionMultiplier = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_resolutionmultiplier(&has_bits);
          _impl_.resolutionmultiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TResourceCacheId cacheId = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_cacheid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TERenderBufferAccessMode renderBufferAccessMode = 18 [default = TERenderBufferAccessMode_WriteOnly];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TERenderBufferAccessMode_IsValid(val))) {
            _internal_set_renderbufferaccessmode(static_cast<::HmiScenegraph::TERenderBufferAccessMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBitmap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBitmap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBitmap.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string resource = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBitmap.resource");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_resource(), target);
  }

  // optional .HmiScenegraph.TEBitmapType type = 3 [default = TEBitmapType_Resource];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional uint32 width = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_width(), target);
  }

  // optional uint32 height = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_height(), target);
  }

  // optional uint32 depth = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_depth(), target);
  }

  // optional uint32 samples = 7 [default = 0];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_samples(), target);
  }

  // optional .TEPixelFormat pixelFormat = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_pixelformat(), target);
  }

  // optional bool generateMipmaps = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_generatemipmaps(), target);
  }

  // repeated string mipmap = 10;
  for (int i = 0, n = this->_internal_mipmap_size(); i < n; i++) {
    const auto& s = this->_internal_mipmap(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBitmap.mipmap");
    target = stream->WriteString(10, s, target);
  }

  // optional .HmiScenegraph.TBitmap.TCubeMap cubemap = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::cubemap(this),
        _Internal::cubemap(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TESemanticValue semanticWidth = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_semanticwidth(), target);
  }

  // optional .HmiScenegraph.TESemanticValue semanticHeight = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_semanticheight(), target);
  }

  // optional .HmiScenegraph.TESemanticValue semanticDepth = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_semanticdepth(), target);
  }

  // optional float resolutionMultiplier = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_resolutionmultiplier(), target);
  }

  // optional .TEScope scope = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_scope(), target);
  }

  // optional .HmiScenegraph.TResourceCacheId cacheId = 17;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::cacheid(this),
        _Internal::cacheid(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TERenderBufferAccessMode renderBufferAccessMode = 18 [default = TERenderBufferAccessMode_WriteOnly];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_renderbufferaccessmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBitmap)
  return target;
}

size_t TBitmap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBitmap)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string mipmap = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mipmap_.size());
  for (int i = 0, n = _impl_.mipmap_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.mipmap_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string resource = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource());
    }

    // optional .HmiScenegraph.TBitmap.TCubeMap cubemap = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cubemap_);
    }

    // optional .HmiScenegraph.TResourceCacheId cacheId = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cacheid_);
    }

    // optional .HmiScenegraph.TEBitmapType type = 3 [default = TEBitmapType_Resource];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint32 width = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

    // optional uint32 depth = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_depth());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 samples = 7 [default = 0];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_samples());
    }

    // optional .TEPixelFormat pixelFormat = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pixelformat());
    }

    // optional bool generateMipmaps = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .HmiScenegraph.TESemanticValue semanticWidth = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticwidth());
    }

    // optional .HmiScenegraph.TESemanticValue semanticHeight = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticheight());
    }

    // optional .HmiScenegraph.TESemanticValue semanticDepth = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticdepth());
    }

    // optional float resolutionMultiplier = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional .HmiScenegraph.TERenderBufferAccessMode renderBufferAccessMode = 18 [default = TERenderBufferAccessMode_WriteOnly];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_renderbufferaccessmode());
    }

  }
  // optional .TEScope scope = 16;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBitmap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBitmap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBitmap::GetClassData() const { return &_class_data_; }


void TBitmap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBitmap*>(&to_msg);
  auto& from = static_cast<const TBitmap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBitmap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mipmap_.MergeFrom(from._impl_.mipmap_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_resource(from._internal_resource());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cubemap()->::HmiScenegraph::TBitmap_TCubeMap::MergeFrom(
          from._internal_cubemap());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cacheid()->::HmiScenegraph::TResourceCacheId::MergeFrom(
          from._internal_cacheid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.depth_ = from._impl_.depth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.samples_ = from._impl_.samples_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.pixelformat_ = from._impl_.pixelformat_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.generatemipmaps_ = from._impl_.generatemipmaps_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.semanticwidth_ = from._impl_.semanticwidth_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.semanticheight_ = from._impl_.semanticheight_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.semanticdepth_ = from._impl_.semanticdepth_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.resolutionmultiplier_ = from._impl_.resolutionmultiplier_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.renderbufferaccessmode_ = from._impl_.renderbufferaccessmode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_scope(from._internal_scope());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBitmap::CopyFrom(const TBitmap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBitmap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBitmap::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TBitmap::InternalSwap(TBitmap* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.mipmap_.InternalSwap(&other->_impl_.mipmap_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resource_, lhs_arena,
      &other->_impl_.resource_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBitmap, _impl_.renderbufferaccessmode_)
      + sizeof(TBitmap::_impl_.renderbufferaccessmode_)
      - PROTOBUF_FIELD_OFFSET(TBitmap, _impl_.cubemap_)>(
          reinterpret_cast<char*>(&_impl_.cubemap_),
          reinterpret_cast<char*>(&other->_impl_.cubemap_));
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TBitmap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[12]);
}

// ===================================================================

class TTexture::_Internal {
 public:
  using HasBits = decltype(std::declval<TTexture>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TTexture, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitmapreference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minfilter(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_magfilter(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_anisotropicsamples(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wrapmodeu(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_wrapmodev(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_uniformname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TTexture::TTexture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TTexture)
}
TTexture::TTexture(const TTexture& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TTexture* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.bitmapreference_){}
    , decltype(_impl_.uniformname_){}
    , decltype(_impl_.anisotropicsamples_){}
    , decltype(_impl_.minfilter_){}
    , decltype(_impl_.magfilter_){}
    , decltype(_impl_.wrapmodeu_){}
    , decltype(_impl_.wrapmodev_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.bitmapreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bitmapreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bitmapreference()) {
    _this->_impl_.bitmapreference_.Set(from._internal_bitmapreference(), 
      _this->GetArenaForAllocation());
  }
  _impl_.uniformname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uniformname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_uniformname()) {
    _this->_impl_.uniformname_.Set(from._internal_uniformname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.anisotropicsamples_, &from._impl_.anisotropicsamples_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.wrapmodev_) -
    reinterpret_cast<char*>(&_impl_.anisotropicsamples_)) + sizeof(_impl_.wrapmodev_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TTexture)
}

inline void TTexture::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.bitmapreference_){}
    , decltype(_impl_.uniformname_){}
    , decltype(_impl_.anisotropicsamples_){0}
    , decltype(_impl_.minfilter_){1}
    , decltype(_impl_.magfilter_){1}
    , decltype(_impl_.wrapmodeu_){1}
    , decltype(_impl_.wrapmodev_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bitmapreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bitmapreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uniformname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uniformname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TTexture::~TTexture() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TTexture)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TTexture::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.bitmapreference_.Destroy();
  _impl_.uniformname_.Destroy();
}

void TTexture::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TTexture::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TTexture)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bitmapreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.uniformname_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    _impl_.anisotropicsamples_ = 0;
    _impl_.minfilter_ = 1;
    _impl_.magfilter_ = 1;
    _impl_.wrapmodeu_ = 1;
    _impl_.wrapmodev_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TTexture::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TTexture.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string bitmapReference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bitmapreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TTexture.bitmapReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TETextureFilter minFilter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TETextureFilter_IsValid(val))) {
            _internal_set_minfilter(static_cast<::TETextureFilter>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TETextureFilter magFilter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TETextureFilter_IsValid(val))) {
            _internal_set_magfilter(static_cast<::TETextureFilter>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float anisotropicSamples = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_anisotropicsamples(&has_bits);
          _impl_.anisotropicsamples_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TETextureWrapMode wrapModeU = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TETextureWrapMode_IsValid(val))) {
            _internal_set_wrapmodeu(static_cast<::TETextureWrapMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TETextureWrapMode wrapModeV = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TETextureWrapMode_IsValid(val))) {
            _internal_set_wrapmodev(static_cast<::TETextureWrapMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string uniformName = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_uniformname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TTexture.uniformName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TTexture::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TTexture)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TTexture.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string bitmapReference = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_bitmapreference().data(), static_cast<int>(this->_internal_bitmapreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TTexture.bitmapReference");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bitmapreference(), target);
  }

  // optional .TETextureFilter minFilter = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_minfilter(), target);
  }

  // optional .TETextureFilter magFilter = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_magfilter(), target);
  }

  // optional float anisotropicSamples = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_anisotropicsamples(), target);
  }

  // optional .TETextureWrapMode wrapModeU = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_wrapmodeu(), target);
  }

  // optional .TETextureWrapMode wrapModeV = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_wrapmodev(), target);
  }

  // optional string uniformName = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_uniformname().data(), static_cast<int>(this->_internal_uniformname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TTexture.uniformName");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_uniformname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TTexture)
  return target;
}

size_t TTexture::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TTexture)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1 [deprecated = true];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_bitmapreference()) {
    // required string bitmapReference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bitmapreference());
  }

  return total_size;
}
size_t TTexture::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TTexture)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1 [deprecated = true];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string bitmapReference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bitmapreference());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000fcu) {
    // optional string uniformName = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_uniformname());
    }

    // optional float anisotropicSamples = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional .TETextureFilter minFilter = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_minfilter());
    }

    // optional .TETextureFilter magFilter = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_magfilter());
    }

    // optional .TETextureWrapMode wrapModeU = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wrapmodeu());
    }

    // optional .TETextureWrapMode wrapModeV = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wrapmodev());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TTexture::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TTexture::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TTexture::GetClassData() const { return &_class_data_; }


void TTexture::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TTexture*>(&to_msg);
  auto& from = static_cast<const TTexture&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TTexture)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bitmapreference(from._internal_bitmapreference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_uniformname(from._internal_uniformname());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.anisotropicsamples_ = from._impl_.anisotropicsamples_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.minfilter_ = from._impl_.minfilter_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.magfilter_ = from._impl_.magfilter_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.wrapmodeu_ = from._impl_.wrapmodeu_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.wrapmodev_ = from._impl_.wrapmodev_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TTexture::CopyFrom(const TTexture& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TTexture)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTexture::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TTexture::InternalSwap(TTexture* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bitmapreference_, lhs_arena,
      &other->_impl_.bitmapreference_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uniformname_, lhs_arena,
      &other->_impl_.uniformname_, rhs_arena
  );
  swap(_impl_.anisotropicsamples_, other->_impl_.anisotropicsamples_);
  swap(_impl_.minfilter_, other->_impl_.minfilter_);
  swap(_impl_.magfilter_, other->_impl_.magfilter_);
  swap(_impl_.wrapmodeu_, other->_impl_.wrapmodeu_);
  swap(_impl_.wrapmodev_, other->_impl_.wrapmodev_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TTexture::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[13]);
}

// ===================================================================

class TMaterial::_Internal {
 public:
  using HasBits = decltype(std::declval<TMaterial>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMaterial, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TRenderMode& rendermode(const TMaterial* msg);
  static void set_has_rendermode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shaderreference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::HmiScenegraph::TRenderMode&
TMaterial::_Internal::rendermode(const TMaterial* msg) {
  return *msg->_impl_.rendermode_;
}
TMaterial::TMaterial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TMaterial)
}
TMaterial::TMaterial(const TMaterial& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMaterial* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.texture_){from._impl_.texture_}
    , decltype(_impl_.uniform_){from._impl_.uniform_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.shaderreference_){}
    , decltype(_impl_.rendermode_){nullptr}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.shaderreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shaderreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shaderreference()) {
    _this->_impl_.shaderreference_.Set(from._internal_shaderreference(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rendermode()) {
    _this->_impl_.rendermode_ = new ::HmiScenegraph::TRenderMode(*from._impl_.rendermode_);
  }
  _this->_impl_.scope_ = from._impl_.scope_;
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TMaterial)
}

inline void TMaterial::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.texture_){arena}
    , decltype(_impl_.uniform_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.shaderreference_){}
    , decltype(_impl_.rendermode_){nullptr}
    , decltype(_impl_.scope_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.shaderreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shaderreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMaterial::~TMaterial() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TMaterial)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMaterial::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.texture_.~RepeatedPtrField();
  _impl_.uniform_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.shaderreference_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rendermode_;
}

void TMaterial::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMaterial::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TMaterial)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.texture_.Clear();
  _impl_.uniform_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.shaderreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rendermode_ != nullptr);
      _impl_.rendermode_->Clear();
    }
    _impl_.scope_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMaterial::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMaterial.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .HmiScenegraph.TRenderMode renderMode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendermode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string shaderReference = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_shaderreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMaterial.shaderReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TTexture texture = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_texture(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TUniform uniform = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uniform(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMaterial::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TMaterial)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMaterial.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required .HmiScenegraph.TRenderMode renderMode = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rendermode(this),
        _Internal::rendermode(this).GetCachedSize(), target, stream);
  }

  // required string shaderReference = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shaderreference().data(), static_cast<int>(this->_internal_shaderreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMaterial.shaderReference");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_shaderreference(), target);
  }

  // repeated .HmiScenegraph.TTexture texture = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_texture_size()); i < n; i++) {
    const auto& repfield = this->_internal_texture(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TEScope scope = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_scope(), target);
  }

  // repeated .HmiScenegraph.TUniform uniform = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uniform_size()); i < n; i++) {
    const auto& repfield = this->_internal_uniform(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TMaterial)
  return target;
}

size_t TMaterial::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TMaterial)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_shaderreference()) {
    // required string shaderReference = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shaderreference());
  }

  if (_internal_has_rendermode()) {
    // required .HmiScenegraph.TRenderMode renderMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rendermode_);
  }

  return total_size;
}
size_t TMaterial::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TMaterial)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string shaderReference = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shaderreference());

    // required .HmiScenegraph.TRenderMode renderMode = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rendermode_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TTexture texture = 4;
  total_size += 1UL * this->_internal_texture_size();
  for (const auto& msg : this->_impl_.texture_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TUniform uniform = 6;
  total_size += 1UL * this->_internal_uniform_size();
  for (const auto& msg : this->_impl_.uniform_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TEScope scope = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMaterial::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMaterial::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMaterial::GetClassData() const { return &_class_data_; }


void TMaterial::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMaterial*>(&to_msg);
  auto& from = static_cast<const TMaterial&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TMaterial)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.texture_.MergeFrom(from._impl_.texture_);
  _this->_impl_.uniform_.MergeFrom(from._impl_.uniform_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_shaderreference(from._internal_shaderreference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rendermode()->::HmiScenegraph::TRenderMode::MergeFrom(
          from._internal_rendermode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMaterial::CopyFrom(const TMaterial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TMaterial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMaterial::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.texture_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.uniform_))
    return false;
  if (_internal_has_rendermode()) {
    if (!_impl_.rendermode_->IsInitialized()) return false;
  }
  return true;
}

void TMaterial::InternalSwap(TMaterial* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.texture_.InternalSwap(&other->_impl_.texture_);
  _impl_.uniform_.InternalSwap(&other->_impl_.uniform_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.shaderreference_, lhs_arena,
      &other->_impl_.shaderreference_, rhs_arena
  );
  swap(_impl_.rendermode_, other->_impl_.rendermode_);
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMaterial::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[14]);
}

// ===================================================================

class TMesh_TAttributeParamteter::_Internal {
 public:
  using HasBits = decltype(std::declval<TMesh_TAttributeParamteter>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMesh_TAttributeParamteter, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMesh_TAttributeParamteter::TMesh_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TMesh.TAttributeParamteter)
}
TMesh_TAttributeParamteter::TMesh_TAttributeParamteter(const TMesh_TAttributeParamteter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMesh_TAttributeParamteter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.precision_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.precision_, &from._impl_.precision_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.precision_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TMesh.TAttributeParamteter)
}

inline void TMesh_TAttributeParamteter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.precision_){0}
    , decltype(_impl_.size_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMesh_TAttributeParamteter::~TMesh_TAttributeParamteter() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TMesh.TAttributeParamteter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMesh_TAttributeParamteter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void TMesh_TAttributeParamteter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMesh_TAttributeParamteter::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TMesh.TAttributeParamteter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.precision_ = 0;
    _impl_.size_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMesh_TAttributeParamteter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMesh.TAttributeParamteter.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAttributePrecision precision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributePrecision_IsValid(val))) {
            _internal_set_precision(static_cast<::HmiScenegraph::TEAttributePrecision>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAttributeSize size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributeSize_IsValid(val))) {
            _internal_set_size(static_cast<::HmiScenegraph::TEAttributeSize>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMesh_TAttributeParamteter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TMesh.TAttributeParamteter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMesh.TAttributeParamteter.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .HmiScenegraph.TEAttributePrecision precision = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_precision(), target);
  }

  // optional .HmiScenegraph.TEAttributeSize size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TMesh.TAttributeParamteter)
  return target;
}

size_t TMesh_TAttributeParamteter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TMesh.TAttributeParamteter)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .HmiScenegraph.TEAttributePrecision precision = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_precision());
    }

    // optional .HmiScenegraph.TEAttributeSize size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMesh_TAttributeParamteter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMesh_TAttributeParamteter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMesh_TAttributeParamteter::GetClassData() const { return &_class_data_; }


void TMesh_TAttributeParamteter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMesh_TAttributeParamteter*>(&to_msg);
  auto& from = static_cast<const TMesh_TAttributeParamteter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TMesh.TAttributeParamteter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.precision_ = from._impl_.precision_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMesh_TAttributeParamteter::CopyFrom(const TMesh_TAttributeParamteter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TMesh.TAttributeParamteter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMesh_TAttributeParamteter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TMesh_TAttributeParamteter::InternalSwap(TMesh_TAttributeParamteter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.precision_, other->_impl_.precision_);
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMesh_TAttributeParamteter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[15]);
}

// ===================================================================

class TMesh::_Internal {
 public:
  using HasBits = decltype(std::declval<TMesh>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TMesh, _impl_._has_bits_);
  static const ::HmiScenegraph::TNode& basenode(const TMesh* msg);
  static void set_has_basenode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_meshresource(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_meshreference(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_materialreference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

const ::HmiScenegraph::TNode&
TMesh::_Internal::basenode(const TMesh* msg) {
  return *msg->_impl_.basenode_;
}
TMesh::TMesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TMesh)
}
TMesh::TMesh(const TMesh& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMesh* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uniform_){from._impl_.uniform_}
    , decltype(_impl_.attributeparameter_){from._impl_.attributeparameter_}
    , decltype(_impl_.renderpassdependency_){from._impl_.renderpassdependency_}
    , decltype(_impl_.texture_){from._impl_.texture_}
    , decltype(_impl_.meshresource_){}
    , decltype(_impl_.materialreference_){}
    , decltype(_impl_.meshreference_){}
    , decltype(_impl_.basenode_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.meshresource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshresource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_meshresource()) {
    _this->_impl_.meshresource_.Set(from._internal_meshresource(), 
      _this->GetArenaForAllocation());
  }
  _impl_.materialreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_materialreference()) {
    _this->_impl_.materialreference_.Set(from._internal_materialreference(), 
      _this->GetArenaForAllocation());
  }
  _impl_.meshreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_meshreference()) {
    _this->_impl_.meshreference_.Set(from._internal_meshreference(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_basenode()) {
    _this->_impl_.basenode_ = new ::HmiScenegraph::TNode(*from._impl_.basenode_);
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TMesh)
}

inline void TMesh::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uniform_){arena}
    , decltype(_impl_.attributeparameter_){arena}
    , decltype(_impl_.renderpassdependency_){arena}
    , decltype(_impl_.texture_){arena}
    , decltype(_impl_.meshresource_){}
    , decltype(_impl_.materialreference_){}
    , decltype(_impl_.meshreference_){}
    , decltype(_impl_.basenode_){nullptr}
  };
  _impl_.meshresource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshresource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.materialreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.meshreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meshreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TMesh::~TMesh() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TMesh)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMesh::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uniform_.~RepeatedPtrField();
  _impl_.attributeparameter_.~RepeatedPtrField();
  _impl_.renderpassdependency_.~RepeatedPtrField();
  _impl_.texture_.~RepeatedPtrField();
  _impl_.meshresource_.Destroy();
  _impl_.materialreference_.Destroy();
  _impl_.meshreference_.Destroy();
  if (this != internal_default_instance()) delete _impl_.basenode_;
}

void TMesh::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMesh::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TMesh)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uniform_.Clear();
  _impl_.attributeparameter_.Clear();
  _impl_.renderpassdependency_.Clear();
  _impl_.texture_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.meshresource_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.materialreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.meshreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.basenode_ != nullptr);
      _impl_.basenode_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMesh::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .HmiScenegraph.TNode baseNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basenode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string meshResource = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_meshresource();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMesh.meshResource");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string materialReference = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_materialreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMesh.materialReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TUniform uniform = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uniform(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TMesh.TAttributeParamteter attributeParameter = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attributeparameter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string renderPassDependency = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_renderpassdependency();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMesh.renderPassDependency");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string meshReference = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_meshreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMesh.meshReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TTexture texture = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_texture(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMesh::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TMesh)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .HmiScenegraph.TNode baseNode = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::basenode(this),
        _Internal::basenode(this).GetCachedSize(), target, stream);
  }

  // required string meshResource = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_meshresource().data(), static_cast<int>(this->_internal_meshresource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMesh.meshResource");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_meshresource(), target);
  }

  // required string materialReference = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_materialreference().data(), static_cast<int>(this->_internal_materialreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMesh.materialReference");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_materialreference(), target);
  }

  // repeated .HmiScenegraph.TUniform uniform = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uniform_size()); i < n; i++) {
    const auto& repfield = this->_internal_uniform(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TMesh.TAttributeParamteter attributeParameter = 5 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributeparameter_size()); i < n; i++) {
    const auto& repfield = this->_internal_attributeparameter(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string renderPassDependency = 6;
  for (int i = 0, n = this->_internal_renderpassdependency_size(); i < n; i++) {
    const auto& s = this->_internal_renderpassdependency(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMesh.renderPassDependency");
    target = stream->WriteString(6, s, target);
  }

  // optional string meshReference = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_meshreference().data(), static_cast<int>(this->_internal_meshreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMesh.meshReference");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_meshreference(), target);
  }

  // repeated .HmiScenegraph.TTexture texture = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_texture_size()); i < n; i++) {
    const auto& repfield = this->_internal_texture(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TMesh)
  return target;
}

size_t TMesh::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TMesh)
  size_t total_size = 0;

  if (_internal_has_meshresource()) {
    // required string meshResource = 2 [deprecated = true];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meshresource());
  }

  if (_internal_has_materialreference()) {
    // required string materialReference = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_materialreference());
  }

  if (_internal_has_basenode()) {
    // required .HmiScenegraph.TNode baseNode = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.basenode_);
  }

  return total_size;
}
size_t TMesh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TMesh)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required string meshResource = 2 [deprecated = true];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meshresource());

    // required string materialReference = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_materialreference());

    // required .HmiScenegraph.TNode baseNode = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.basenode_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TUniform uniform = 4;
  total_size += 1UL * this->_internal_uniform_size();
  for (const auto& msg : this->_impl_.uniform_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TMesh.TAttributeParamteter attributeParameter = 5 [deprecated = true];
  total_size += 1UL * this->_internal_attributeparameter_size();
  for (const auto& msg : this->_impl_.attributeparameter_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string renderPassDependency = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.renderpassdependency_.size());
  for (int i = 0, n = _impl_.renderpassdependency_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.renderpassdependency_.Get(i));
  }

  // repeated .HmiScenegraph.TTexture texture = 8;
  total_size += 1UL * this->_internal_texture_size();
  for (const auto& msg : this->_impl_.texture_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string meshReference = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_meshreference());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMesh::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMesh::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMesh::GetClassData() const { return &_class_data_; }


void TMesh::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMesh*>(&to_msg);
  auto& from = static_cast<const TMesh&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TMesh)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uniform_.MergeFrom(from._impl_.uniform_);
  _this->_impl_.attributeparameter_.MergeFrom(from._impl_.attributeparameter_);
  _this->_impl_.renderpassdependency_.MergeFrom(from._impl_.renderpassdependency_);
  _this->_impl_.texture_.MergeFrom(from._impl_.texture_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_meshresource(from._internal_meshresource());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_materialreference(from._internal_materialreference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_meshreference(from._internal_meshreference());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_basenode()->::HmiScenegraph::TNode::MergeFrom(
          from._internal_basenode());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMesh::CopyFrom(const TMesh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TMesh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMesh::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.uniform_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.attributeparameter_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.texture_))
    return false;
  if (_internal_has_basenode()) {
    if (!_impl_.basenode_->IsInitialized()) return false;
  }
  return true;
}

void TMesh::InternalSwap(TMesh* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.uniform_.InternalSwap(&other->_impl_.uniform_);
  _impl_.attributeparameter_.InternalSwap(&other->_impl_.attributeparameter_);
  _impl_.renderpassdependency_.InternalSwap(&other->_impl_.renderpassdependency_);
  _impl_.texture_.InternalSwap(&other->_impl_.texture_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meshresource_, lhs_arena,
      &other->_impl_.meshresource_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.materialreference_, lhs_arena,
      &other->_impl_.materialreference_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.meshreference_, lhs_arena,
      &other->_impl_.meshreference_, rhs_arena
  );
  swap(_impl_.basenode_, other->_impl_.basenode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMesh::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[16]);
}

// ===================================================================

class TRenderLayer::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderLayer>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderLayer, _impl_._has_bits_);
  static const ::HmiScenegraph::TNode& basenode(const TRenderLayer* msg);
  static void set_has_basenode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_materialreference(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TRenderPass& renderpass(const TRenderLayer* msg);
  static void set_has_renderpass(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rendertargetscale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_boundingboxrootname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bordersize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::HmiScenegraph::TNode&
TRenderLayer::_Internal::basenode(const TRenderLayer* msg) {
  return *msg->_impl_.basenode_;
}
const ::HmiScenegraph::TRenderPass&
TRenderLayer::_Internal::renderpass(const TRenderLayer* msg) {
  return *msg->_impl_.renderpass_;
}
TRenderLayer::TRenderLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderLayer)
}
TRenderLayer::TRenderLayer(const TRenderLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uniform_){from._impl_.uniform_}
    , decltype(_impl_.child_){from._impl_.child_}
    , decltype(_impl_.materialreference_){}
    , decltype(_impl_.boundingboxrootname_){}
    , decltype(_impl_.basenode_){nullptr}
    , decltype(_impl_.renderpass_){nullptr}
    , decltype(_impl_.rendertargetscale_){}
    , decltype(_impl_.bordersize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.materialreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_materialreference()) {
    _this->_impl_.materialreference_.Set(from._internal_materialreference(), 
      _this->GetArenaForAllocation());
  }
  _impl_.boundingboxrootname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boundingboxrootname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_boundingboxrootname()) {
    _this->_impl_.boundingboxrootname_.Set(from._internal_boundingboxrootname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_basenode()) {
    _this->_impl_.basenode_ = new ::HmiScenegraph::TNode(*from._impl_.basenode_);
  }
  if (from._internal_has_renderpass()) {
    _this->_impl_.renderpass_ = new ::HmiScenegraph::TRenderPass(*from._impl_.renderpass_);
  }
  ::memcpy(&_impl_.rendertargetscale_, &from._impl_.rendertargetscale_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bordersize_) -
    reinterpret_cast<char*>(&_impl_.rendertargetscale_)) + sizeof(_impl_.bordersize_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderLayer)
}

inline void TRenderLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uniform_){arena}
    , decltype(_impl_.child_){arena}
    , decltype(_impl_.materialreference_){}
    , decltype(_impl_.boundingboxrootname_){}
    , decltype(_impl_.basenode_){nullptr}
    , decltype(_impl_.renderpass_){nullptr}
    , decltype(_impl_.rendertargetscale_){0}
    , decltype(_impl_.bordersize_){0}
  };
  _impl_.materialreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.materialreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.boundingboxrootname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.boundingboxrootname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TRenderLayer::~TRenderLayer() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uniform_.~RepeatedPtrField();
  _impl_.child_.~RepeatedPtrField();
  _impl_.materialreference_.Destroy();
  _impl_.boundingboxrootname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.basenode_;
  if (this != internal_default_instance()) delete _impl_.renderpass_;
}

void TRenderLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uniform_.Clear();
  _impl_.child_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.materialreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.boundingboxrootname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.basenode_ != nullptr);
      _impl_.basenode_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.renderpass_ != nullptr);
      _impl_.renderpass_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.rendertargetscale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bordersize_) -
        reinterpret_cast<char*>(&_impl_.rendertargetscale_)) + sizeof(_impl_.bordersize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .HmiScenegraph.TNode baseNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_basenode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string materialReference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_materialreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderLayer.materialReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TUniform uniform = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_uniform(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TRenderPass renderPass = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_renderpass(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float renderTargetScale = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_rendertargetscale(&has_bits);
          _impl_.rendertargetscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string boundingBoxRootName = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_boundingboxrootname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderLayer.boundingBoxRootName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 borderSize = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bordersize(&has_bits);
          _impl_.bordersize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TNode child = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_child(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .HmiScenegraph.TNode baseNode = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::basenode(this),
        _Internal::basenode(this).GetCachedSize(), target, stream);
  }

  // optional string materialReference = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_materialreference().data(), static_cast<int>(this->_internal_materialreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderLayer.materialReference");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_materialreference(), target);
  }

  // repeated .HmiScenegraph.TUniform uniform = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_uniform_size()); i < n; i++) {
    const auto& repfield = this->_internal_uniform(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TRenderPass renderPass = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::renderpass(this),
        _Internal::renderpass(this).GetCachedSize(), target, stream);
  }

  // optional float renderTargetScale = 5 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_rendertargetscale(), target);
  }

  // optional string boundingBoxRootName = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_boundingboxrootname().data(), static_cast<int>(this->_internal_boundingboxrootname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderLayer.boundingBoxRootName");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_boundingboxrootname(), target);
  }

  // optional int32 borderSize = 7 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_bordersize(), target);
  }

  // repeated .HmiScenegraph.TNode child = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_child_size()); i < n; i++) {
    const auto& repfield = this->_internal_child(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderLayer)
  return target;
}

size_t TRenderLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderLayer)
  size_t total_size = 0;

  // required .HmiScenegraph.TNode baseNode = 1;
  if (_internal_has_basenode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.basenode_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TUniform uniform = 3;
  total_size += 1UL * this->_internal_uniform_size();
  for (const auto& msg : this->_impl_.uniform_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TNode child = 8;
  total_size += 1UL * this->_internal_child_size();
  for (const auto& msg : this->_impl_.child_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string materialReference = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_materialreference());
    }

    // optional string boundingBoxRootName = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_boundingboxrootname());
    }

  }
  if (cached_has_bits & 0x00000038u) {
    // optional .HmiScenegraph.TRenderPass renderPass = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.renderpass_);
    }

    // optional float renderTargetScale = 5 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 borderSize = 7 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bordersize());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderLayer::GetClassData() const { return &_class_data_; }


void TRenderLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderLayer*>(&to_msg);
  auto& from = static_cast<const TRenderLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.uniform_.MergeFrom(from._impl_.uniform_);
  _this->_impl_.child_.MergeFrom(from._impl_.child_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_materialreference(from._internal_materialreference());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_boundingboxrootname(from._internal_boundingboxrootname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_basenode()->::HmiScenegraph::TNode::MergeFrom(
          from._internal_basenode());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_renderpass()->::HmiScenegraph::TRenderPass::MergeFrom(
          from._internal_renderpass());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rendertargetscale_ = from._impl_.rendertargetscale_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.bordersize_ = from._impl_.bordersize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderLayer::CopyFrom(const TRenderLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderLayer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.uniform_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.child_))
    return false;
  if (_internal_has_basenode()) {
    if (!_impl_.basenode_->IsInitialized()) return false;
  }
  if (_internal_has_renderpass()) {
    if (!_impl_.renderpass_->IsInitialized()) return false;
  }
  return true;
}

void TRenderLayer::InternalSwap(TRenderLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.uniform_.InternalSwap(&other->_impl_.uniform_);
  _impl_.child_.InternalSwap(&other->_impl_.child_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.materialreference_, lhs_arena,
      &other->_impl_.materialreference_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.boundingboxrootname_, lhs_arena,
      &other->_impl_.boundingboxrootname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TRenderLayer, _impl_.bordersize_)
      + sizeof(TRenderLayer::_impl_.bordersize_)
      - PROTOBUF_FIELD_OFFSET(TRenderLayer, _impl_.basenode_)>(
          reinterpret_cast<char*>(&_impl_.basenode_),
          reinterpret_cast<char*>(&other->_impl_.basenode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[17]);
}

// ===================================================================

class TBoundingVolume_TBoundingBox::_Internal {
 public:
  using HasBits = decltype(std::declval<TBoundingVolume_TBoundingBox>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingBox, _impl_._has_bits_);
  static const ::TVector3f& minbound(const TBoundingVolume_TBoundingBox* msg);
  static void set_has_minbound(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TVector3f& maxbound(const TBoundingVolume_TBoundingBox* msg);
  static void set_has_maxbound(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TVector3f&
TBoundingVolume_TBoundingBox::_Internal::minbound(const TBoundingVolume_TBoundingBox* msg) {
  return *msg->_impl_.minbound_;
}
const ::TVector3f&
TBoundingVolume_TBoundingBox::_Internal::maxbound(const TBoundingVolume_TBoundingBox* msg) {
  return *msg->_impl_.maxbound_;
}
void TBoundingVolume_TBoundingBox::clear_minbound() {
  if (_impl_.minbound_ != nullptr) _impl_.minbound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TBoundingVolume_TBoundingBox::clear_maxbound() {
  if (_impl_.maxbound_ != nullptr) _impl_.maxbound_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TBoundingVolume_TBoundingBox::TBoundingVolume_TBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBoundingVolume.TBoundingBox)
}
TBoundingVolume_TBoundingBox::TBoundingVolume_TBoundingBox(const TBoundingVolume_TBoundingBox& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBoundingVolume_TBoundingBox* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minbound_){nullptr}
    , decltype(_impl_.maxbound_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_minbound()) {
    _this->_impl_.minbound_ = new ::TVector3f(*from._impl_.minbound_);
  }
  if (from._internal_has_maxbound()) {
    _this->_impl_.maxbound_ = new ::TVector3f(*from._impl_.maxbound_);
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBoundingVolume.TBoundingBox)
}

inline void TBoundingVolume_TBoundingBox::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minbound_){nullptr}
    , decltype(_impl_.maxbound_){nullptr}
  };
}

TBoundingVolume_TBoundingBox::~TBoundingVolume_TBoundingBox() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBoundingVolume.TBoundingBox)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBoundingVolume_TBoundingBox::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.minbound_;
  if (this != internal_default_instance()) delete _impl_.maxbound_;
}

void TBoundingVolume_TBoundingBox::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBoundingVolume_TBoundingBox::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBoundingVolume.TBoundingBox)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.minbound_ != nullptr);
      _impl_.minbound_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.maxbound_ != nullptr);
      _impl_.maxbound_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBoundingVolume_TBoundingBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TVector3f minBound = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_minbound(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3f maxBound = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxbound(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBoundingVolume_TBoundingBox::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBoundingVolume.TBoundingBox)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TVector3f minBound = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::minbound(this),
        _Internal::minbound(this).GetCachedSize(), target, stream);
  }

  // optional .TVector3f maxBound = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::maxbound(this),
        _Internal::maxbound(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBoundingVolume.TBoundingBox)
  return target;
}

size_t TBoundingVolume_TBoundingBox::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBoundingVolume.TBoundingBox)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TVector3f minBound = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.minbound_);
    }

    // optional .TVector3f maxBound = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.maxbound_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBoundingVolume_TBoundingBox::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBoundingVolume_TBoundingBox::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBoundingVolume_TBoundingBox::GetClassData() const { return &_class_data_; }


void TBoundingVolume_TBoundingBox::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBoundingVolume_TBoundingBox*>(&to_msg);
  auto& from = static_cast<const TBoundingVolume_TBoundingBox&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBoundingVolume.TBoundingBox)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_minbound()->::TVector3f::MergeFrom(
          from._internal_minbound());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maxbound()->::TVector3f::MergeFrom(
          from._internal_maxbound());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBoundingVolume_TBoundingBox::CopyFrom(const TBoundingVolume_TBoundingBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBoundingVolume.TBoundingBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBoundingVolume_TBoundingBox::IsInitialized() const {
  if (_internal_has_minbound()) {
    if (!_impl_.minbound_->IsInitialized()) return false;
  }
  if (_internal_has_maxbound()) {
    if (!_impl_.maxbound_->IsInitialized()) return false;
  }
  return true;
}

void TBoundingVolume_TBoundingBox::InternalSwap(TBoundingVolume_TBoundingBox* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingBox, _impl_.maxbound_)
      + sizeof(TBoundingVolume_TBoundingBox::_impl_.maxbound_)
      - PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingBox, _impl_.minbound_)>(
          reinterpret_cast<char*>(&_impl_.minbound_),
          reinterpret_cast<char*>(&other->_impl_.minbound_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TBoundingVolume_TBoundingBox::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[18]);
}

// ===================================================================

class TBoundingVolume_TBoundingSphere::_Internal {
 public:
  using HasBits = decltype(std::declval<TBoundingVolume_TBoundingSphere>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingSphere, _impl_._has_bits_);
  static const ::TVector3f& centerposition(const TBoundingVolume_TBoundingSphere* msg);
  static void set_has_centerposition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TVector3f&
TBoundingVolume_TBoundingSphere::_Internal::centerposition(const TBoundingVolume_TBoundingSphere* msg) {
  return *msg->_impl_.centerposition_;
}
void TBoundingVolume_TBoundingSphere::clear_centerposition() {
  if (_impl_.centerposition_ != nullptr) _impl_.centerposition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TBoundingVolume_TBoundingSphere::TBoundingVolume_TBoundingSphere(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBoundingVolume.TBoundingSphere)
}
TBoundingVolume_TBoundingSphere::TBoundingVolume_TBoundingSphere(const TBoundingVolume_TBoundingSphere& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBoundingVolume_TBoundingSphere* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.centerposition_){nullptr}
    , decltype(_impl_.radius_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_centerposition()) {
    _this->_impl_.centerposition_ = new ::TVector3f(*from._impl_.centerposition_);
  }
  _this->_impl_.radius_ = from._impl_.radius_;
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBoundingVolume.TBoundingSphere)
}

inline void TBoundingVolume_TBoundingSphere::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.centerposition_){nullptr}
    , decltype(_impl_.radius_){0}
  };
}

TBoundingVolume_TBoundingSphere::~TBoundingVolume_TBoundingSphere() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBoundingVolume_TBoundingSphere::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.centerposition_;
}

void TBoundingVolume_TBoundingSphere::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBoundingVolume_TBoundingSphere::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.centerposition_ != nullptr);
    _impl_.centerposition_->Clear();
  }
  _impl_.radius_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBoundingVolume_TBoundingSphere::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TVector3f centerPosition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_centerposition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBoundingVolume_TBoundingSphere::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TVector3f centerPosition = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::centerposition(this),
        _Internal::centerposition(this).GetCachedSize(), target, stream);
  }

  // optional float radius = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  return target;
}

size_t TBoundingVolume_TBoundingSphere::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TVector3f centerPosition = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.centerposition_);
    }

    // optional float radius = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBoundingVolume_TBoundingSphere::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBoundingVolume_TBoundingSphere::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBoundingVolume_TBoundingSphere::GetClassData() const { return &_class_data_; }


void TBoundingVolume_TBoundingSphere::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBoundingVolume_TBoundingSphere*>(&to_msg);
  auto& from = static_cast<const TBoundingVolume_TBoundingSphere&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_centerposition()->::TVector3f::MergeFrom(
          from._internal_centerposition());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBoundingVolume_TBoundingSphere::CopyFrom(const TBoundingVolume_TBoundingSphere& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBoundingVolume.TBoundingSphere)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBoundingVolume_TBoundingSphere::IsInitialized() const {
  if (_internal_has_centerposition()) {
    if (!_impl_.centerposition_->IsInitialized()) return false;
  }
  return true;
}

void TBoundingVolume_TBoundingSphere::InternalSwap(TBoundingVolume_TBoundingSphere* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingSphere, _impl_.radius_)
      + sizeof(TBoundingVolume_TBoundingSphere::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(TBoundingVolume_TBoundingSphere, _impl_.centerposition_)>(
          reinterpret_cast<char*>(&_impl_.centerposition_),
          reinterpret_cast<char*>(&other->_impl_.centerposition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TBoundingVolume_TBoundingSphere::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[19]);
}

// ===================================================================

class TBoundingVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<TBoundingVolume>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBoundingVolume, _impl_._has_bits_);
  static const ::HmiScenegraph::TBoundingVolume_TBoundingBox& boundingbox(const TBoundingVolume* msg);
  static void set_has_boundingbox(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TBoundingVolume_TBoundingSphere& boundingsphere(const TBoundingVolume* msg);
  static void set_has_boundingsphere(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::HmiScenegraph::TBoundingVolume_TBoundingBox&
TBoundingVolume::_Internal::boundingbox(const TBoundingVolume* msg) {
  return *msg->_impl_.boundingbox_;
}
const ::HmiScenegraph::TBoundingVolume_TBoundingSphere&
TBoundingVolume::_Internal::boundingsphere(const TBoundingVolume* msg) {
  return *msg->_impl_.boundingsphere_;
}
TBoundingVolume::TBoundingVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBoundingVolume)
}
TBoundingVolume::TBoundingVolume(const TBoundingVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBoundingVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boundingbox_){nullptr}
    , decltype(_impl_.boundingsphere_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_boundingbox()) {
    _this->_impl_.boundingbox_ = new ::HmiScenegraph::TBoundingVolume_TBoundingBox(*from._impl_.boundingbox_);
  }
  if (from._internal_has_boundingsphere()) {
    _this->_impl_.boundingsphere_ = new ::HmiScenegraph::TBoundingVolume_TBoundingSphere(*from._impl_.boundingsphere_);
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBoundingVolume)
}

inline void TBoundingVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boundingbox_){nullptr}
    , decltype(_impl_.boundingsphere_){nullptr}
  };
}

TBoundingVolume::~TBoundingVolume() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBoundingVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBoundingVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.boundingbox_;
  if (this != internal_default_instance()) delete _impl_.boundingsphere_;
}

void TBoundingVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBoundingVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBoundingVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.boundingbox_ != nullptr);
      _impl_.boundingbox_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.boundingsphere_ != nullptr);
      _impl_.boundingsphere_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBoundingVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .HmiScenegraph.TBoundingVolume.TBoundingBox boundingBox = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundingbox(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBoundingVolume.TBoundingSphere boundingSphere = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundingsphere(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBoundingVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBoundingVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .HmiScenegraph.TBoundingVolume.TBoundingBox boundingBox = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::boundingbox(this),
        _Internal::boundingbox(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBoundingVolume.TBoundingSphere boundingSphere = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::boundingsphere(this),
        _Internal::boundingsphere(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBoundingVolume)
  return target;
}

size_t TBoundingVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBoundingVolume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .HmiScenegraph.TBoundingVolume.TBoundingBox boundingBox = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.boundingbox_);
    }

    // optional .HmiScenegraph.TBoundingVolume.TBoundingSphere boundingSphere = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.boundingsphere_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBoundingVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBoundingVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBoundingVolume::GetClassData() const { return &_class_data_; }


void TBoundingVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBoundingVolume*>(&to_msg);
  auto& from = static_cast<const TBoundingVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBoundingVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_boundingbox()->::HmiScenegraph::TBoundingVolume_TBoundingBox::MergeFrom(
          from._internal_boundingbox());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_boundingsphere()->::HmiScenegraph::TBoundingVolume_TBoundingSphere::MergeFrom(
          from._internal_boundingsphere());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBoundingVolume::CopyFrom(const TBoundingVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBoundingVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBoundingVolume::IsInitialized() const {
  if (_internal_has_boundingbox()) {
    if (!_impl_.boundingbox_->IsInitialized()) return false;
  }
  if (_internal_has_boundingsphere()) {
    if (!_impl_.boundingsphere_->IsInitialized()) return false;
  }
  return true;
}

void TBoundingVolume::InternalSwap(TBoundingVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBoundingVolume, _impl_.boundingsphere_)
      + sizeof(TBoundingVolume::_impl_.boundingsphere_)
      - PROTOBUF_FIELD_OFFSET(TBoundingVolume, _impl_.boundingbox_)>(
          reinterpret_cast<char*>(&_impl_.boundingbox_),
          reinterpret_cast<char*>(&other->_impl_.boundingbox_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TBoundingVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[20]);
}

// ===================================================================

class TNode_TRenderPassName::_Internal {
 public:
  using HasBits = decltype(std::declval<TNode_TRenderPassName>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TNode_TRenderPassName, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TNode_TRenderPassName::TNode_TRenderPassName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TNode.TRenderPassName)
}
TNode_TRenderPassName::TNode_TRenderPassName(const TNode_TRenderPassName& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TNode_TRenderPassName* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TNode.TRenderPassName)
}

inline void TNode_TRenderPassName::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.enabled_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TNode_TRenderPassName::~TNode_TRenderPassName() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TNode.TRenderPassName)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TNode_TRenderPassName::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void TNode_TRenderPassName::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TNode_TRenderPassName::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TNode.TRenderPassName)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TNode_TRenderPassName::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TNode.TRenderPassName.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TNode_TRenderPassName::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TNode.TRenderPassName)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TNode.TRenderPassName.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool enabled = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TNode.TRenderPassName)
  return target;
}

size_t TNode_TRenderPassName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TNode.TRenderPassName)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool enabled = 2 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TNode_TRenderPassName::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TNode_TRenderPassName::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TNode_TRenderPassName::GetClassData() const { return &_class_data_; }


void TNode_TRenderPassName::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TNode_TRenderPassName*>(&to_msg);
  auto& from = static_cast<const TNode_TRenderPassName&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TNode.TRenderPassName)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TNode_TRenderPassName::CopyFrom(const TNode_TRenderPassName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TNode.TRenderPassName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TNode_TRenderPassName::IsInitialized() const {
  return true;
}

void TNode_TRenderPassName::InternalSwap(TNode_TRenderPassName* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TNode_TRenderPassName::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[21]);
}

// ===================================================================

class TNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TNode>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TNode, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_renderorder(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_childsortorderrank(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TVector3f& scale(const TNode* msg);
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TVector3f& rotation(const TNode* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TVector3f& translation(const TNode* msg);
  static void set_has_translation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TMatrix4x4f& transformation(const TNode* msg);
  static void set_has_transformation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::HmiScenegraph::TCamera& camera(const TNode* msg);
  static void set_has_camera(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_lookattargetname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TVector3f& lookatupvector(const TNode* msg);
  static void set_has_lookatupvector(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_lookatupaxis(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_lookatforwardaxis(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_lookataligntotargetaxis(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_renderpassname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_renderpassenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::HmiScenegraph::TBoundingVolume& boundingvolume(const TNode* msg);
  static void set_has_boundingvolume(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TIdentifier& renderorderbin(const TNode* msg);
  static void set_has_renderorderbin(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000038) ^ 0x00000038) != 0;
  }
};

const ::TVector3f&
TNode::_Internal::scale(const TNode* msg) {
  return *msg->_impl_.scale_;
}
const ::TVector3f&
TNode::_Internal::rotation(const TNode* msg) {
  return *msg->_impl_.rotation_;
}
const ::TVector3f&
TNode::_Internal::translation(const TNode* msg) {
  return *msg->_impl_.translation_;
}
const ::TMatrix4x4f&
TNode::_Internal::transformation(const TNode* msg) {
  return *msg->_impl_.transformation_;
}
const ::HmiScenegraph::TCamera&
TNode::_Internal::camera(const TNode* msg) {
  return *msg->_impl_.camera_;
}
const ::TVector3f&
TNode::_Internal::lookatupvector(const TNode* msg) {
  return *msg->_impl_.lookatupvector_;
}
const ::HmiScenegraph::TBoundingVolume&
TNode::_Internal::boundingvolume(const TNode* msg) {
  return *msg->_impl_.boundingvolume_;
}
const ::TIdentifier&
TNode::_Internal::renderorderbin(const TNode* msg) {
  return *msg->_impl_.renderorderbin_;
}
void TNode::clear_scale() {
  if (_impl_.scale_ != nullptr) _impl_.scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TNode::clear_rotation() {
  if (_impl_.rotation_ != nullptr) _impl_.rotation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void TNode::clear_translation() {
  if (_impl_.translation_ != nullptr) _impl_.translation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void TNode::clear_transformation() {
  if (_impl_.transformation_ != nullptr) _impl_.transformation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void TNode::clear_lookatupvector() {
  if (_impl_.lookatupvector_ != nullptr) _impl_.lookatupvector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void TNode::clear_renderorderbin() {
  if (_impl_.renderorderbin_ != nullptr) _impl_.renderorderbin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
TNode::TNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TNode)
}
TNode::TNode(const TNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_){from._impl_.child_}
    , decltype(_impl_.mesh_){from._impl_.mesh_}
    , decltype(_impl_.renderlayer_){from._impl_.renderlayer_}
    , decltype(_impl_.renderpassnameext_){from._impl_.renderpassnameext_}
    , decltype(_impl_.renderpass_){from._impl_.renderpass_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.lookattargetname_){}
    , decltype(_impl_.renderpassname_){}
    , decltype(_impl_.scale_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , decltype(_impl_.transformation_){nullptr}
    , decltype(_impl_.camera_){nullptr}
    , decltype(_impl_.lookatupvector_){nullptr}
    , decltype(_impl_.renderorderbin_){nullptr}
    , decltype(_impl_.boundingvolume_){nullptr}
    , decltype(_impl_.renderorder_){}
    , decltype(_impl_.childsortorderrank_){}
    , decltype(_impl_.lookatupaxis_){}
    , decltype(_impl_.lookatforwardaxis_){}
    , decltype(_impl_.lookataligntotargetaxis_){}
    , decltype(_impl_.renderpassenabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lookattargetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lookattargetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lookattargetname()) {
    _this->_impl_.lookattargetname_.Set(from._internal_lookattargetname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.renderpassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.renderpassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_renderpassname()) {
    _this->_impl_.renderpassname_.Set(from._internal_renderpassname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_scale()) {
    _this->_impl_.scale_ = new ::TVector3f(*from._impl_.scale_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::TVector3f(*from._impl_.rotation_);
  }
  if (from._internal_has_translation()) {
    _this->_impl_.translation_ = new ::TVector3f(*from._impl_.translation_);
  }
  if (from._internal_has_transformation()) {
    _this->_impl_.transformation_ = new ::TMatrix4x4f(*from._impl_.transformation_);
  }
  if (from._internal_has_camera()) {
    _this->_impl_.camera_ = new ::HmiScenegraph::TCamera(*from._impl_.camera_);
  }
  if (from._internal_has_lookatupvector()) {
    _this->_impl_.lookatupvector_ = new ::TVector3f(*from._impl_.lookatupvector_);
  }
  if (from._internal_has_renderorderbin()) {
    _this->_impl_.renderorderbin_ = new ::TIdentifier(*from._impl_.renderorderbin_);
  }
  if (from._internal_has_boundingvolume()) {
    _this->_impl_.boundingvolume_ = new ::HmiScenegraph::TBoundingVolume(*from._impl_.boundingvolume_);
  }
  ::memcpy(&_impl_.renderorder_, &from._impl_.renderorder_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.renderpassenabled_) -
    reinterpret_cast<char*>(&_impl_.renderorder_)) + sizeof(_impl_.renderpassenabled_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TNode)
}

inline void TNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_){arena}
    , decltype(_impl_.mesh_){arena}
    , decltype(_impl_.renderlayer_){arena}
    , decltype(_impl_.renderpassnameext_){arena}
    , decltype(_impl_.renderpass_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.lookattargetname_){}
    , decltype(_impl_.renderpassname_){}
    , decltype(_impl_.scale_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.translation_){nullptr}
    , decltype(_impl_.transformation_){nullptr}
    , decltype(_impl_.camera_){nullptr}
    , decltype(_impl_.lookatupvector_){nullptr}
    , decltype(_impl_.renderorderbin_){nullptr}
    , decltype(_impl_.boundingvolume_){nullptr}
    , decltype(_impl_.renderorder_){0}
    , decltype(_impl_.childsortorderrank_){0}
    , decltype(_impl_.lookatupaxis_){0}
    , decltype(_impl_.lookatforwardaxis_){0}
    , decltype(_impl_.lookataligntotargetaxis_){0}
    , decltype(_impl_.renderpassenabled_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lookattargetname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lookattargetname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.renderpassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.renderpassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TNode::~TNode() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.child_.~RepeatedPtrField();
  _impl_.mesh_.~RepeatedPtrField();
  _impl_.renderlayer_.~RepeatedPtrField();
  _impl_.renderpassnameext_.~RepeatedPtrField();
  _impl_.renderpass_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.lookattargetname_.Destroy();
  _impl_.renderpassname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.scale_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.translation_;
  if (this != internal_default_instance()) delete _impl_.transformation_;
  if (this != internal_default_instance()) delete _impl_.camera_;
  if (this != internal_default_instance()) delete _impl_.lookatupvector_;
  if (this != internal_default_instance()) delete _impl_.renderorderbin_;
  if (this != internal_default_instance()) delete _impl_.boundingvolume_;
}

void TNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TNode::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.child_.Clear();
  _impl_.mesh_.Clear();
  _impl_.renderlayer_.Clear();
  _impl_.renderpassnameext_.Clear();
  _impl_.renderpass_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.lookattargetname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.renderpassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.scale_ != nullptr);
      _impl_.scale_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.translation_ != nullptr);
      _impl_.translation_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.transformation_ != nullptr);
      _impl_.transformation_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.camera_ != nullptr);
      _impl_.camera_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.lookatupvector_ != nullptr);
      _impl_.lookatupvector_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.renderorderbin_ != nullptr);
      _impl_.renderorderbin_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.boundingvolume_ != nullptr);
      _impl_.boundingvolume_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f800u) {
    ::memset(&_impl_.renderorder_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lookataligntotargetaxis_) -
        reinterpret_cast<char*>(&_impl_.renderorder_)) + sizeof(_impl_.lookataligntotargetaxis_));
  }
  _impl_.renderpassenabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TNode.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 renderOrder = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_renderorder(&has_bits);
          _impl_.renderorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 childSortOrderRank = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_childsortorderrank(&has_bits);
          _impl_.childsortorderrank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TVector3f scale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TVector3f rotation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TVector3f translation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_translation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TMatrix4x4f transformation = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TNode child = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_child(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TMesh mesh = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mesh(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TCamera camera = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderLayer renderLayer = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_renderlayer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string lookAtTargetName = 14 [deprecated = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_lookattargetname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TNode.lookAtTargetName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TVector3f lookAtUpVector = 15 [deprecated = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_lookatupvector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAxis lookAtUpAxis = 16 [deprecated = true];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAxis_IsValid(val))) {
            _internal_set_lookatupaxis(static_cast<::HmiScenegraph::TEAxis>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAxis lookAtForwardAxis = 17 [deprecated = true];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAxis_IsValid(val))) {
            _internal_set_lookatforwardaxis(static_cast<::HmiScenegraph::TEAxis>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAxis lookAtAlignToTargetAxis = 18 [deprecated = true];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAxis_IsValid(val))) {
            _internal_set_lookataligntotargetaxis(static_cast<::HmiScenegraph::TEAxis>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string renderPassName = 19 [deprecated = true];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_renderpassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TNode.renderPassName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool renderPassEnabled = 20 [default = false, deprecated = true];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_renderpassenabled(&has_bits);
          _impl_.renderpassenabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TNode.TRenderPassName renderPassNameEXT = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_renderpassnameext(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TIdentifier renderOrderBin = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_renderorderbin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TBoundingVolume boundingVolume = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundingvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderPass renderPass = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_renderpass(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TNode.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 renderOrder = 2;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_renderorder(), target);
  }

  // optional int32 childSortOrderRank = 3;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_childsortorderrank(), target);
  }

  // required .TVector3f scale = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::scale(this),
        _Internal::scale(this).GetCachedSize(), target, stream);
  }

  // required .TVector3f rotation = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // required .TVector3f translation = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::translation(this),
        _Internal::translation(this).GetCachedSize(), target, stream);
  }

  // optional .TMatrix4x4f transformation = 7 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::transformation(this),
        _Internal::transformation(this).GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TNode child = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_child_size()); i < n; i++) {
    const auto& repfield = this->_internal_child(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TMesh mesh = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mesh_size()); i < n; i++) {
    const auto& repfield = this->_internal_mesh(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TCamera camera = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::camera(this),
        _Internal::camera(this).GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TRenderLayer renderLayer = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderlayer_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderlayer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string lookAtTargetName = 14 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_lookattargetname().data(), static_cast<int>(this->_internal_lookattargetname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TNode.lookAtTargetName");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_lookattargetname(), target);
  }

  // optional .TVector3f lookAtUpVector = 15 [deprecated = true];
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::lookatupvector(this),
        _Internal::lookatupvector(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TEAxis lookAtUpAxis = 16 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_lookatupaxis(), target);
  }

  // optional .HmiScenegraph.TEAxis lookAtForwardAxis = 17 [deprecated = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      17, this->_internal_lookatforwardaxis(), target);
  }

  // optional .HmiScenegraph.TEAxis lookAtAlignToTargetAxis = 18 [deprecated = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_lookataligntotargetaxis(), target);
  }

  // optional string renderPassName = 19 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_renderpassname().data(), static_cast<int>(this->_internal_renderpassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TNode.renderPassName");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_renderpassname(), target);
  }

  // optional bool renderPassEnabled = 20 [default = false, deprecated = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_renderpassenabled(), target);
  }

  // repeated .HmiScenegraph.TNode.TRenderPassName renderPassNameEXT = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderpassnameext_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderpassnameext(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TIdentifier renderOrderBin = 22;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::renderorderbin(this),
        _Internal::renderorderbin(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TBoundingVolume boundingVolume = 23;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::boundingvolume(this),
        _Internal::boundingvolume(this).GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TRenderPass renderPass = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderpass_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderpass(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TNode)
  return target;
}

size_t TNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:HmiScenegraph.TNode)
  size_t total_size = 0;

  if (_internal_has_scale()) {
    // required .TVector3f scale = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scale_);
  }

  if (_internal_has_rotation()) {
    // required .TVector3f rotation = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  if (_internal_has_translation()) {
    // required .TVector3f translation = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.translation_);
  }

  return total_size;
}
size_t TNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TNode)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000038) ^ 0x00000038) == 0) {  // All required fields are present.
    // required .TVector3f scale = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scale_);

    // required .TVector3f rotation = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);

    // required .TVector3f translation = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.translation_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TNode child = 10;
  total_size += 1UL * this->_internal_child_size();
  for (const auto& msg : this->_impl_.child_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TMesh mesh = 11;
  total_size += 1UL * this->_internal_mesh_size();
  for (const auto& msg : this->_impl_.mesh_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TRenderLayer renderLayer = 13;
  total_size += 1UL * this->_internal_renderlayer_size();
  for (const auto& msg : this->_impl_.renderlayer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TNode.TRenderPassName renderPassNameEXT = 21;
  total_size += 2UL * this->_internal_renderpassnameext_size();
  for (const auto& msg : this->_impl_.renderpassnameext_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TRenderPass renderPass = 24;
  total_size += 2UL * this->_internal_renderpass_size();
  for (const auto& msg : this->_impl_.renderpass_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string lookAtTargetName = 14 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lookattargetname());
    }

    // optional string renderPassName = 19 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_renderpassname());
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional .TMatrix4x4f transformation = 7 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transformation_);
    }

    // optional .HmiScenegraph.TCamera camera = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.camera_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TVector3f lookAtUpVector = 15 [deprecated = true];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lookatupvector_);
    }

    // optional .TIdentifier renderOrderBin = 22;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.renderorderbin_);
    }

    // optional .HmiScenegraph.TBoundingVolume boundingVolume = 23;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.boundingvolume_);
    }

    // optional int32 renderOrder = 2;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_renderorder());
    }

    // optional int32 childSortOrderRank = 3;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_childsortorderrank());
    }

    // optional .HmiScenegraph.TEAxis lookAtUpAxis = 16 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lookatupaxis());
    }

    // optional .HmiScenegraph.TEAxis lookAtForwardAxis = 17 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lookatforwardaxis());
    }

    // optional .HmiScenegraph.TEAxis lookAtAlignToTargetAxis = 18 [deprecated = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_lookataligntotargetaxis());
    }

  }
  // optional bool renderPassEnabled = 20 [default = false, deprecated = true];
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TNode::GetClassData() const { return &_class_data_; }


void TNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TNode*>(&to_msg);
  auto& from = static_cast<const TNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.child_.MergeFrom(from._impl_.child_);
  _this->_impl_.mesh_.MergeFrom(from._impl_.mesh_);
  _this->_impl_.renderlayer_.MergeFrom(from._impl_.renderlayer_);
  _this->_impl_.renderpassnameext_.MergeFrom(from._impl_.renderpassnameext_);
  _this->_impl_.renderpass_.MergeFrom(from._impl_.renderpass_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_lookattargetname(from._internal_lookattargetname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_renderpassname(from._internal_renderpassname());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_scale()->::TVector3f::MergeFrom(
          from._internal_scale());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_rotation()->::TVector3f::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_translation()->::TVector3f::MergeFrom(
          from._internal_translation());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_transformation()->::TMatrix4x4f::MergeFrom(
          from._internal_transformation());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_camera()->::HmiScenegraph::TCamera::MergeFrom(
          from._internal_camera());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_lookatupvector()->::TVector3f::MergeFrom(
          from._internal_lookatupvector());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_renderorderbin()->::TIdentifier::MergeFrom(
          from._internal_renderorderbin());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_boundingvolume()->::HmiScenegraph::TBoundingVolume::MergeFrom(
          from._internal_boundingvolume());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.renderorder_ = from._impl_.renderorder_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.childsortorderrank_ = from._impl_.childsortorderrank_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.lookatupaxis_ = from._impl_.lookatupaxis_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.lookatforwardaxis_ = from._impl_.lookatforwardaxis_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.lookataligntotargetaxis_ = from._impl_.lookataligntotargetaxis_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_renderpassenabled(from._internal_renderpassenabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TNode::CopyFrom(const TNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.child_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.mesh_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.renderlayer_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.renderpass_))
    return false;
  if (_internal_has_scale()) {
    if (!_impl_.scale_->IsInitialized()) return false;
  }
  if (_internal_has_rotation()) {
    if (!_impl_.rotation_->IsInitialized()) return false;
  }
  if (_internal_has_translation()) {
    if (!_impl_.translation_->IsInitialized()) return false;
  }
  if (_internal_has_camera()) {
    if (!_impl_.camera_->IsInitialized()) return false;
  }
  if (_internal_has_lookatupvector()) {
    if (!_impl_.lookatupvector_->IsInitialized()) return false;
  }
  if (_internal_has_boundingvolume()) {
    if (!_impl_.boundingvolume_->IsInitialized()) return false;
  }
  return true;
}

void TNode::InternalSwap(TNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.child_.InternalSwap(&other->_impl_.child_);
  _impl_.mesh_.InternalSwap(&other->_impl_.mesh_);
  _impl_.renderlayer_.InternalSwap(&other->_impl_.renderlayer_);
  _impl_.renderpassnameext_.InternalSwap(&other->_impl_.renderpassnameext_);
  _impl_.renderpass_.InternalSwap(&other->_impl_.renderpass_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lookattargetname_, lhs_arena,
      &other->_impl_.lookattargetname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.renderpassname_, lhs_arena,
      &other->_impl_.renderpassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TNode, _impl_.renderpassenabled_)
      + sizeof(TNode::_impl_.renderpassenabled_)
      - PROTOBUF_FIELD_OFFSET(TNode, _impl_.scale_)>(
          reinterpret_cast<char*>(&_impl_.scale_),
          reinterpret_cast<char*>(&other->_impl_.scale_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[22]);
}

// ===================================================================

class TRenderOrder::_Internal {
 public:
};

TRenderOrder::TRenderOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderOrder)
}
TRenderOrder::TRenderOrder(const TRenderOrder& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  TRenderOrder* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderOrder)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderOrder::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderOrder::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata TRenderOrder::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[23]);
}

// ===================================================================

class TRenderOrderBin::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderOrderBin>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderOrderBin, _impl_._has_bits_);
  static const ::TIdentifier& name(const TRenderOrderBin* msg);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_renderorderrank(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sortorder(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TIdentifier&
TRenderOrderBin::_Internal::name(const TRenderOrderBin* msg) {
  return *msg->_impl_.name_;
}
void TRenderOrderBin::clear_name() {
  if (_impl_.name_ != nullptr) _impl_.name_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TRenderOrderBin::TRenderOrderBin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderOrderBin)
}
TRenderOrderBin::TRenderOrderBin(const TRenderOrderBin& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderOrderBin* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){nullptr}
    , decltype(_impl_.renderorderrank_){}
    , decltype(_impl_.sortorder_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_name()) {
    _this->_impl_.name_ = new ::TIdentifier(*from._impl_.name_);
  }
  ::memcpy(&_impl_.renderorderrank_, &from._impl_.renderorderrank_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sortorder_) -
    reinterpret_cast<char*>(&_impl_.renderorderrank_)) + sizeof(_impl_.sortorder_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderOrderBin)
}

inline void TRenderOrderBin::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){nullptr}
    , decltype(_impl_.renderorderrank_){0}
    , decltype(_impl_.sortorder_){0}
  };
}

TRenderOrderBin::~TRenderOrderBin() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderOrderBin)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderOrderBin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.name_;
}

void TRenderOrderBin::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderOrderBin::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderOrderBin)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.name_ != nullptr);
    _impl_.name_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.renderorderrank_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sortorder_) -
        reinterpret_cast<char*>(&_impl_.renderorderrank_)) + sizeof(_impl_.sortorder_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderOrderBin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TIdentifier name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 renderOrderRank = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_renderorderrank(&has_bits);
          _impl_.renderorderrank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TERenderBinSortOrder sortOrder = 3 [default = TERenderBinSortOrder_ChildSortOrder];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TERenderBinSortOrder_IsValid(val))) {
            _internal_set_sortorder(static_cast<::HmiScenegraph::TERenderBinSortOrder>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderOrderBin::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderOrderBin)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TIdentifier name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::name(this),
        _Internal::name(this).GetCachedSize(), target, stream);
  }

  // optional int32 renderOrderRank = 2 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_renderorderrank(), target);
  }

  // optional .HmiScenegraph.TERenderBinSortOrder sortOrder = 3 [default = TERenderBinSortOrder_ChildSortOrder];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_sortorder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderOrderBin)
  return target;
}

size_t TRenderOrderBin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderOrderBin)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TIdentifier name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.name_);
    }

    // optional int32 renderOrderRank = 2 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_renderorderrank());
    }

    // optional .HmiScenegraph.TERenderBinSortOrder sortOrder = 3 [default = TERenderBinSortOrder_ChildSortOrder];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sortorder());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderOrderBin::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderOrderBin::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderOrderBin::GetClassData() const { return &_class_data_; }


void TRenderOrderBin::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderOrderBin*>(&to_msg);
  auto& from = static_cast<const TRenderOrderBin&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderOrderBin)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_name()->::TIdentifier::MergeFrom(
          from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.renderorderrank_ = from._impl_.renderorderrank_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sortorder_ = from._impl_.sortorder_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderOrderBin::CopyFrom(const TRenderOrderBin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderOrderBin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderOrderBin::IsInitialized() const {
  return true;
}

void TRenderOrderBin::InternalSwap(TRenderOrderBin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TRenderOrderBin, _impl_.sortorder_)
      + sizeof(TRenderOrderBin::_impl_.sortorder_)
      - PROTOBUF_FIELD_OFFSET(TRenderOrderBin, _impl_.name_)>(
          reinterpret_cast<char*>(&_impl_.name_),
          reinterpret_cast<char*>(&other->_impl_.name_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderOrderBin::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[24]);
}

// ===================================================================

class TRenderTarget::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderTarget>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderTarget, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_samples(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_semanticwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_semanticheight(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_semanticdepth(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_resolutionmultiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_depthbuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stencilbuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::HmiScenegraph::TDiscardFramebuffer& discardframebuffer(const TRenderTarget* msg);
  static void set_has_discardframebuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::HmiScenegraph::TDiscardFramebuffer&
TRenderTarget::_Internal::discardframebuffer(const TRenderTarget* msg) {
  return *msg->_impl_.discardframebuffer_;
}
TRenderTarget::TRenderTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderTarget)
}
TRenderTarget::TRenderTarget(const TRenderTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderTarget* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.colorbuffer_){from._impl_.colorbuffer_}
    , decltype(_impl_.depthbuffer_){}
    , decltype(_impl_.stencilbuffer_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.discardframebuffer_){nullptr}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.samples_){}
    , decltype(_impl_.semanticwidth_){}
    , decltype(_impl_.semanticheight_){}
    , decltype(_impl_.semanticdepth_){}
    , decltype(_impl_.resolutionmultiplier_){}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.depthbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.depthbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_depthbuffer()) {
    _this->_impl_.depthbuffer_.Set(from._internal_depthbuffer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.stencilbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stencilbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stencilbuffer()) {
    _this->_impl_.stencilbuffer_.Set(from._internal_stencilbuffer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_discardframebuffer()) {
    _this->_impl_.discardframebuffer_ = new ::HmiScenegraph::TDiscardFramebuffer(*from._impl_.discardframebuffer_);
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scope_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.scope_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderTarget)
}

inline void TRenderTarget::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.colorbuffer_){arena}
    , decltype(_impl_.depthbuffer_){}
    , decltype(_impl_.stencilbuffer_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.discardframebuffer_){nullptr}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.samples_){0}
    , decltype(_impl_.semanticwidth_){0}
    , decltype(_impl_.semanticheight_){0}
    , decltype(_impl_.semanticdepth_){0}
    , decltype(_impl_.resolutionmultiplier_){0}
    , decltype(_impl_.scope_){1}
  };
  _impl_.depthbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.depthbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stencilbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stencilbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TRenderTarget::~TRenderTarget() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderTarget)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.colorbuffer_.~RepeatedPtrField();
  _impl_.depthbuffer_.Destroy();
  _impl_.stencilbuffer_.Destroy();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.discardframebuffer_;
}

void TRenderTarget::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.colorbuffer_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.depthbuffer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.stencilbuffer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.discardframebuffer_ != nullptr);
      _impl_.discardframebuffer_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.semanticwidth_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.semanticwidth_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.semanticheight_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.resolutionmultiplier_) -
        reinterpret_cast<char*>(&_impl_.semanticheight_)) + sizeof(_impl_.resolutionmultiplier_));
    _impl_.scope_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderTarget::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 samples = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_samples(&has_bits);
          _impl_.samples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string colorBuffer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_colorbuffer();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderTarget.colorBuffer");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string depthBuffer = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_depthbuffer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderTarget.depthBuffer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string stencilBuffer = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_stencilbuffer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderTarget.stencilBuffer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TDiscardFramebuffer discardFramebuffer = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_discardframebuffer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticWidth = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticwidth(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticHeight = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticheight(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TESemanticValue semanticDepth = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TESemanticValue_IsValid(val))) {
            _internal_set_semanticdepth(static_cast<::HmiScenegraph::TESemanticValue>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float resolutionMultiplier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_resolutionmultiplier(&has_bits);
          _impl_.resolutionmultiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderTarget.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 width = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // optional uint32 height = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  // optional int32 samples = 3 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_samples(), target);
  }

  // repeated string colorBuffer = 4;
  for (int i = 0, n = this->_internal_colorbuffer_size(); i < n; i++) {
    const auto& s = this->_internal_colorbuffer(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderTarget.colorBuffer");
    target = stream->WriteString(4, s, target);
  }

  // optional string depthBuffer = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_depthbuffer().data(), static_cast<int>(this->_internal_depthbuffer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderTarget.depthBuffer");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_depthbuffer(), target);
  }

  // optional string stencilBuffer = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_stencilbuffer().data(), static_cast<int>(this->_internal_stencilbuffer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderTarget.stencilBuffer");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_stencilbuffer(), target);
  }

  // optional .HmiScenegraph.TDiscardFramebuffer discardFramebuffer = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::discardframebuffer(this),
        _Internal::discardframebuffer(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TESemanticValue semanticWidth = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_semanticwidth(), target);
  }

  // optional .HmiScenegraph.TESemanticValue semanticHeight = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_semanticheight(), target);
  }

  // optional .HmiScenegraph.TESemanticValue semanticDepth = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_semanticdepth(), target);
  }

  // optional float resolutionMultiplier = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_resolutionmultiplier(), target);
  }

  // optional string name = 12;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderTarget.name");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_name(), target);
  }

  // optional .TEScope scope = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_scope(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderTarget)
  return target;
}

size_t TRenderTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string colorBuffer = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.colorbuffer_.size());
  for (int i = 0, n = _impl_.colorbuffer_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.colorbuffer_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string depthBuffer = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_depthbuffer());
    }

    // optional string stencilBuffer = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stencilbuffer());
    }

    // optional string name = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .HmiScenegraph.TDiscardFramebuffer discardFramebuffer = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.discardframebuffer_);
    }

    // optional uint32 width = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

    // optional int32 samples = 3 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_samples());
    }

    // optional .HmiScenegraph.TESemanticValue semanticWidth = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticwidth());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .HmiScenegraph.TESemanticValue semanticHeight = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticheight());
    }

    // optional .HmiScenegraph.TESemanticValue semanticDepth = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semanticdepth());
    }

    // optional float resolutionMultiplier = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional .TEScope scope = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderTarget::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderTarget::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderTarget::GetClassData() const { return &_class_data_; }


void TRenderTarget::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderTarget*>(&to_msg);
  auto& from = static_cast<const TRenderTarget&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderTarget)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.colorbuffer_.MergeFrom(from._impl_.colorbuffer_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_depthbuffer(from._internal_depthbuffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_stencilbuffer(from._internal_stencilbuffer());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_discardframebuffer()->::HmiScenegraph::TDiscardFramebuffer::MergeFrom(
          from._internal_discardframebuffer());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.samples_ = from._impl_.samples_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.semanticwidth_ = from._impl_.semanticwidth_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.semanticheight_ = from._impl_.semanticheight_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.semanticdepth_ = from._impl_.semanticdepth_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.resolutionmultiplier_ = from._impl_.resolutionmultiplier_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderTarget::CopyFrom(const TRenderTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderTarget::IsInitialized() const {
  return true;
}

void TRenderTarget::InternalSwap(TRenderTarget* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.colorbuffer_.InternalSwap(&other->_impl_.colorbuffer_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.depthbuffer_, lhs_arena,
      &other->_impl_.depthbuffer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stencilbuffer_, lhs_arena,
      &other->_impl_.stencilbuffer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TRenderTarget, _impl_.resolutionmultiplier_)
      + sizeof(TRenderTarget::_impl_.resolutionmultiplier_)
      - PROTOBUF_FIELD_OFFSET(TRenderTarget, _impl_.discardframebuffer_)>(
          reinterpret_cast<char*>(&_impl_.discardframebuffer_),
          reinterpret_cast<char*>(&other->_impl_.discardframebuffer_));
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderTarget::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[25]);
}

// ===================================================================

class TClearMode::_Internal {
 public:
  using HasBits = decltype(std::declval<TClearMode>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TClearMode, _impl_._has_bits_);
  static void set_has_clearcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cleardepth(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clearstencil(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TClearMode::TClearMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TClearMode)
}
TClearMode::TClearMode(const TClearMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TClearMode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clearcolor_){}
    , decltype(_impl_.cleardepth_){}
    , decltype(_impl_.clearstencil_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.clearcolor_, &from._impl_.clearcolor_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clearstencil_) -
    reinterpret_cast<char*>(&_impl_.clearcolor_)) + sizeof(_impl_.clearstencil_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TClearMode)
}

inline void TClearMode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.clearcolor_){0u}
    , decltype(_impl_.cleardepth_){0}
    , decltype(_impl_.clearstencil_){0u}
  };
}

TClearMode::~TClearMode() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TClearMode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TClearMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TClearMode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TClearMode::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TClearMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.clearcolor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clearstencil_) -
        reinterpret_cast<char*>(&_impl_.clearcolor_)) + sizeof(_impl_.clearstencil_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TClearMode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 clearColor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_clearcolor(&has_bits);
          _impl_.clearcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional float clearDepth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_cleardepth(&has_bits);
          _impl_.cleardepth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 clearStencil = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_clearstencil(&has_bits);
          _impl_.clearstencil_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TClearMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TClearMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 clearColor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_clearcolor(), target);
  }

  // optional float clearDepth = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_cleardepth(), target);
  }

  // optional fixed32 clearStencil = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_clearstencil(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TClearMode)
  return target;
}

size_t TClearMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TClearMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional fixed32 clearColor = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float clearDepth = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 clearStencil = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TClearMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TClearMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TClearMode::GetClassData() const { return &_class_data_; }


void TClearMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TClearMode*>(&to_msg);
  auto& from = static_cast<const TClearMode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TClearMode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.clearcolor_ = from._impl_.clearcolor_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cleardepth_ = from._impl_.cleardepth_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.clearstencil_ = from._impl_.clearstencil_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TClearMode::CopyFrom(const TClearMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TClearMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TClearMode::IsInitialized() const {
  return true;
}

void TClearMode::InternalSwap(TClearMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TClearMode, _impl_.clearstencil_)
      + sizeof(TClearMode::_impl_.clearstencil_)
      - PROTOBUF_FIELD_OFFSET(TClearMode, _impl_.clearcolor_)>(
          reinterpret_cast<char*>(&_impl_.clearcolor_),
          reinterpret_cast<char*>(&other->_impl_.clearcolor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TClearMode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[26]);
}

// ===================================================================

class TDiscardFramebuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<TDiscardFramebuffer>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TDiscardFramebuffer, _impl_._has_bits_);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stencil(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TDiscardFramebuffer::TDiscardFramebuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TDiscardFramebuffer)
}
TDiscardFramebuffer::TDiscardFramebuffer(const TDiscardFramebuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TDiscardFramebuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.stencil_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.color_, &from._impl_.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.stencil_) -
    reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.stencil_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TDiscardFramebuffer)
}

inline void TDiscardFramebuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){false}
    , decltype(_impl_.depth_){false}
    , decltype(_impl_.stencil_){false}
  };
}

TDiscardFramebuffer::~TDiscardFramebuffer() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TDiscardFramebuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TDiscardFramebuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TDiscardFramebuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TDiscardFramebuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TDiscardFramebuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.color_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.stencil_) -
      reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.stencil_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TDiscardFramebuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_color(&has_bits);
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool depth = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_depth(&has_bits);
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stencil = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stencil(&has_bits);
          _impl_.stencil_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TDiscardFramebuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TDiscardFramebuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_color(), target);
  }

  // optional bool depth = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_depth(), target);
  }

  // optional bool stencil = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_stencil(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TDiscardFramebuffer)
  return target;
}

size_t TDiscardFramebuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TDiscardFramebuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool depth = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool stencil = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TDiscardFramebuffer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TDiscardFramebuffer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TDiscardFramebuffer::GetClassData() const { return &_class_data_; }


void TDiscardFramebuffer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TDiscardFramebuffer*>(&to_msg);
  auto& from = static_cast<const TDiscardFramebuffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TDiscardFramebuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.depth_ = from._impl_.depth_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.stencil_ = from._impl_.stencil_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TDiscardFramebuffer::CopyFrom(const TDiscardFramebuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TDiscardFramebuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TDiscardFramebuffer::IsInitialized() const {
  return true;
}

void TDiscardFramebuffer::InternalSwap(TDiscardFramebuffer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TDiscardFramebuffer, _impl_.stencil_)
      + sizeof(TDiscardFramebuffer::_impl_.stencil_)
      - PROTOBUF_FIELD_OFFSET(TDiscardFramebuffer, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TDiscardFramebuffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[27]);
}

// ===================================================================

class TRenderPass::_Internal {
 public:
  using HasBits = decltype(std::declval<TRenderPass>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TRenderPass, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::HmiScenegraph::TRenderOrder& renderorder(const TRenderPass* msg);
  static void set_has_renderorder(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::HmiScenegraph::TRenderTarget& rendertarget(const TRenderPass* msg);
  static void set_has_rendertarget(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_rendertargetreference(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::HmiScenegraph::TClearMode& clearmode(const TRenderPass* msg);
  static void set_has_clearmode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cameraname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TVector4f& viewport(const TRenderPass* msg);
  static void set_has_viewport(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_viewfrustumcullingenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_scopemask(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::HmiScenegraph::TRenderOrder&
TRenderPass::_Internal::renderorder(const TRenderPass* msg) {
  return *msg->_impl_.renderorder_;
}
const ::HmiScenegraph::TRenderTarget&
TRenderPass::_Internal::rendertarget(const TRenderPass* msg) {
  return *msg->_impl_.rendertarget_;
}
const ::HmiScenegraph::TClearMode&
TRenderPass::_Internal::clearmode(const TRenderPass* msg) {
  return *msg->_impl_.clearmode_;
}
const ::TVector4f&
TRenderPass::_Internal::viewport(const TRenderPass* msg) {
  return *msg->_impl_.viewport_;
}
void TRenderPass::clear_viewport() {
  if (_impl_.viewport_ != nullptr) _impl_.viewport_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
TRenderPass::TRenderPass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TRenderPass)
}
TRenderPass::TRenderPass(const TRenderPass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TRenderPass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.renderorderbin_){from._impl_.renderorderbin_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cameraname_){}
    , decltype(_impl_.rendertargetreference_){}
    , decltype(_impl_.renderorder_){nullptr}
    , decltype(_impl_.rendertarget_){nullptr}
    , decltype(_impl_.clearmode_){nullptr}
    , decltype(_impl_.viewport_){nullptr}
    , decltype(_impl_.rank_){}
    , decltype(_impl_.viewfrustumcullingenabled_){}
    , decltype(_impl_.scopemask_){}
    , decltype(_impl_.scope_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cameraname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cameraname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cameraname()) {
    _this->_impl_.cameraname_.Set(from._internal_cameraname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.rendertargetreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rendertargetreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rendertargetreference()) {
    _this->_impl_.rendertargetreference_.Set(from._internal_rendertargetreference(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_renderorder()) {
    _this->_impl_.renderorder_ = new ::HmiScenegraph::TRenderOrder(*from._impl_.renderorder_);
  }
  if (from._internal_has_rendertarget()) {
    _this->_impl_.rendertarget_ = new ::HmiScenegraph::TRenderTarget(*from._impl_.rendertarget_);
  }
  if (from._internal_has_clearmode()) {
    _this->_impl_.clearmode_ = new ::HmiScenegraph::TClearMode(*from._impl_.clearmode_);
  }
  if (from._internal_has_viewport()) {
    _this->_impl_.viewport_ = new ::TVector4f(*from._impl_.viewport_);
  }
  ::memcpy(&_impl_.rank_, &from._impl_.rank_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scope_) -
    reinterpret_cast<char*>(&_impl_.rank_)) + sizeof(_impl_.scope_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TRenderPass)
}

inline void TRenderPass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.renderorderbin_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cameraname_){}
    , decltype(_impl_.rendertargetreference_){}
    , decltype(_impl_.renderorder_){nullptr}
    , decltype(_impl_.rendertarget_){nullptr}
    , decltype(_impl_.clearmode_){nullptr}
    , decltype(_impl_.viewport_){nullptr}
    , decltype(_impl_.rank_){0u}
    , decltype(_impl_.viewfrustumcullingenabled_){false}
    , decltype(_impl_.scopemask_){0u}
    , decltype(_impl_.scope_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cameraname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cameraname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rendertargetreference_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rendertargetreference_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TRenderPass::~TRenderPass() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TRenderPass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TRenderPass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.renderorderbin_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.cameraname_.Destroy();
  _impl_.rendertargetreference_.Destroy();
  if (this != internal_default_instance()) delete _impl_.renderorder_;
  if (this != internal_default_instance()) delete _impl_.rendertarget_;
  if (this != internal_default_instance()) delete _impl_.clearmode_;
  if (this != internal_default_instance()) delete _impl_.viewport_;
}

void TRenderPass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TRenderPass::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TRenderPass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.renderorderbin_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.cameraname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.rendertargetreference_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.renderorder_ != nullptr);
      _impl_.renderorder_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.rendertarget_ != nullptr);
      _impl_.rendertarget_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.clearmode_ != nullptr);
      _impl_.clearmode_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.viewport_ != nullptr);
      _impl_.viewport_->Clear();
    }
  }
  _impl_.rank_ = 0u;
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.viewfrustumcullingenabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scopemask_) -
        reinterpret_cast<char*>(&_impl_.viewfrustumcullingenabled_)) + sizeof(_impl_.scopemask_));
    _impl_.scope_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TRenderPass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderPass.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rank = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rank(&has_bits);
          _impl_.rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TRenderOrder renderOrder = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_renderorder(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TRenderTarget renderTarget = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendertarget(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TClearMode clearMode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_clearmode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cameraName = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_cameraname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderPass.cameraName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TVector4f viewport = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_viewport(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool viewFrustumCullingEnabled = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_viewfrustumcullingenabled(&has_bits);
          _impl_.viewfrustumcullingenabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 scopeMask = 9 [deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_scopemask(&has_bits);
          _impl_.scopemask_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional .TEScope scope = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TEScope_IsValid(val))) {
            _internal_set_scope(static_cast<::TEScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string renderTargetReference = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_rendertargetreference();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TRenderPass.renderTargetReference");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderOrderBin renderOrderBin = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_renderorderbin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TRenderPass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TRenderPass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderPass.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 rank = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rank(), target);
  }

  // optional .HmiScenegraph.TRenderOrder renderOrder = 3 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::renderorder(this),
        _Internal::renderorder(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TRenderTarget renderTarget = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rendertarget(this),
        _Internal::rendertarget(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TClearMode clearMode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::clearmode(this),
        _Internal::clearmode(this).GetCachedSize(), target, stream);
  }

  // optional string cameraName = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cameraname().data(), static_cast<int>(this->_internal_cameraname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderPass.cameraName");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_cameraname(), target);
  }

  // optional .TVector4f viewport = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::viewport(this),
        _Internal::viewport(this).GetCachedSize(), target, stream);
  }

  // optional bool viewFrustumCullingEnabled = 8 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_viewfrustumcullingenabled(), target);
  }

  // optional fixed32 scopeMask = 9 [deprecated = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_scopemask(), target);
  }

  // optional .TEScope scope = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_scope(), target);
  }

  // optional string renderTargetReference = 11;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rendertargetreference().data(), static_cast<int>(this->_internal_rendertargetreference().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TRenderPass.renderTargetReference");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_rendertargetreference(), target);
  }

  // repeated .HmiScenegraph.TRenderOrderBin renderOrderBin = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderorderbin_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderorderbin(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TRenderPass)
  return target;
}

size_t TRenderPass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TRenderPass)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TRenderOrderBin renderOrderBin = 12;
  total_size += 1UL * this->_internal_renderorderbin_size();
  for (const auto& msg : this->_impl_.renderorderbin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string cameraName = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cameraname());
    }

    // optional string renderTargetReference = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rendertargetreference());
    }

    // optional .HmiScenegraph.TRenderOrder renderOrder = 3 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.renderorder_);
    }

    // optional .HmiScenegraph.TRenderTarget renderTarget = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rendertarget_);
    }

    // optional .HmiScenegraph.TClearMode clearMode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.clearmode_);
    }

    // optional .TVector4f viewport = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.viewport_);
    }

    // optional uint32 rank = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool viewFrustumCullingEnabled = 8 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional fixed32 scopeMask = 9 [deprecated = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional .TEScope scope = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_scope());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TRenderPass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TRenderPass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TRenderPass::GetClassData() const { return &_class_data_; }


void TRenderPass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TRenderPass*>(&to_msg);
  auto& from = static_cast<const TRenderPass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TRenderPass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.renderorderbin_.MergeFrom(from._impl_.renderorderbin_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_cameraname(from._internal_cameraname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_rendertargetreference(from._internal_rendertargetreference());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_renderorder()->::HmiScenegraph::TRenderOrder::MergeFrom(
          from._internal_renderorder());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_rendertarget()->::HmiScenegraph::TRenderTarget::MergeFrom(
          from._internal_rendertarget());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_clearmode()->::HmiScenegraph::TClearMode::MergeFrom(
          from._internal_clearmode());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_viewport()->::TVector4f::MergeFrom(
          from._internal_viewport());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.rank_ = from._impl_.rank_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.viewfrustumcullingenabled_ = from._impl_.viewfrustumcullingenabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.scopemask_ = from._impl_.scopemask_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.scope_ = from._impl_.scope_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TRenderPass::CopyFrom(const TRenderPass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TRenderPass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TRenderPass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_viewport()) {
    if (!_impl_.viewport_->IsInitialized()) return false;
  }
  return true;
}

void TRenderPass::InternalSwap(TRenderPass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.renderorderbin_.InternalSwap(&other->_impl_.renderorderbin_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cameraname_, lhs_arena,
      &other->_impl_.cameraname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.rendertargetreference_, lhs_arena,
      &other->_impl_.rendertargetreference_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TRenderPass, _impl_.scopemask_)
      + sizeof(TRenderPass::_impl_.scopemask_)
      - PROTOBUF_FIELD_OFFSET(TRenderPass, _impl_.renderorder_)>(
          reinterpret_cast<char*>(&_impl_.renderorder_),
          reinterpret_cast<char*>(&other->_impl_.renderorder_));
  swap(_impl_.scope_, other->_impl_.scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TRenderPass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[28]);
}

// ===================================================================

class TBlitPass::_Internal {
 public:
  using HasBits = decltype(std::declval<TBlitPass>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TBlitPass, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rank(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sourcerenderbuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_destinationrenderbuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_regionwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_regionheight(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_regionsourcex(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_regionsourcey(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_regiondestinationx(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_regiondestinationy(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TBlitPass::TBlitPass(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TBlitPass)
}
TBlitPass::TBlitPass(const TBlitPass& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TBlitPass* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.sourcerenderbuffer_){}
    , decltype(_impl_.destinationrenderbuffer_){}
    , decltype(_impl_.rank_){}
    , decltype(_impl_.regionwidth_){}
    , decltype(_impl_.regionheight_){}
    , decltype(_impl_.regionsourcex_){}
    , decltype(_impl_.regionsourcey_){}
    , decltype(_impl_.regiondestinationx_){}
    , decltype(_impl_.regiondestinationy_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourcerenderbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcerenderbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcerenderbuffer()) {
    _this->_impl_.sourcerenderbuffer_.Set(from._internal_sourcerenderbuffer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.destinationrenderbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destinationrenderbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_destinationrenderbuffer()) {
    _this->_impl_.destinationrenderbuffer_.Set(from._internal_destinationrenderbuffer(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.rank_, &from._impl_.rank_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.regiondestinationy_) -
    reinterpret_cast<char*>(&_impl_.rank_)) + sizeof(_impl_.regiondestinationy_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TBlitPass)
}

inline void TBlitPass::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.sourcerenderbuffer_){}
    , decltype(_impl_.destinationrenderbuffer_){}
    , decltype(_impl_.rank_){0u}
    , decltype(_impl_.regionwidth_){0u}
    , decltype(_impl_.regionheight_){0u}
    , decltype(_impl_.regionsourcex_){0u}
    , decltype(_impl_.regionsourcey_){0u}
    , decltype(_impl_.regiondestinationx_){0u}
    , decltype(_impl_.regiondestinationy_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourcerenderbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcerenderbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.destinationrenderbuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destinationrenderbuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TBlitPass::~TBlitPass() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TBlitPass)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TBlitPass::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.sourcerenderbuffer_.Destroy();
  _impl_.destinationrenderbuffer_.Destroy();
}

void TBlitPass::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TBlitPass::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TBlitPass)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourcerenderbuffer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.destinationrenderbuffer_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.rank_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.regionsourcey_) -
        reinterpret_cast<char*>(&_impl_.rank_)) + sizeof(_impl_.regionsourcey_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.regiondestinationx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.regiondestinationy_) -
        reinterpret_cast<char*>(&_impl_.regiondestinationx_)) + sizeof(_impl_.regiondestinationy_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TBlitPass::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBlitPass.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rank = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rank(&has_bits);
          _impl_.rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sourceRenderBuffer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sourcerenderbuffer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBlitPass.sourceRenderBuffer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string destinationRenderBuffer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_destinationrenderbuffer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TBlitPass.destinationRenderBuffer");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionWidth = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_regionwidth(&has_bits);
          _impl_.regionwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionHeight = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_regionheight(&has_bits);
          _impl_.regionheight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionSourceX = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_regionsourcex(&has_bits);
          _impl_.regionsourcex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionSourceY = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_regionsourcey(&has_bits);
          _impl_.regionsourcey_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionDestinationX = 9 [default = 0];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_regiondestinationx(&has_bits);
          _impl_.regiondestinationx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 regionDestinationY = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_regiondestinationy(&has_bits);
          _impl_.regiondestinationy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TBlitPass::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TBlitPass)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBlitPass.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 rank = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rank(), target);
  }

  // optional string sourceRenderBuffer = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcerenderbuffer().data(), static_cast<int>(this->_internal_sourcerenderbuffer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBlitPass.sourceRenderBuffer");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sourcerenderbuffer(), target);
  }

  // optional string destinationRenderBuffer = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_destinationrenderbuffer().data(), static_cast<int>(this->_internal_destinationrenderbuffer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TBlitPass.destinationRenderBuffer");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_destinationrenderbuffer(), target);
  }

  // optional uint32 regionWidth = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_regionwidth(), target);
  }

  // optional uint32 regionHeight = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_regionheight(), target);
  }

  // optional uint32 regionSourceX = 7 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_regionsourcex(), target);
  }

  // optional uint32 regionSourceY = 8 [default = 0];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_regionsourcey(), target);
  }

  // optional uint32 regionDestinationX = 9 [default = 0];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_regiondestinationx(), target);
  }

  // optional uint32 regionDestinationY = 10 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_regiondestinationy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TBlitPass)
  return target;
}

size_t TBlitPass::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TBlitPass)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string sourceRenderBuffer = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sourcerenderbuffer());
    }

    // optional string destinationRenderBuffer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_destinationrenderbuffer());
    }

    // optional uint32 rank = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rank());
    }

    // optional uint32 regionWidth = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regionwidth());
    }

    // optional uint32 regionHeight = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regionheight());
    }

    // optional uint32 regionSourceX = 7 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regionsourcex());
    }

    // optional uint32 regionSourceY = 8 [default = 0];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regionsourcey());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 regionDestinationX = 9 [default = 0];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regiondestinationx());
    }

    // optional uint32 regionDestinationY = 10 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_regiondestinationy());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TBlitPass::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TBlitPass::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TBlitPass::GetClassData() const { return &_class_data_; }


void TBlitPass::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TBlitPass*>(&to_msg);
  auto& from = static_cast<const TBlitPass&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TBlitPass)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourcerenderbuffer(from._internal_sourcerenderbuffer());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_destinationrenderbuffer(from._internal_destinationrenderbuffer());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rank_ = from._impl_.rank_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.regionwidth_ = from._impl_.regionwidth_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.regionheight_ = from._impl_.regionheight_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.regionsourcex_ = from._impl_.regionsourcex_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.regionsourcey_ = from._impl_.regionsourcey_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.regiondestinationx_ = from._impl_.regiondestinationx_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.regiondestinationy_ = from._impl_.regiondestinationy_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TBlitPass::CopyFrom(const TBlitPass& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TBlitPass)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TBlitPass::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TBlitPass::InternalSwap(TBlitPass* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcerenderbuffer_, lhs_arena,
      &other->_impl_.sourcerenderbuffer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.destinationrenderbuffer_, lhs_arena,
      &other->_impl_.destinationrenderbuffer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TBlitPass, _impl_.regiondestinationy_)
      + sizeof(TBlitPass::_impl_.regiondestinationy_)
      - PROTOBUF_FIELD_OFFSET(TBlitPass, _impl_.rank_)>(
          reinterpret_cast<char*>(&_impl_.rank_),
          reinterpret_cast<char*>(&other->_impl_.rank_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TBlitPass::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[29]);
}

// ===================================================================

class TGeometry_TAttributeParamteter::_Internal {
 public:
  using HasBits = decltype(std::declval<TGeometry_TAttributeParamteter>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TGeometry_TAttributeParamteter, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_semantic(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_usageindex(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::HmiScenegraph::TResourceCacheId& cacheid(const TGeometry_TAttributeParamteter* msg);
  static void set_has_cacheid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::HmiScenegraph::TResourceCacheId&
TGeometry_TAttributeParamteter::_Internal::cacheid(const TGeometry_TAttributeParamteter* msg) {
  return *msg->_impl_.cacheid_;
}
TGeometry_TAttributeParamteter::TGeometry_TAttributeParamteter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TGeometry.TAttributeParamteter)
}
TGeometry_TAttributeParamteter::TGeometry_TAttributeParamteter(const TGeometry_TAttributeParamteter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TGeometry_TAttributeParamteter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.precision_){}
    , decltype(_impl_.usageindex_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.semantic_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cacheid()) {
    _this->_impl_.cacheid_ = new ::HmiScenegraph::TResourceCacheId(*from._impl_.cacheid_);
  }
  ::memcpy(&_impl_.precision_, &from._impl_.precision_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.semantic_) -
    reinterpret_cast<char*>(&_impl_.precision_)) + sizeof(_impl_.semantic_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TGeometry.TAttributeParamteter)
}

inline void TGeometry_TAttributeParamteter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.cacheid_){nullptr}
    , decltype(_impl_.precision_){0}
    , decltype(_impl_.usageindex_){0u}
    , decltype(_impl_.size_){1}
    , decltype(_impl_.semantic_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TGeometry_TAttributeParamteter::~TGeometry_TAttributeParamteter() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TGeometry.TAttributeParamteter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TGeometry_TAttributeParamteter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cacheid_;
}

void TGeometry_TAttributeParamteter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TGeometry_TAttributeParamteter::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TGeometry.TAttributeParamteter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cacheid_ != nullptr);
      _impl_.cacheid_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.precision_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.usageindex_) -
        reinterpret_cast<char*>(&_impl_.precision_)) + sizeof(_impl_.usageindex_));
    _impl_.size_ = 1;
    _impl_.semantic_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TGeometry_TAttributeParamteter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TGeometry.TAttributeParamteter.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAttributePrecision precision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributePrecision_IsValid(val))) {
            _internal_set_precision(static_cast<::HmiScenegraph::TEAttributePrecision>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAttributeSize size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributeSize_IsValid(val))) {
            _internal_set_size(static_cast<::HmiScenegraph::TEAttributeSize>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEAttributeSemantic semantic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEAttributeSemantic_IsValid(val))) {
            _internal_set_semantic(static_cast<::HmiScenegraph::TEAttributeSemantic>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 usageIndex = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_usageindex(&has_bits);
          _impl_.usageindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TResourceCacheId cacheId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cacheid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TGeometry_TAttributeParamteter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TGeometry.TAttributeParamteter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TGeometry.TAttributeParamteter.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .HmiScenegraph.TEAttributePrecision precision = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_precision(), target);
  }

  // optional .HmiScenegraph.TEAttributeSize size = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_size(), target);
  }

  // optional .HmiScenegraph.TEAttributeSemantic semantic = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_semantic(), target);
  }

  // optional uint32 usageIndex = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_usageindex(), target);
  }

  // optional .HmiScenegraph.TResourceCacheId cacheId = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::cacheid(this),
        _Internal::cacheid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TGeometry.TAttributeParamteter)
  return target;
}

size_t TGeometry_TAttributeParamteter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TGeometry.TAttributeParamteter)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional .HmiScenegraph.TResourceCacheId cacheId = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cacheid_);
    }

    // optional .HmiScenegraph.TEAttributePrecision precision = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_precision());
    }

    // optional uint32 usageIndex = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_usageindex());
    }

    // optional .HmiScenegraph.TEAttributeSize size = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_size());
    }

    // optional .HmiScenegraph.TEAttributeSemantic semantic = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_semantic());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TGeometry_TAttributeParamteter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TGeometry_TAttributeParamteter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TGeometry_TAttributeParamteter::GetClassData() const { return &_class_data_; }


void TGeometry_TAttributeParamteter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TGeometry_TAttributeParamteter*>(&to_msg);
  auto& from = static_cast<const TGeometry_TAttributeParamteter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TGeometry.TAttributeParamteter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cacheid()->::HmiScenegraph::TResourceCacheId::MergeFrom(
          from._internal_cacheid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.precision_ = from._impl_.precision_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.usageindex_ = from._impl_.usageindex_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.semantic_ = from._impl_.semantic_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TGeometry_TAttributeParamteter::CopyFrom(const TGeometry_TAttributeParamteter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TGeometry.TAttributeParamteter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TGeometry_TAttributeParamteter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TGeometry_TAttributeParamteter::InternalSwap(TGeometry_TAttributeParamteter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TGeometry_TAttributeParamteter, _impl_.usageindex_)
      + sizeof(TGeometry_TAttributeParamteter::_impl_.usageindex_)
      - PROTOBUF_FIELD_OFFSET(TGeometry_TAttributeParamteter, _impl_.cacheid_)>(
          reinterpret_cast<char*>(&_impl_.cacheid_),
          reinterpret_cast<char*>(&other->_impl_.cacheid_));
  swap(_impl_.size_, other->_impl_.size_);
  swap(_impl_.semantic_, other->_impl_.semantic_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TGeometry_TAttributeParamteter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[30]);
}

// ===================================================================

class TGeometry::_Internal {
 public:
  using HasBits = decltype(std::declval<TGeometry>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TGeometry, _impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vertexcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_primitivecount(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_primitivetype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::HmiScenegraph::TResourceCacheId& indexdatacacheid(const TGeometry* msg);
  static void set_has_indexdatacacheid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::HmiScenegraph::TResourceCacheId&
TGeometry::_Internal::indexdatacacheid(const TGeometry* msg) {
  return *msg->_impl_.indexdatacacheid_;
}
TGeometry::TGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TGeometry)
}
TGeometry::TGeometry(const TGeometry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TGeometry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributeparameter_){from._impl_.attributeparameter_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.indexdatacacheid_){nullptr}
    , decltype(_impl_.vertexcount_){}
    , decltype(_impl_.primitivecount_){}
    , decltype(_impl_.primitivetype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_resource()) {
    _this->_impl_.resource_.Set(from._internal_resource(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_indexdatacacheid()) {
    _this->_impl_.indexdatacacheid_ = new ::HmiScenegraph::TResourceCacheId(*from._impl_.indexdatacacheid_);
  }
  ::memcpy(&_impl_.vertexcount_, &from._impl_.vertexcount_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primitivetype_) -
    reinterpret_cast<char*>(&_impl_.vertexcount_)) + sizeof(_impl_.primitivetype_));
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TGeometry)
}

inline void TGeometry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attributeparameter_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.resource_){}
    , decltype(_impl_.indexdatacacheid_){nullptr}
    , decltype(_impl_.vertexcount_){0u}
    , decltype(_impl_.primitivecount_){0u}
    , decltype(_impl_.primitivetype_){4}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.resource_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TGeometry::~TGeometry() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TGeometry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TGeometry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attributeparameter_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  _impl_.resource_.Destroy();
  if (this != internal_default_instance()) delete _impl_.indexdatacacheid_;
}

void TGeometry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TGeometry::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TGeometry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attributeparameter_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.resource_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.indexdatacacheid_ != nullptr);
      _impl_.indexdatacacheid_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.vertexcount_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.primitivecount_) -
        reinterpret_cast<char*>(&_impl_.vertexcount_)) + sizeof(_impl_.primitivecount_));
    _impl_.primitivetype_ = 4;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TGeometry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TGeometry.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string resource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_resource();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "HmiScenegraph.TGeometry.resource");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TGeometry.TAttributeParamteter attributeParameter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attributeparameter(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 vertexCount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_vertexcount(&has_bits);
          _impl_.vertexcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 primitiveCount = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_primitivecount(&has_bits);
          _impl_.primitivecount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TEPrimitiveType primitiveType = 6 [default = TEPrimitiveType_Triangles];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::HmiScenegraph::TEPrimitiveType_IsValid(val))) {
            _internal_set_primitivetype(static_cast<::HmiScenegraph::TEPrimitiveType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TResourceCacheId indexDataCacheId = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_indexdatacacheid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TGeometry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TGeometry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TGeometry.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string resource = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TGeometry.resource");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_resource(), target);
  }

  // repeated .HmiScenegraph.TGeometry.TAttributeParamteter attributeParameter = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributeparameter_size()); i < n; i++) {
    const auto& repfield = this->_internal_attributeparameter(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 vertexCount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_vertexcount(), target);
  }

  // optional uint32 primitiveCount = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_primitivecount(), target);
  }

  // optional .HmiScenegraph.TEPrimitiveType primitiveType = 6 [default = TEPrimitiveType_Triangles];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_primitivetype(), target);
  }

  // optional .HmiScenegraph.TResourceCacheId indexDataCacheId = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::indexdatacacheid(this),
        _Internal::indexdatacacheid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TGeometry)
  return target;
}

size_t TGeometry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TGeometry)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TGeometry.TAttributeParamteter attributeParameter = 3;
  total_size += 1UL * this->_internal_attributeparameter_size();
  for (const auto& msg : this->_impl_.attributeparameter_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional string resource = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource());
    }

    // optional .HmiScenegraph.TResourceCacheId indexDataCacheId = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.indexdatacacheid_);
    }

    // optional uint32 vertexCount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vertexcount());
    }

    // optional uint32 primitiveCount = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_primitivecount());
    }

    // optional .HmiScenegraph.TEPrimitiveType primitiveType = 6 [default = TEPrimitiveType_Triangles];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_primitivetype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TGeometry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TGeometry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TGeometry::GetClassData() const { return &_class_data_; }


void TGeometry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TGeometry*>(&to_msg);
  auto& from = static_cast<const TGeometry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TGeometry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attributeparameter_.MergeFrom(from._impl_.attributeparameter_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_resource(from._internal_resource());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_indexdatacacheid()->::HmiScenegraph::TResourceCacheId::MergeFrom(
          from._internal_indexdatacacheid());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.vertexcount_ = from._impl_.vertexcount_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primitivecount_ = from._impl_.primitivecount_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.primitivetype_ = from._impl_.primitivetype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TGeometry::CopyFrom(const TGeometry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TGeometry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TGeometry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.attributeparameter_))
    return false;
  return true;
}

void TGeometry::InternalSwap(TGeometry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attributeparameter_.InternalSwap(&other->_impl_.attributeparameter_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.resource_, lhs_arena,
      &other->_impl_.resource_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TGeometry, _impl_.primitivecount_)
      + sizeof(TGeometry::_impl_.primitivecount_)
      - PROTOBUF_FIELD_OFFSET(TGeometry, _impl_.indexdatacacheid_)>(
          reinterpret_cast<char*>(&_impl_.indexdatacacheid_),
          reinterpret_cast<char*>(&other->_impl_.indexdatacacheid_));
  swap(_impl_.primitivetype_, other->_impl_.primitivetype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TGeometry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[31]);
}

// ===================================================================

class TMaterialLib::_Internal {
 public:
};

TMaterialLib::TMaterialLib(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TMaterialLib)
}
TMaterialLib::TMaterialLib(const TMaterialLib& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TMaterialLib* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.material_){from._impl_.material_}
    , decltype(_impl_.shader_){from._impl_.shader_}
    , decltype(_impl_.bitmap_){from._impl_.bitmap_}
    , decltype(_impl_.geometry_){from._impl_.geometry_}
    , decltype(_impl_.rendertarget_){from._impl_.rendertarget_}
    , decltype(_impl_.renderpass_){from._impl_.renderpass_}
    , decltype(_impl_.resourcecache_){from._impl_.resourcecache_}
    , decltype(_impl_.blitpass_){from._impl_.blitpass_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TMaterialLib)
}

inline void TMaterialLib::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.material_){arena}
    , decltype(_impl_.shader_){arena}
    , decltype(_impl_.bitmap_){arena}
    , decltype(_impl_.geometry_){arena}
    , decltype(_impl_.rendertarget_){arena}
    , decltype(_impl_.renderpass_){arena}
    , decltype(_impl_.resourcecache_){arena}
    , decltype(_impl_.blitpass_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TMaterialLib::~TMaterialLib() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TMaterialLib)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TMaterialLib::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.material_.~RepeatedPtrField();
  _impl_.shader_.~RepeatedPtrField();
  _impl_.bitmap_.~RepeatedPtrField();
  _impl_.geometry_.~RepeatedPtrField();
  _impl_.rendertarget_.~RepeatedPtrField();
  _impl_.renderpass_.~RepeatedPtrField();
  _impl_.resourcecache_.~RepeatedPtrField();
  _impl_.blitpass_.~RepeatedPtrField();
}

void TMaterialLib::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TMaterialLib::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TMaterialLib)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.material_.Clear();
  _impl_.shader_.Clear();
  _impl_.bitmap_.Clear();
  _impl_.geometry_.Clear();
  _impl_.rendertarget_.Clear();
  _impl_.renderpass_.Clear();
  _impl_.resourcecache_.Clear();
  _impl_.blitpass_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMaterialLib::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .HmiScenegraph.TMaterial material = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_material(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TShader shader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shader(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TBitmap bitmap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bitmap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TGeometry geometry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_geometry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderTarget renderTarget = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rendertarget(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderPass renderPass = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_renderpass(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string resourceCache = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_resourcecache();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "HmiScenegraph.TMaterialLib.resourceCache");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TBlitPass blitPass = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blitpass(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TMaterialLib::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TMaterialLib)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TMaterial material = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_material_size()); i < n; i++) {
    const auto& repfield = this->_internal_material(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TShader shader = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shader_size()); i < n; i++) {
    const auto& repfield = this->_internal_shader(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TBitmap bitmap = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bitmap_size()); i < n; i++) {
    const auto& repfield = this->_internal_bitmap(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TGeometry geometry = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_geometry_size()); i < n; i++) {
    const auto& repfield = this->_internal_geometry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TRenderTarget renderTarget = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rendertarget_size()); i < n; i++) {
    const auto& repfield = this->_internal_rendertarget(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TRenderPass renderPass = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderpass_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderpass(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string resourceCache = 7;
  for (int i = 0, n = this->_internal_resourcecache_size(); i < n; i++) {
    const auto& s = this->_internal_resourcecache(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "HmiScenegraph.TMaterialLib.resourceCache");
    target = stream->WriteString(7, s, target);
  }

  // repeated .HmiScenegraph.TBlitPass blitPass = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blitpass_size()); i < n; i++) {
    const auto& repfield = this->_internal_blitpass(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TMaterialLib)
  return target;
}

size_t TMaterialLib::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TMaterialLib)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TMaterial material = 1;
  total_size += 1UL * this->_internal_material_size();
  for (const auto& msg : this->_impl_.material_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TShader shader = 2;
  total_size += 1UL * this->_internal_shader_size();
  for (const auto& msg : this->_impl_.shader_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TBitmap bitmap = 3;
  total_size += 1UL * this->_internal_bitmap_size();
  for (const auto& msg : this->_impl_.bitmap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TGeometry geometry = 4;
  total_size += 1UL * this->_internal_geometry_size();
  for (const auto& msg : this->_impl_.geometry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TRenderTarget renderTarget = 5;
  total_size += 1UL * this->_internal_rendertarget_size();
  for (const auto& msg : this->_impl_.rendertarget_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .HmiScenegraph.TRenderPass renderPass = 6;
  total_size += 1UL * this->_internal_renderpass_size();
  for (const auto& msg : this->_impl_.renderpass_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string resourceCache = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.resourcecache_.size());
  for (int i = 0, n = _impl_.resourcecache_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.resourcecache_.Get(i));
  }

  // repeated .HmiScenegraph.TBlitPass blitPass = 8;
  total_size += 1UL * this->_internal_blitpass_size();
  for (const auto& msg : this->_impl_.blitpass_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TMaterialLib::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TMaterialLib::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TMaterialLib::GetClassData() const { return &_class_data_; }


void TMaterialLib::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TMaterialLib*>(&to_msg);
  auto& from = static_cast<const TMaterialLib&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TMaterialLib)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.material_.MergeFrom(from._impl_.material_);
  _this->_impl_.shader_.MergeFrom(from._impl_.shader_);
  _this->_impl_.bitmap_.MergeFrom(from._impl_.bitmap_);
  _this->_impl_.geometry_.MergeFrom(from._impl_.geometry_);
  _this->_impl_.rendertarget_.MergeFrom(from._impl_.rendertarget_);
  _this->_impl_.renderpass_.MergeFrom(from._impl_.renderpass_);
  _this->_impl_.resourcecache_.MergeFrom(from._impl_.resourcecache_);
  _this->_impl_.blitpass_.MergeFrom(from._impl_.blitpass_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TMaterialLib::CopyFrom(const TMaterialLib& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TMaterialLib)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMaterialLib::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.material_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.shader_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.bitmap_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.geometry_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.renderpass_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.blitpass_))
    return false;
  return true;
}

void TMaterialLib::InternalSwap(TMaterialLib* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.material_.InternalSwap(&other->_impl_.material_);
  _impl_.shader_.InternalSwap(&other->_impl_.shader_);
  _impl_.bitmap_.InternalSwap(&other->_impl_.bitmap_);
  _impl_.geometry_.InternalSwap(&other->_impl_.geometry_);
  _impl_.rendertarget_.InternalSwap(&other->_impl_.rendertarget_);
  _impl_.renderpass_.InternalSwap(&other->_impl_.renderpass_);
  _impl_.resourcecache_.InternalSwap(&other->_impl_.resourcecache_);
  _impl_.blitpass_.InternalSwap(&other->_impl_.blitpass_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMaterialLib::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[32]);
}

// ===================================================================

class TScene::_Internal {
 public:
  using HasBits = decltype(std::declval<TScene>()._impl_._has_bits_);
  static constexpr int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TScene, _impl_._has_bits_);
  static const ::HmiScenegraph::TNode& root(const TScene* msg);
  static void set_has_root(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::HmiScenegraph::TMaterialLib& materiallibrary(const TScene* msg);
  static void set_has_materiallibrary(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::HmiScenegraph::TNode&
TScene::_Internal::root(const TScene* msg) {
  return *msg->_impl_.root_;
}
const ::HmiScenegraph::TMaterialLib&
TScene::_Internal::materiallibrary(const TScene* msg) {
  return *msg->_impl_.materiallibrary_;
}
TScene::TScene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:HmiScenegraph.TScene)
}
TScene::TScene(const TScene& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TScene* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.renderpass_){from._impl_.renderpass_}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.materiallibrary_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_root()) {
    _this->_impl_.root_ = new ::HmiScenegraph::TNode(*from._impl_.root_);
  }
  if (from._internal_has_materiallibrary()) {
    _this->_impl_.materiallibrary_ = new ::HmiScenegraph::TMaterialLib(*from._impl_.materiallibrary_);
  }
  // @@protoc_insertion_point(copy_constructor:HmiScenegraph.TScene)
}

inline void TScene::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.renderpass_){arena}
    , decltype(_impl_.root_){nullptr}
    , decltype(_impl_.materiallibrary_){nullptr}
  };
}

TScene::~TScene() {
  // @@protoc_insertion_point(destructor:HmiScenegraph.TScene)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TScene::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.renderpass_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.root_;
  if (this != internal_default_instance()) delete _impl_.materiallibrary_;
}

void TScene::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TScene::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiScenegraph.TScene)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.renderpass_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.root_ != nullptr);
      _impl_.root_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.materiallibrary_ != nullptr);
      _impl_.materiallibrary_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TScene::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .HmiScenegraph.TNode root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .HmiScenegraph.TMaterialLib materialLibrary = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_materiallibrary(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .HmiScenegraph.TRenderPass renderPass = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_renderpass(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TScene::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiScenegraph.TScene)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .HmiScenegraph.TNode root = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::root(this),
        _Internal::root(this).GetCachedSize(), target, stream);
  }

  // optional .HmiScenegraph.TMaterialLib materialLibrary = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::materiallibrary(this),
        _Internal::materiallibrary(this).GetCachedSize(), target, stream);
  }

  // repeated .HmiScenegraph.TRenderPass renderPass = 4 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_renderpass_size()); i < n; i++) {
    const auto& repfield = this->_internal_renderpass(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiScenegraph.TScene)
  return target;
}

size_t TScene::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiScenegraph.TScene)
  size_t total_size = 0;

  // required .HmiScenegraph.TNode root = 1;
  if (_internal_has_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.root_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HmiScenegraph.TRenderPass renderPass = 4 [deprecated = true];
  total_size += 1UL * this->_internal_renderpass_size();
  for (const auto& msg : this->_impl_.renderpass_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .HmiScenegraph.TMaterialLib materialLibrary = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.materiallibrary_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TScene::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TScene::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TScene::GetClassData() const { return &_class_data_; }


void TScene::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TScene*>(&to_msg);
  auto& from = static_cast<const TScene&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:HmiScenegraph.TScene)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.renderpass_.MergeFrom(from._impl_.renderpass_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_root()->::HmiScenegraph::TNode::MergeFrom(
          from._internal_root());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_materiallibrary()->::HmiScenegraph::TMaterialLib::MergeFrom(
          from._internal_materiallibrary());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TScene::CopyFrom(const TScene& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiScenegraph.TScene)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TScene::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.renderpass_))
    return false;
  if (_internal_has_root()) {
    if (!_impl_.root_->IsInitialized()) return false;
  }
  if (_internal_has_materiallibrary()) {
    if (!_impl_.materiallibrary_->IsInitialized()) return false;
  }
  return true;
}

void TScene::InternalSwap(TScene* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.renderpass_.InternalSwap(&other->_impl_.renderpass_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TScene, _impl_.materiallibrary_)
      + sizeof(TScene::_impl_.materiallibrary_)
      - PROTOBUF_FIELD_OFFSET(TScene, _impl_.root_)>(
          reinterpret_cast<char*>(&_impl_.root_),
          reinterpret_cast<char*>(&other->_impl_.root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TScene::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Scenegraph_2eproto_getter, &descriptor_table_Scenegraph_2eproto_once,
      file_level_metadata_Scenegraph_2eproto[33]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace HmiScenegraph
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TResourceCacheId*
Arena::CreateMaybeMessage< ::HmiScenegraph::TResourceCacheId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TResourceCacheId >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TUniform*
Arena::CreateMaybeMessage< ::HmiScenegraph::TUniform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TUniform >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TCamera*
Arena::CreateMaybeMessage< ::HmiScenegraph::TCamera >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TCamera >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBlendMode*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBlendMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBlendMode >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TStencilMode*
Arena::CreateMaybeMessage< ::HmiScenegraph::TStencilMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TStencilMode >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TScissorTest*
Arena::CreateMaybeMessage< ::HmiScenegraph::TScissorTest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TScissorTest >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderMode_TColorWrite*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderMode_TColorWrite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderMode_TColorWrite >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderMode*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderMode >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TAttributeMapping*
Arena::CreateMaybeMessage< ::HmiScenegraph::TAttributeMapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TAttributeMapping >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TShader*
Arena::CreateMaybeMessage< ::HmiScenegraph::TShader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TShader >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBitmap_TCubeMapResource*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBitmap_TCubeMapResource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBitmap_TCubeMapResource >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBitmap_TCubeMap*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBitmap_TCubeMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBitmap_TCubeMap >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBitmap*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBitmap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBitmap >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TTexture*
Arena::CreateMaybeMessage< ::HmiScenegraph::TTexture >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TTexture >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TMaterial*
Arena::CreateMaybeMessage< ::HmiScenegraph::TMaterial >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TMaterial >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TMesh_TAttributeParamteter*
Arena::CreateMaybeMessage< ::HmiScenegraph::TMesh_TAttributeParamteter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TMesh_TAttributeParamteter >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TMesh*
Arena::CreateMaybeMessage< ::HmiScenegraph::TMesh >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TMesh >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderLayer*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBoundingVolume_TBoundingBox*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBoundingVolume_TBoundingBox >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBoundingVolume_TBoundingBox >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBoundingVolume_TBoundingSphere*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBoundingVolume_TBoundingSphere >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBoundingVolume_TBoundingSphere >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBoundingVolume*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBoundingVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBoundingVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TNode_TRenderPassName*
Arena::CreateMaybeMessage< ::HmiScenegraph::TNode_TRenderPassName >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TNode_TRenderPassName >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TNode*
Arena::CreateMaybeMessage< ::HmiScenegraph::TNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TNode >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderOrder*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderOrder >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderOrder >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderOrderBin*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderOrderBin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderOrderBin >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderTarget*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TClearMode*
Arena::CreateMaybeMessage< ::HmiScenegraph::TClearMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TClearMode >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TDiscardFramebuffer*
Arena::CreateMaybeMessage< ::HmiScenegraph::TDiscardFramebuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TDiscardFramebuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TRenderPass*
Arena::CreateMaybeMessage< ::HmiScenegraph::TRenderPass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TRenderPass >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TBlitPass*
Arena::CreateMaybeMessage< ::HmiScenegraph::TBlitPass >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TBlitPass >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TGeometry_TAttributeParamteter*
Arena::CreateMaybeMessage< ::HmiScenegraph::TGeometry_TAttributeParamteter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TGeometry_TAttributeParamteter >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TGeometry*
Arena::CreateMaybeMessage< ::HmiScenegraph::TGeometry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TGeometry >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TMaterialLib*
Arena::CreateMaybeMessage< ::HmiScenegraph::TMaterialLib >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TMaterialLib >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiScenegraph::TScene*
Arena::CreateMaybeMessage< ::HmiScenegraph::TScene >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiScenegraph::TScene >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
